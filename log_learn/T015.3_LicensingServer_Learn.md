# T015.3 - Cloud Licensing Server Learning Notes

**Subtask**: 15.3 - Set up cloud licensing server (Lambda/Firebase)
**Date**: 2025-12-09

---

## Key Learnings

### 1. License Key Format Design

The XXXX-XXXX-XXXX-XXXX format provides:
- **Readability**: Dashes help users read and type keys
- **Verification**: Easy visual grouping for error checking
- **Flexibility**: 16 alphanumeric chars = 36^16 combinations (~7.96 × 10^24)

```typescript
// Normalization handles user input variations
function normalizeLicenseKey(key: string): string {
  return key.toUpperCase()
    .replace(/\s/g, '')
    .replace(/^([A-Z0-9]{4})([A-Z0-9]{4})([A-Z0-9]{4})([A-Z0-9]{4})$/, '$1-$2-$3-$4');
}
```

### 2. Hardware Fingerprint Binding

Binding licenses to hardware fingerprints prevents:
- License sharing between machines
- Unauthorized distribution
- Multiple simultaneous uses

The fingerprint is only bound on first activation, allowing transfers:
```typescript
if (license.hardwareFingerprint === '') {
  // Not yet bound - will bind on activation
  return true;
}
return license.hardwareFingerprint === fingerprint;
```

### 3. License State Machine

```
pending → active → (expired | revoked | suspended)
                ↓
           deactivated (returns to pending with reduced count)
```

Status transitions are server-controlled to prevent tampering.

### 4. Offline Validation Strategy

For offline scenarios:
1. Cache last valid server response locally
2. Include a grace period (e.g., 7 days)
3. Require periodic online validation

```typescript
interface CachedValidation {
  license: License;
  validatedAt: Date;
  validUntil: Date;  // Online check required after this
}
```

### 5. Feature Flags in Licenses

Embedding features in licenses enables:
- Fine-grained access control
- A/B testing
- Gradual rollouts
- Tier differentiation

```typescript
function hasFeature(license: License, feature: string): boolean {
  if (license.features.includes('unlimited')) return true;
  return license.features.includes(feature);
}
```

### 6. Mock Server Pattern

Creating a mock server for testing provides:
- Predictable test environments
- No network dependencies
- Fast test execution
- Full control over responses

```typescript
class MockLicensingServer {
  private licenses = new Map<string, License>();

  simulateActivation(request): LicenseActivationResponse {
    // Reproduce server logic locally
  }
}
```

---

## TypeScript Patterns

### 1. Discriminated Union for Responses

```typescript
type LicenseResponse =
  | { success: true; license: License }
  | { success: false; error: string; errorCode: string };
```

### 2. Branded Types for Safety

```typescript
type LicenseKey = string & { readonly __brand: 'LicenseKey' };

function validateKey(key: string): LicenseKey | null {
  if (isValidLicenseKeyFormat(key)) {
    return normalizeLicenseKey(key) as LicenseKey;
  }
  return null;
}
```

### 3. Date Serialization

JSON.stringify converts Date to ISO string, but JSON.parse returns strings:
```typescript
function deserializeLicense(json: string): License | null {
  const data = JSON.parse(json);
  // Restore Date objects
  if (data.activatedAt) data.activatedAt = new Date(data.activatedAt);
  if (data.expiresAt) data.expiresAt = new Date(data.expiresAt);
  return data;
}
```

---

## Security Considerations

### 1. API Key Protection

Never expose API keys in client code:
```typescript
// BAD: Key in client
const client = new LicensingClient({ apiKey: 'secret-key' });

// GOOD: Key in environment
const client = new LicensingClient({ apiKey: process.env.LICENSE_API_KEY });
```

### 2. Fingerprint Tampering

Hardware fingerprints should be:
- Computed fresh each time (not stored)
- Include multiple identifiers
- Be signed or encrypted in transit

### 3. Response Validation

Always validate server responses:
```typescript
function validateResponse(response: unknown): response is LicenseResponse {
  return typeof response === 'object'
    && response !== null
    && 'success' in response;
}
```

---

## Integration with Previous Components

### Hardware Fingerprint (T015.1 + T015.2)

```typescript
import { HardwareFingerprintService } from './HardwareFingerprint';
import { EnhancedFingerprintService } from './FallbackIdentifiers';

// Get robust fingerprint
const fingerprintService = new EnhancedFingerprintService();
const result = await fingerprintService.getFingerprint();

// Use for license activation
const activation = await client.activate({
  licenseKey: key,
  hardwareFingerprint: result.fingerprint,
});
```

---

## Error Handling Best Practices

### 1. Specific Error Codes

```typescript
type LicenseErrorCode =
  | 'INVALID_KEY'
  | 'NOT_FOUND'
  | 'EXPIRED'
  | 'REVOKED'
  | 'MAX_ACTIVATIONS'
  | 'FINGERPRINT_MISMATCH'
  | 'SERVER_ERROR';
```

### 2. User-Friendly Messages

```typescript
const errorMessages: Record<LicenseErrorCode, string> = {
  INVALID_KEY: 'The license key format is invalid',
  NOT_FOUND: 'This license key was not found',
  EXPIRED: 'Your license has expired',
  REVOKED: 'This license has been revoked',
  MAX_ACTIVATIONS: 'Maximum activations reached',
  FINGERPRINT_MISMATCH: 'License is activated on another device',
  SERVER_ERROR: 'Unable to contact licensing server',
};
```

### 3. Retry Strategy

```typescript
async function withRetry<T>(
  operation: () => Promise<T>,
  maxAttempts: number = 3
): Promise<T> {
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      return await operation();
    } catch (error) {
      if (attempt === maxAttempts) throw error;
      await delay(1000 * attempt); // Exponential backoff
    }
  }
  throw new Error('Retry failed');
}
```

---

## Testing Strategies

### 1. Time-Based Tests

```typescript
// Use fixed dates for reproducible tests
const fixedDate = new Date('2025-01-15T12:00:00Z');
jest.useFakeTimers().setSystemTime(fixedDate);

// Test expiry logic
const license = createTestLicense({
  expiresAt: new Date('2025-01-20T12:00:00Z'),
});
expect(calculateRemainingDays(license.expiresAt)).toBe(5);
```

### 2. State Transition Tests

```typescript
it('should transition pending → active on activation', () => {
  const license = createTestLicense({ status: 'pending' });
  server.addLicense(license);

  const result = server.simulateActivation({
    licenseKey: license.key,
    hardwareFingerprint: 'fp-123',
  });

  expect(result.license?.status).toBe('active');
});
```

---

## Next Steps

1. **T015.4**: Create license validation endpoint
   - Implement actual HTTP client
   - Add request signing
   - Handle network errors

2. **T015.5**: Implement license caching
   - Store validated licenses locally
   - Define cache invalidation rules
   - Handle offline mode

---

## References

- [License Key Generation Best Practices](https://en.wikipedia.org/wiki/Software_license)
- [Hardware Fingerprinting](https://en.wikipedia.org/wiki/Device_fingerprint)
- [REST API Security](https://owasp.org/www-project-api-security/)
