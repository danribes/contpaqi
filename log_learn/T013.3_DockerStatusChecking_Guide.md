# Docker Status Checking in Electron - Learning Guide

## Overview
How to check Docker daemon and container status from an Electron application using Node.js child processes.

## Key Concepts

### 1. Docker CLI Commands

#### Check Daemon Status
```bash
# Get Docker version (proves daemon is running)
docker info --format '{{.ServerVersion}}'
# Output: 24.0.7

# Quick version check
docker --version
# Output: Docker version 24.0.7, build afdd53b
```

#### List Running Containers
```bash
# Get container names only
docker ps --format '{{.Names}}'
# Output:
# mcp-container
# redis
# postgres

# Get more details
docker ps --format '{{.ID}}\t{{.Names}}\t{{.Status}}'
```

#### Inspect Container
```bash
# Get all details as JSON
docker inspect mcp-container --format '{{json .}}'

# Get specific fields
docker inspect mcp-container --format '{{.State.Status}}'
# Output: running

# Get health status
docker inspect mcp-container --format '{{.State.Health.Status}}'
# Output: healthy
```

### 2. Spawning Docker Commands in Node.js

```typescript
import { spawn } from 'child_process';

function runDockerCommand(args: string[]): Promise<string> {
  return new Promise((resolve, reject) => {
    const process = spawn('docker', args, { shell: true });
    let stdout = '';
    let stderr = '';

    process.stdout?.on('data', (data) => {
      stdout += data.toString();
    });

    process.stderr?.on('data', (data) => {
      stderr += data.toString();
    });

    process.on('close', (code) => {
      if (code === 0) {
        resolve(stdout.trim());
      } else {
        reject(new Error(stderr || `Exit code: ${code}`));
      }
    });

    process.on('error', reject);
  });
}
```

### 3. Timeout Pattern
```typescript
async function runWithTimeout(fn: () => Promise<T>, ms: number): Promise<T> {
  return new Promise((resolve, reject) => {
    const timeoutId = setTimeout(() => {
      reject(new Error('Timeout'));
    }, ms);

    fn()
      .then((result) => {
        clearTimeout(timeoutId);
        resolve(result);
      })
      .catch((err) => {
        clearTimeout(timeoutId);
        reject(err);
      });
  });
}
```

### 4. Class-Based Docker Manager

```typescript
export class DockerManager {
  private containerName: string;
  private timeout: number;

  constructor(containerName: string, timeout = 10000) {
    this.containerName = containerName;
    this.timeout = timeout;
  }

  async checkDaemonStatus() {
    // Check if docker daemon is running
  }

  async checkContainerStatus() {
    // Check if specific container is running
  }

  async getFullStatus() {
    // Combine all checks into comprehensive status
  }
}
```

### 5. Container State Detection

```typescript
async checkContainerStatus(): Promise<ContainerStatusResult> {
  const output = await this.runCommand(['ps', '--format', '{{.Names}}']);

  const containers = output
    .trim()
    .split('\n')
    .map(name => name.trim())
    .filter(Boolean);

  const isRunning = containers.some(name => name === this.containerName);

  return {
    containerState: isRunning ? 'running' : 'stopped',
    containerName: isRunning ? this.containerName : undefined,
  };
}
```

### 6. Health Check Detection

```typescript
async isContainerHealthy(): Promise<boolean> {
  try {
    const output = await this.runCommand([
      'inspect',
      this.containerName,
      '--format',
      '{{.State.Health.Status}}'
    ]);
    return output.trim().toLowerCase() === 'healthy';
  } catch {
    return false;
  }
}
```

## Common Docker States

| State | Meaning |
|-------|---------|
| running | Container is running |
| stopped | Container exists but not running |
| unknown | Cannot determine state |
| healthy | Health check passing |
| unhealthy | Health check failing |
| starting | Container/health check initializing |

## Error Handling

### Docker Daemon Not Running
```typescript
// Exit code 1 + error message
// "Cannot connect to the Docker daemon at..."
{
  isDaemonRunning: false,
  error: 'Cannot connect to Docker daemon'
}
```

### Docker Not Installed
```typescript
// spawn ENOENT error
{
  isDaemonRunning: false,
  error: 'spawn ENOENT'
}
```

### Container Not Found
```typescript
// docker inspect returns exit code 1
// "No such container: mcp-container"
{
  containerState: 'stopped'
}
```

## Best Practices

1. **Use exact name matching** - `name === containerName` not `includes()`
2. **Set reasonable timeouts** - 10 seconds is usually enough
3. **Handle all error cases** - spawn errors, exit codes, empty output
4. **Include timestamps** - Know when status was last checked
5. **Use `--format` flags** - Parse structured output, not human-readable
6. **Use `shell: true`** - Ensures Docker CLI is found in PATH

## Electron Integration

### IPC Pattern
```typescript
// Main process
ipcMain.handle('docker:status', async () => {
  return dockerManager.getFullStatus();
});

// Renderer process (via preload)
const status = await window.electronAPI.dockerStatus();
if (!status.isDaemonRunning) {
  showDockerNotRunningError();
}
```

### Status Polling
```typescript
// Poll every 5 seconds
setInterval(async () => {
  const status = await window.electronAPI.dockerStatus();
  updateStatusIndicator(status);
}, 5000);
```

## Key Takeaways

1. Use `docker info` to check daemon, `docker ps` for containers
2. Always set timeouts on Docker commands
3. Parse `--format` output instead of regex on human output
4. Handle spawn errors (Docker not installed)
5. Use exact string matching for container names
6. Return comprehensive status objects with timestamps
