# Learning Guide: Subtask 16.1 - PyArmor Configuration

## What is Code Obfuscation?

Code obfuscation is the process of transforming source code into a form that is difficult to understand or reverse-engineer while maintaining its functionality. It's a common technique for:

- **Protecting intellectual property**: Preventing competitors from stealing algorithms
- **License enforcement**: Making it harder to bypass license checks
- **Security by obscurity**: Adding a layer of protection (not a replacement for proper security)

---

## Why PyArmor?

PyArmor is a tool designed specifically for obfuscating Python code. We chose PyArmor because:

### Advantages
1. **Python-specific**: Designed for Python's unique challenges
2. **Maintains functionality**: Obfuscated code runs identically to original
3. **Cross-platform**: Works on Linux, Windows, macOS
4. **Active development**: Regular updates and security patches
5. **Production-ready**: Used by thousands of commercial projects

### PyArmor 8.x vs 7.x
```
PyArmor 7.x:
- Command-line based configuration
- Separate license files
- Older obfuscation algorithms

PyArmor 8.x (what we use):
- JSON configuration file
- Improved obfuscation techniques
- Better performance
- Simplified commands
```

---

## Configuration File Explained

### pyarmor.json Structure

```json
{
  "project": {
    "name": "contpaqi-ai-bridge",
    "version": "1.0.0"
  }
}
```
**Project metadata** - identifies what's being obfuscated.

```json
{
  "obfuscation": {
    "src": "src",
    "output": "dist",
    "entry": "main.py",
    "recursive": true,
    "includes": ["*.py"],
    "excludes": ["test_*.py", "tests/"]
  }
}
```
**Obfuscation settings**:
- `src`: Where to find source files
- `output`: Where to put obfuscated files
- `entry`: Main script (entry point)
- `recursive`: Include subdirectories
- `includes`: Patterns to include
- `excludes`: Patterns to exclude

```json
{
  "settings": {
    "python_version": "3.9",
    "restrict_mode": 2,
    "obf_code": 2,
    "obf_module": 1
  }
}
```
**Security settings**:
- `python_version`: Target Python version
- `restrict_mode`: How restricted the code is
- `obf_code`: Code obfuscation level (0-2)
- `obf_module`: Module obfuscation level (0-1)

---

## Restriction Modes

| Mode | Name | Description |
|------|------|-------------|
| 0 | None | Code can run anywhere |
| 1 | Basic | Must import from obfuscated module |
| 2 | High | Can only run in obfuscated environment |
| 3 | Very High | Additional runtime checks |

**We use Mode 2** for production code to prevent:
- Copying individual functions
- Importing obfuscated modules into plain code
- Easy debugging/inspection

---

## Why Separate Dev Requirements?

```
requirements.txt          # Runtime only (in container)
requirements-dev.txt      # Build/dev tools (not in container)
```

### Runtime vs Build-time Dependencies

**Runtime (requirements.txt)**:
- Things the application NEEDS to run
- Included in Docker container
- Keep as small as possible

**Build-time (requirements-dev.txt)**:
- Things for development/building
- NOT in production container
- Testing, linting, obfuscation tools

PyArmor is a BUILD tool, not a RUNTIME tool. The obfuscated code runs without PyArmor installed.

---

## Obfuscation Script Design

### Why a Python Script?

We could just run `pyarmor gen ...` directly, but a script provides:

1. **Configuration loading**: Read settings from pyarmor.json
2. **Validation**: Check PyArmor is installed
3. **File discovery**: Find all files to obfuscate
4. **Error handling**: Graceful error messages
5. **Automation**: Easy to integrate into CI/CD

### Script Structure

```python
class PyArmorObfuscator:
    def __init__(self, config_path):
        self.config = self._load_config()

    def obfuscate(self):
        # 1. Check PyArmor installed
        # 2. Find Python files
        # 3. Build PyArmor command
        # 4. Run obfuscation
        # 5. Verify output
```

### Command-Line Interface

```bash
python scripts/obfuscate.py --help
```

Options:
- `--config`: Custom config file
- `--output`: Override output directory
- `--dry-run`: See what would happen without doing it
- `--clean`: Delete output directory first
- `--verbose`: More detailed logging

---

## What Gets Obfuscated?

### Primary Targets
| File | Contains | Why Obfuscate? |
|------|----------|----------------|
| main.py | API endpoints | Protect API logic |
| inference.py | AI pipeline | Core business logic |
| models/*.py | AI models | Proprietary algorithms |
| utils/ocr.py | OCR processing | Processing techniques |

### What's Excluded
| Pattern | Reason |
|---------|--------|
| test_*.py | Tests don't need protection |
| __pycache__ | Bytecode, not source |
| *.pyc | Already compiled |

---

## Build Pipeline Integration

### Development Flow
```
1. Developer writes code in src/
2. Tests run against unobfuscated src/
3. Ready for release? Run obfuscation
4. Docker builds with dist/ (obfuscated)
5. Deploy obfuscated container
```

### Dockerfile Change (coming in Subtask 16.3)
```dockerfile
# Before (development)
COPY src/ ./src/

# After (production)
COPY dist/ ./src/
```

---

## Testing Obfuscation Configuration

### What We Test

1. **Requirements exist**: PyArmor in dev requirements
2. **Version pinned**: Reproducible builds
3. **Config valid**: JSON structure correct
4. **Files exist**: All targets present
5. **Script works**: No syntax errors

### Why Not Test Actual Obfuscation?

Actual obfuscation tests require:
- PyArmor installed (not in test environment)
- Running the obfuscated code
- Complex setup

These are covered in Subtask 16.6 (integration testing).

---

## Common Pitfalls

### 1. Forgetting Recursive Imports
```python
# If A imports B, both must be obfuscated together
# Otherwise: ImportError
```
Solution: Use `recursive: true` in config.

### 2. Hardcoded Paths
```python
# Bad
with open('/home/user/src/data.json')

# Good
from pathlib import Path
Path(__file__).parent / 'data.json'
```
Obfuscation can change file locations.

### 3. Dynamic Code
```python
# This might break
exec("some_code")
eval("expression")
```
PyArmor can handle some dynamic code, but test carefully.

### 4. Missing Dependencies
Obfuscated code still needs all runtime dependencies. Only PyArmor itself is excluded.

---

## Security Considerations

### What Obfuscation Protects Against
- Casual inspection of source code
- Simple copy-paste theft
- Quick reverse engineering

### What Obfuscation Does NOT Protect Against
- Determined attackers with debugging tools
- Memory inspection at runtime
- API-level analysis

**Obfuscation is ONE layer of security, not a complete solution.**

Additional layers:
- License validation (Task 15)
- API authentication
- Server-side processing for critical operations

---

## Summary

| Concept | Key Point |
|---------|-----------|
| PyArmor | Python-specific obfuscation tool |
| Version | Use 8.x for latest features |
| Config | JSON-based pyarmor.json |
| Dev vs Runtime | PyArmor is build-time only |
| Script | Automated obfuscation with validation |
| Security | One layer, not complete protection |

---

## Next Steps

After this subtask:
1. **16.2**: Actually run obfuscation on main.py and inference.py
2. **16.3**: Update Dockerfile to use obfuscated code
3. **16.4-16.5**: Set up Dotfuscator for C# code
4. **16.6**: Test that obfuscated code works correctly
