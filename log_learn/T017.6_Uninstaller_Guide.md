# Learning Guide: Subtask 17.6 - Create Uninstaller Logic

## Overview

This guide explains how to implement comprehensive uninstallation logic for Windows applications. A proper uninstaller should remove all traces of the application while giving users control over what gets removed.

## Why Dedicated Uninstaller Logic?

1. **Complete Cleanup**: Remove all components (services, Docker, data)
2. **User Control**: Options to keep or remove user data
3. **Graceful Failures**: Continue cleanup even if some steps fail
4. **Silent Mode**: Support for automated/scripted uninstallation
5. **Registry Cleanup**: Remove application registration

## Cleanup Components

### 1. Windows Services

**Stop the Service First:**
```powershell
$service = Get-Service -Name "ServiceName" -ErrorAction SilentlyContinue
if ($service.Status -eq 'Running') {
    Stop-Service -Name "ServiceName" -Force

    # Wait for stop
    $timeout = 30
    while ((Get-Service -Name "ServiceName").Status -ne 'Stopped' -and $timeout -gt 0) {
        Start-Sleep -Seconds 1
        $timeout--
    }
}
```

**Remove the Service:**
```powershell
# Using sc.exe (Windows built-in)
sc.exe delete "ServiceName"

# Or PowerShell 6+ (if available)
Remove-Service -Name "ServiceName"
```

### 2. Docker Resources

**Stop Containers:**
```powershell
# Find containers using the image
$containers = docker ps -a --filter "ancestor=myimage:latest" --format "{{.ID}}"

foreach ($id in $containers) {
    docker stop $id
    docker rm $id
}
```

**Remove Images:**
```powershell
docker rmi myimage:latest
```

**Handle Docker Not Running:**
```powershell
function Test-DockerAvailable {
    try {
        $result = & docker info 2>&1
        return $LASTEXITCODE -eq 0
    }
    catch {
        return $false
    }
}

if (-not (Test-DockerAvailable)) {
    Write-Warning "Docker not available, skipping Docker cleanup"
    return
}
```

### 3. Application Data

**Selective Cleanup:**
```powershell
param(
    [switch]$KeepData,    # Keep all user data
    [switch]$RemoveAll    # Remove everything
)

if ($KeepData) {
    Write-Log "Preserving user data"
    return
}

$foldersToRemove = if ($RemoveAll) {
    @("logs", "data", "config")
} else {
    @("logs", "data\temp")  # Keep config by default
}

foreach ($folder in $foldersToRemove) {
    $path = Join-Path $InstallPath $folder
    if (Test-Path $path) {
        Remove-Item -Path $path -Recurse -Force
    }
}
```

### 4. Registry Entries

**Remove Application Key:**
```powershell
$RegistryPath = "HKLM:\SOFTWARE\MyApplication"

if (Test-Path $RegistryPath) {
    Remove-Item -Path $RegistryPath -Recurse -Force
}
```

**Remove Environment Variables:**
```powershell
# Method 1: .NET Framework
[Environment]::SetEnvironmentVariable("MY_VAR", $null, "Machine")

# Method 2: Registry
$EnvPath = "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment"
Remove-ItemProperty -Path $EnvPath -Name "MY_VAR" -Force
```

## Error Handling Strategy

### Continue on Failure

Uninstallers should continue even if some steps fail:

```powershell
$errors = @()

try {
    Remove-Service
} catch {
    $errors += "Service removal: $($_.Exception.Message)"
}

try {
    Remove-DockerResources
} catch {
    $errors += "Docker cleanup: $($_.Exception.Message)"
}

# Report all errors at end
if ($errors.Count -gt 0) {
    Write-Warning "Some cleanup steps failed:"
    $errors | ForEach-Object { Write-Warning "  - $_" }
    exit 1  # Partial failure
}

exit 0  # Success
```

### SilentlyContinue

For non-critical operations:
```powershell
Remove-Item -Path $tempFolder -Recurse -Force -ErrorAction SilentlyContinue
```

## Integration with Inno Setup

### [UninstallRun] Section

Execute scripts before files are removed:
```pascal
[UninstallRun]
Filename: "{app}\scripts\uninstall.ps1"; \
    Parameters: "-Force -Quiet"; \
    Flags: runhidden waituntilterminated
```

### [UninstallDelete] Section

Remove specific files/folders:
```pascal
[UninstallDelete]
Type: filesandordirs; Name: "{app}\logs"
Type: filesandordirs; Name: "{app}\data\temp"
```

### CurUninstallStepChanged Procedure

Custom logic at uninstall stages:
```pascal
procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);
begin
  if CurUninstallStep = usPostUninstall then
  begin
    // Ask about removing user data
    if MsgBox('Remove all user data?', mbConfirmation, MB_YESNO) = IDYES then
    begin
      DelTree(ExpandConstant('{app}\data'), True, True, True);
    end;
  end;
end;
```

## User Experience

### Confirmation Prompts

```powershell
if (-not $Force -and -not $Quiet) {
    $confirm = Read-Host "Remove ContPAQi AI Bridge? (Y/N)"
    if ($confirm -ne 'Y') {
        Write-Host "Uninstallation cancelled"
        exit 0
    }
}
```

### Progress Feedback

```powershell
Write-Log "Removing Windows Service..."
# ... operation ...
Write-Log "Service removed" -Level Success

Write-Log "Cleaning up Docker resources..."
# ... operation ...
Write-Log "Docker cleanup complete" -Level Success
```

### Summary Report

```powershell
Write-Log "================================"
Write-Log "Cleanup Summary"
Write-Log "================================"
Write-Log "Windows Service: $serviceStatus"
Write-Log "Docker Resources: $dockerStatus"
Write-Log "Application Data: $dataStatus"
Write-Log "Registry Entries: $registryStatus"
```

## Best Practices

1. **Order Matters**: Stop services before removing files
2. **Check Existence**: Don't fail if item doesn't exist
3. **Continue on Error**: Complete as much cleanup as possible
4. **User Choice**: Allow users to keep their data
5. **Silent Mode**: Support automated uninstallation
6. **Logging**: Record what was removed (and what failed)
7. **Exit Codes**: Return meaningful codes for automation

## Exit Code Convention

| Code | Meaning |
|------|---------|
| 0 | Complete success |
| 1 | Partial success (some steps failed) |
| 2 | Critical failure |
| 3 | User cancelled |

## Summary

A comprehensive uninstaller should:
- Remove all application components in correct order
- Handle missing Docker gracefully
- Give users control over data removal
- Continue cleanup even if some steps fail
- Support both interactive and silent modes
- Provide clear feedback on what was removed
- Return meaningful exit codes for automation

The implementation in `uninstall.ps1` follows all these principles, ensuring a clean uninstallation experience.
