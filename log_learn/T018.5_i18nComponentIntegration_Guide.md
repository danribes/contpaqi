# T018.5 - i18n Component Integration Guide

**Subtask**: 18.5 - Update UI components to use translation keys
**Topic**: Integrating react-i18next into React Components

---

## Overview

This guide covers how to integrate the i18next internationalization framework into React components to support multiple languages. The pattern shown here enables dynamic language switching while maintaining clean, maintainable code.

---

## Prerequisites

- i18next and react-i18next installed
- Translation files (en.json, es.json) configured
- i18n initialization complete (see Task 18.2)

---

## Core Pattern: useTranslation Hook

### Basic Usage

```tsx
import { useTranslation } from 'react-i18next';

function MyComponent() {
  const { t } = useTranslation();

  return (
    <div>
      <h1>{t('page.title')}</h1>
      <button>{t('actions.submit')}</button>
    </div>
  );
}
```

### Key Points

1. **Hook must be at component top level** - Cannot be called conditionally
2. **Returns `t` function** - Use for translating keys
3. **Triggers re-render on language change** - Automatic UI updates

---

## Translation Key Mapping Pattern

### Creating Key Mapping Functions

When component logic needs to determine which translation key to use, create a mapping function:

```typescript
type AppStatus = 'starting' | 'ready' | 'error' | 'offline';

export function getStatusTextKey(status: AppStatus): string {
  const keyMap: Record<AppStatus, string> = {
    starting: 'status.starting',
    ready: 'status.ready',
    error: 'status.error',
    offline: 'status.offline',
  };
  return keyMap[status] || 'status.starting';
}
```

### Using in Component

```tsx
function StatusIndicator({ status }: { status: AppStatus }) {
  const { t } = useTranslation();

  return <span>{t(getStatusTextKey(status))}</span>;
}
```

### Benefits

- **Testable** - Key mapping can be unit tested independently
- **Type-safe** - TypeScript ensures valid status values
- **Reusable** - Same mapping used across components

---

## Handling Dynamic Values (Interpolation)

### Translation File

```json
{
  "batch": {
    "filesProcessed": "{{processed}} of {{total}} files processed",
    "daysRemaining": "{{days}} days remaining"
  }
}
```

### Component Usage

```tsx
function Progress({ processed, total }: { processed: number; total: number }) {
  const { t } = useTranslation();

  return (
    <span>
      {t('batch.filesProcessed', { processed, total })}
    </span>
  );
}
```

### Spanish Translation

```json
{
  "batch": {
    "filesProcessed": "{{processed}} de {{total}} archivos procesados"
  }
}
```

---

## Backward Compatibility

### Keeping Fallback Functions

When updating existing code, maintain backward compatibility:

```typescript
/**
 * Get translation key for status
 */
export function getStatusTextKey(status: AppStatus): string {
  const keyMap: Record<AppStatus, string> = { ... };
  return keyMap[status];
}

/**
 * Get display text (fallback for non-React contexts)
 * @deprecated Use getStatusTextKey with useTranslation hook
 */
export function getStatusText(status: AppStatus): string {
  switch (status) {
    case 'ready': return 'Ready';
    case 'starting': return 'Starting...';
    // ...
  }
}
```

### When to Use Each

| Context | Function to Use |
|---------|-----------------|
| React component | `t(getStatusTextKey(status))` |
| Test file | `getStatusText(status)` |
| Non-React utility | `getStatusText(status)` |

---

## Form Field Labels Pattern

### Define Key Constants

```typescript
export const FIELD_LABEL_KEYS: Record<string, string> = {
  rfcEmisor: 'invoice.form.rfcEmisor',
  rfcReceptor: 'invoice.form.rfcReceptor',
  fecha: 'invoice.form.fecha',
  subtotal: 'invoice.form.subtotal',
  iva: 'invoice.form.iva',
  total: 'invoice.form.total',
};
```

### Use in Component

```tsx
function FormField({ fieldName }: { fieldName: string }) {
  const { t } = useTranslation();

  return (
    <label>
      {t(FIELD_LABEL_KEYS[fieldName])}
      <input name={fieldName} />
    </label>
  );
}
```

---

## Multiple Translations in One Component

```tsx
function StatusBar({ status, isRetrying }: Props) {
  const { t } = useTranslation();

  return (
    <div>
      <span>{t(getStatusTextKey(status))}</span>
      <span>{t(getStatusBarMessageKey(status))}</span>
      <button>
        {isRetrying ? t('common.processing') : t('actions.retry')}
      </button>
    </div>
  );
}
```

---

## Testing i18n Components

### Mock Translation Function

```typescript
const mockTranslations = {
  en: {
    'status.ready': 'Ready',
    'status.starting': 'Starting...',
  },
  es: {
    'status.ready': 'Listo',
    'status.starting': 'Iniciando...',
  },
};

function createMockI18n(lang = 'en') {
  return {
    t: (key: string) => mockTranslations[lang][key] || key,
    changeLanguage: async (lng: string) => { /* ... */ },
  };
}
```

### Test Key Mapping

```typescript
test('should map status to correct key', () => {
  expect(getStatusTextKey('ready')).toBe('status.ready');
});

test('should translate to Spanish', async () => {
  const i18n = createMockI18n('es');
  expect(i18n.t('status.ready')).toBe('Listo');
});
```

---

## Best Practices

### 1. Consistent Key Naming

```
section.subsection.item

Examples:
- status.ready
- invoice.form.rfcEmisor
- validation.required
- errors.network
```

### 2. Keep Brand Names Untranslated

```json
{
  "app": {
    "name": "ContPAQi AI Bridge",
    "tagline": "Intelligent Invoice Processing"
  }
}
```

Spanish:
```json
{
  "app": {
    "name": "ContPAQi AI Bridge",
    "tagline": "Procesamiento Inteligente de Facturas"
  }
}
```

### 3. Use Formal Register for Spanish

- Use "usted" instead of "tú"
- "¿Está seguro?" not "¿Estás seguro?"

### 4. Include All Interpolation Variables

Both language files must have identical `{{variable}}` placeholders:

```json
// en.json
"daysRemaining": "{{days}} days remaining"

// es.json
"daysRemaining": "{{days}} días restantes"
```

---

## Common Pitfalls

### 1. Forgetting the Hook

```tsx
// WRONG - Missing hook
function Component() {
  return <span>{t('key')}</span>; // Error: t is not defined
}

// CORRECT
function Component() {
  const { t } = useTranslation();
  return <span>{t('key')}</span>;
}
```

### 2. Hardcoded Fallbacks

```tsx
// WRONG - Mixes translated and hardcoded
<span>{t('status') || 'Status'}</span>

// CORRECT - Let i18next handle fallbacks
<span>{t('status')}</span>
```

### 3. Missing Keys

Always ensure all keys exist in both language files. Use tests to verify:

```typescript
test('all en.json keys exist in es.json', () => {
  const enKeys = Object.keys(enTranslations);
  const esKeys = new Set(Object.keys(esTranslations));

  enKeys.forEach(key => {
    expect(esKeys.has(key)).toBe(true);
  });
});
```

---

## Files Reference

| File | Purpose |
|------|---------|
| `src/i18n/index.ts` | i18next initialization |
| `src/i18n/locales/en.json` | English translations |
| `src/i18n/locales/es.json` | Spanish translations |
| `src/components/StatusIndicator.tsx` | Example i18n component |
| `tests/i18n-component-integration.test.ts` | Translation tests |

---

## Related Tasks

- **Task 18.2**: i18n framework setup
- **Task 18.3**: English language file (en.json)
- **Task 18.4**: Spanish language file (es.json)
- **Task 18.6**: Language switcher component
