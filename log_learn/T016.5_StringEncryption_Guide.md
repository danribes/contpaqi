# Learning Guide: Subtask 16.5 - Enable String Encryption

## What Is String Encryption?

String encryption transforms literal strings in code into encrypted data that is decrypted at runtime.

```
┌─────────────────────────────────────────────────────────┐
│ Before Encryption                                       │
│                                                         │
│ api_key = "sk_live_abc123xyz"                          │
│ db_url = "postgres://user:pass@host:5432/db"           │
└────────────────────────┬────────────────────────────────┘
                         │ Encryption
                         ▼
┌─────────────────────────────────────────────────────────┐
│ After Encryption                                        │
│                                                         │
│ api_key = decrypt(b'\x4a\x7b\x2c...')                  │
│ db_url = decrypt(b'\x89\x1f\x3a...')                   │
└─────────────────────────────────────────────────────────┘
```

---

## Why Encrypt Strings?

### The Problem
```bash
# Anyone can extract strings from binaries
$ strings app.dll | grep -i "password\|api\|key"
API_KEY=sk_live_abc123xyz
DB_PASSWORD=super_secret
```

### The Solution
Encrypted strings appear as binary blobs:
```bash
$ strings obfuscated_app.dll | grep -i "password"
# No readable output
```

---

## Python String Encryption (PyArmor)

### obf_code Levels

| Level | Protection |
|-------|------------|
| 0 | No obfuscation |
| 1 | Basic bytecode obfuscation |
| 2 | Enhanced + string encryption |

### Configuration

```json
{
  "settings": {
    "obf_code": 2
  },
  "string_encryption": {
    "enabled": true,
    "selective": true,
    "patterns": ["api_key", "password", "secret"]
  }
}
```

### How It Works

1. PyArmor scans source for string literals
2. Matches against defined patterns
3. Encrypts matching strings
4. Injects decryption at runtime

```python
# Original
api_key = "sk_live_abc123"

# After obfuscation (conceptual)
api_key = __pyarmor_decrypt__(b'\x89\x4a...')
```

---

## C# String Encryption (Dotfuscator)

### Community vs Professional

| Feature | Community | Professional |
|---------|-----------|--------------|
| Renaming | Yes | Yes |
| String Encryption | Limited | Full |
| Control Flow | No | Yes |

### Professional Configuration

```xml
<stringencrypt>
  <option>all</option>

  <includelist>
    <type name="MyApp.Services.*" regex="true" />
  </includelist>

  <excludelist>
    <type name="MyApp.Models.*" regex="true" />
  </excludelist>
</stringencrypt>
```

### Community Alternative

For Community Edition, implement custom encryption:

```csharp
public static class StringProtection
{
    public static string Decode(string encoded)
    {
        byte[] data = Convert.FromBase64String(encoded);
        // XOR or AES decrypt
        return Encoding.UTF8.GetString(decrypted);
    }
}

// Usage
string apiKey = StringProtection.Decode("ZW5jb2RlZA==");
```

---

## Sensitive String Categories

### API Credentials
```
api_key, api_secret, bearer_token, oauth_token
```

### Connection Strings
```
database_url, redis_url, connection_string
host, port, endpoint
```

### Authentication
```
password, secret, credential, auth_token
```

### Application-Specific
```
license_key, contpaqi, sdk_path
```

---

## Selective Encryption

### Why Selective?

Not all strings need encryption:
- Log messages (DEBUG, INFO, ERROR)
- Common literals (utf-8, application/json)
- Public constants

### Pattern-Based Selection

```json
"patterns": [
  "api_key",     // Encrypt strings containing "api_key"
  "password",    // Encrypt strings containing "password"
  "secret"       // Encrypt strings containing "secret"
],
"exclude_patterns": [
  "DEBUG",       // Don't encrypt log levels
  "utf-8"        // Don't encrypt common encodings
]
```

---

## Security Limitations

### Runtime Visibility

**Important Warning**: Encrypted strings are decrypted at runtime!

```
┌─────────────────────────────────────┐
│ Encrypted (in binary)               │
│ b'\x4a\x7b\x2c...'                  │
└────────────────┬────────────────────┘
                 │ Runtime Decryption
                 ▼
┌─────────────────────────────────────┐
│ Decrypted (in memory)               │
│ "sk_live_abc123xyz"                 │ ← Visible to debugger!
└─────────────────────────────────────┘
```

### Attacks That Still Work

1. **Memory Inspection** - Debugger can see decrypted strings
2. **Memory Dumps** - Core dumps contain decrypted data
3. **API Monitoring** - Network traffic still visible
4. **Decompiler + Time** - Determined attacker can find decrypt routine

---

## Defense in Depth

String encryption is ONE layer:

```
┌─────────────────────────────────────────────────────────┐
│ Layer 1: String Encryption                              │
│   - Prevents casual extraction                          │
├─────────────────────────────────────────────────────────┤
│ Layer 2: Code Obfuscation                               │
│   - Renaming, control flow                              │
├─────────────────────────────────────────────────────────┤
│ Layer 3: Environment Variables                          │
│   - Secrets not in code at all                          │
├─────────────────────────────────────────────────────────┤
│ Layer 4: Secure Configuration                           │
│   - Encrypted config files                              │
├─────────────────────────────────────────────────────────┤
│ Layer 5: Runtime Protection                             │
│   - Anti-debugging, integrity checks                    │
└─────────────────────────────────────────────────────────┘
```

---

## Best Practices

### DO:
- Encrypt API keys and secrets
- Use selective encryption
- Combine with other obfuscation
- Document encrypted string patterns
- Test decryption works at runtime

### DON'T:
- Rely solely on string encryption
- Encrypt ALL strings (performance)
- Hardcode production secrets
- Skip environment variables
- Assume complete protection

---

## Testing String Encryption

### Verify Encryption Applied

```bash
# Check for readable sensitive strings
strings obfuscated_binary | grep -i "api_key\|password"

# Should return nothing if properly encrypted
```

### Runtime Test

```python
def test_encrypted_strings_work():
    """Verify decryption works at runtime."""
    config = load_config()

    # String should be decrypted and usable
    assert config.api_key is not None
    assert len(config.api_key) > 0
```

---

## Performance Impact

| Aspect | Impact |
|--------|--------|
| Binary Size | +5-10% |
| Startup Time | +50-100ms |
| Per-string | ~1ms |
| Memory | Negligible |

### Optimization

- Cache decrypted strings
- Decrypt at startup, not on-demand
- Exclude high-frequency strings

---

## Summary

| Concept | Key Point |
|---------|-----------|
| Purpose | Hide sensitive literals |
| Python | PyArmor obf_code=2 |
| C# Pro | stringencrypt section |
| C# Community | Custom helper |
| Limitation | Runtime visibility |
| Strategy | Defense in depth |

---

## Next Steps

After this subtask:
1. **16.6**: Test obfuscated code functionality
2. Verify all components work after obfuscation
3. Create end-to-end test with obfuscated code
