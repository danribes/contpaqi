# T008.5 Row Intersection Logic - Learning Guide

## Overview
This guide explains how the `_assign_words_to_rows()` method assigns OCR words to table rows for line item extraction.

## The Problem

After OCR and table detection, we have:
1. **Words**: Text extracted from the entire image
2. **Rows**: Bounding boxes of table rows

We need to determine which words belong to which row:

```
┌─────────────────────────────────────────────────┐
│  FACTURA                    ← Not in table      │
├─────────────────────────────────────────────────┤
│  Descripción │ Cant │ Precio │ Importe │ Row 0 │
├─────────────────────────────────────────────────┤
│  Producto A  │  2   │ $500   │ $1,000  │ Row 1 │
├─────────────────────────────────────────────────┤
│  Producto B  │  1   │ $160   │ $160    │ Row 2 │
└─────────────────────────────────────────────────┘
│  TOTAL: $1,160              ← Not in table      │
```

## Center Y Algorithm

We use the word's vertical center to determine row membership:

```
Word bbox: (x1=100, y1=50, x2=200, y2=70)
                         │
                         ▼
         center_y = (50 + 70) / 2 = 60
                         │
                         ▼
         Is 60 within row's y range?

Row bbox: (x1=40, y1=40, x2=500, y2=80)
                   │           │
                   └───────────┘
                    y range: 40-80
                         │
                         ▼
                40 <= 60 <= 80 ✓
                         │
                         ▼
              Word assigned to this row
```

## Why Center Y?

### Alternative: Full Overlap
```python
# Requires entire word to be inside row
if box[1] >= row_y1 and box[3] <= row_y2:
```
❌ Problem: Words overlapping row boundaries are missed

### Alternative: Any Overlap
```python
# Any vertical overlap counts
if box[3] >= row_y1 and box[1] <= row_y2:
```
❌ Problem: Words may be assigned to multiple rows

### Center Y (Our Choice)
```python
# Word center must be inside row
center_y = (box[1] + box[3]) / 2
if row_y1 <= center_y <= row_y2:
```
✅ Benefits:
- Each word assigned to exactly one row
- Handles slight overlaps gracefully
- Intuitive: "where is the word primarily located?"

## Inclusive Boundaries

We use `<=` for boundaries:

```python
if row_bbox[1] <= word_center_y <= row_bbox[3]:
```

This means words exactly on the boundary are included:
- `center_y == row_y1` → included
- `center_y == row_y2` → included

## Result Structure

Each line item contains:

```python
{
    'row_index': 0,      # Original row index
    'words': [           # Words in reading order
        {'word': 'Descripción', 'bbox': (50, 100, 150, 120)},
        {'word': 'Cant', 'bbox': (200, 100, 250, 120)},
    ],
    'bbox': (40, 95, 510, 125)  # Row bounding box
}
```

## Empty Row Handling

Rows without any words are excluded:

```python
if row_words:  # Only add if non-empty
    line_items.append({...})
```

This is useful because:
- Some detected "rows" may be table borders
- Header detection may produce extra rows
- Cleaner output for downstream processing

## Integration Example

```python
# From OCR
words = ['Descripción', 'Cant', 'Producto', 'A', '2']
boxes = [(50,100,150,120), (200,100,250,120), (50,130,120,150), ...]

# From TATR
rows = [
    {'bbox': (40, 95, 510, 125), 'index': 0},   # Header
    {'bbox': (40, 125, 510, 155), 'index': 1},  # Data row
]

# Assign words to rows
line_items = engine._assign_words_to_rows(words, boxes, rows)

# Result:
# line_items[0]['words'] = [Descripción, Cant] (header)
# line_items[1]['words'] = [Producto, A, 2] (data)
```

## Key Takeaways

1. **Center Y algorithm**: Simple and effective
2. **Inclusive boundaries**: Words on edges are included
3. **Empty rows excluded**: Cleaner output
4. **Preserves word order**: Words in order they appear
5. **Keeps original bbox**: For further processing
