# BackgroundService and Channels - Learning Guide

## Overview
How to create background processing services in ASP.NET Core.

## Key Concepts

### 1. BackgroundService
Base class for long-running background tasks:
```csharp
public class MyService : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            await DoWorkAsync();
            await Task.Delay(1000, stoppingToken);
        }
    }
}
```

### 2. IHostedService Lifecycle
```csharp
public interface IHostedService
{
    Task StartAsync(CancellationToken cancellationToken);
    Task StopAsync(CancellationToken cancellationToken);
}
```

**Lifecycle Events:**
1. Host starts
2. StartAsync called
3. ExecuteAsync runs in background
4. Host stops
5. StopAsync called

### 3. System.Threading.Channels
High-performance producer/consumer:
```csharp
// Create bounded channel
var channel = Channel.CreateBounded<Job>(new BoundedChannelOptions(100)
{
    FullMode = BoundedChannelFullMode.Wait
});

// Producer
await channel.Writer.WriteAsync(job);

// Consumer
await foreach (var job in channel.Reader.ReadAllAsync(token))
{
    await ProcessAsync(job);
}
```

### 4. Channel Options
| Option | Description |
|--------|-------------|
| Bounded | Fixed capacity, blocks when full |
| Unbounded | No limit (watch memory!) |
| FullMode.Wait | Block producer when full |
| FullMode.DropOldest | Drop oldest item |
| SingleReader | Optimize for one consumer |

### 5. Registration Pattern
```csharp
// Singleton for DI access
builder.Services.AddSingleton<JobQueueService>();

// Also as hosted service
builder.Services.AddHostedService(sp =>
    sp.GetRequiredService<JobQueueService>());
```

## Patterns

### Producer-Consumer
```csharp
public class QueueService : BackgroundService
{
    private readonly Channel<Job> _queue;

    public async Task EnqueueAsync(Job job)
    {
        await _queue.Writer.WriteAsync(job);
    }

    protected override async Task ExecuteAsync(CancellationToken token)
    {
        await foreach (var job in _queue.Reader.ReadAllAsync(token))
        {
            await ProcessAsync(job);
        }
    }
}
```

## Best Practices

1. **Respect CancellationToken** - For graceful shutdown
2. **Use bounded channels** - Prevent memory exhaustion
3. **Handle exceptions** - Don't let service crash
4. **Log lifecycle events** - For debugging
5. **Singleton + HostedService** - For DI access

## Key Takeaways

1. BackgroundService handles lifecycle automatically
2. Channels are thread-safe and async-friendly
3. Bounded channels provide backpressure
4. Singleton registration allows controller access
5. CancellationToken enables graceful shutdown
