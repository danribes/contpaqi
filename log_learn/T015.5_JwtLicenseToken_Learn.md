# T015.5 - JWT Signing and Validation Learning Notes

**Subtask**: 15.5 - Implement JWT signing and validation
**Date**: 2025-12-09

---

## Key Learnings

### 1. JWT Structure

JSON Web Tokens consist of three parts separated by dots:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
   └─────────── Header ───────────┘.└───────────────────── Payload ─────────────────────┘.└─────────── Signature ───────────┘
```

Each part is Base64URL encoded.

### 2. Base64URL vs Base64

Standard Base64 uses characters that are URL-unsafe:
- `+` → replaced with `-`
- `/` → replaced with `_`
- `=` padding → removed

```typescript
function base64UrlEncode(str: string): string {
  const base64 = Buffer.from(str).toString('base64');
  return base64
    .replace(/\+/g, '-')
    .replace(/\//g, '_')
    .replace(/=+$/, '');
}
```

### 3. HMAC Signature Security

**Constant-Time Comparison** prevents timing attacks:

```typescript
function verifyHmacSignature(data, signature, secret, algorithm) {
  const expected = createHmacSignature(data, secret, algorithm);

  // BAD: Early exit reveals information
  // if (expected !== signature) return false;

  // GOOD: Compare all characters regardless of match
  if (expected.length !== signature.length) return false;
  let result = 0;
  for (let i = 0; i < expected.length; i++) {
    result |= expected.charCodeAt(i) ^ signature.charCodeAt(i);
  }
  return result === 0;
}
```

### 4. Standard JWT Claims

| Claim | Name | Description |
|-------|------|-------------|
| iss | Issuer | Who created the token |
| sub | Subject | What the token is about |
| aud | Audience | Who should accept it |
| exp | Expiration | When it expires (Unix timestamp) |
| iat | Issued At | When it was created |
| nbf | Not Before | Token not valid before this time |
| jti | JWT ID | Unique identifier for this token |

### 5. Custom Claims for Licensing

Extended the standard claims with license-specific data:

```typescript
interface LicenseTokenPayload {
  // Standard claims
  iss, sub, aud, exp, iat, nbf, jti: ...

  // Custom claims
  licenseId: string;
  licenseType: LicenseType;
  fingerprint: string;      // Hardware binding
  features: string[];       // Enabled features
  maxActivations: number;
  currentActivations: number;
}
```

---

## Algorithm Comparison

| Algorithm | Hash | Signature Size | Performance | Security |
|-----------|------|----------------|-------------|----------|
| HS256 | SHA-256 | 256 bits | Fast | Standard |
| HS384 | SHA-384 | 384 bits | Medium | Higher |
| HS512 | SHA-512 | 512 bits | Slower | Highest |

For license tokens, HS256 provides adequate security with best performance.

---

## Token Validation Order

Validation checks should be ordered from cheapest to most expensive:

1. **Format** - String split, O(1)
2. **Structure** - JSON parse, O(n)
3. **Signature** - HMAC compute, O(n)
4. **Claims** - Comparison, O(1)
5. **External checks** - Database lookup, O(?)

```typescript
function validateToken(token, fingerprint, config) {
  // 1. Format (cheapest)
  if (!isTokenFormatValid(token)) return error('INVALID_FORMAT');

  // 2. Parse
  const parsed = parseToken(token);
  if (!parsed) return error('DECODE_ERROR');

  // 3. Signature (expensive but necessary)
  if (!isSignatureValid(token, config.secret, config.algorithm))
    return error('INVALID_SIGNATURE');

  // 4. Claims (cheap)
  if (!isIssuerValid(parsed.payload, config.issuer))
    return error('INVALID_ISSUER');
  // ... more claim checks
}
```

---

## Token Refresh Strategy

### When to Refresh

```typescript
function shouldRefreshToken(payload, thresholdMinutes = 5) {
  const now = Math.floor(Date.now() / 1000);
  const remainingSeconds = payload.exp - now;
  return remainingSeconds <= thresholdMinutes * 60;
}
```

### Refresh Flow

```
┌─────────────────────────────────────────────────────┐
│                  Token Lifetime                      │
├─────────────────────────────────────────────────────┤
│  Valid    │  Valid    │  Valid    │  Refresh Zone  │
│           │           │           │  (5 min)       │
└───────────┴───────────┴───────────┴────────────────┘
                                     ↓
                              Request new token
                                     ↓
                              Replace current
```

---

## Unique Token IDs (JTI)

Purpose:
- Prevent token replay attacks
- Enable token revocation by ID
- Audit logging

```typescript
function generateJti(): string {
  return crypto.randomBytes(16).toString('hex');
  // Returns 32-character hex string
  // e.g., "a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6"
}
```

---

## TypeScript Patterns

### Generic Decoding

```typescript
function base64UrlDecodeJson<T>(str: string): T | null {
  try {
    return JSON.parse(base64UrlDecode(str)) as T;
  } catch {
    return null;
  }
}

// Usage
const header = base64UrlDecodeJson<JwtHeader>(parts[0]);
const payload = base64UrlDecodeJson<LicenseTokenPayload>(parts[1]);
```

### Error Result Pattern

```typescript
interface TokenValidationResult {
  valid: boolean;
  payload: LicenseTokenPayload | null;
  error?: string;
  errorCode?: TokenErrorCode;
}

// Always return same structure
return {
  valid: false,
  payload: null,
  error: 'Invalid signature',
  errorCode: 'INVALID_SIGNATURE',
};
```

---

## Security Best Practices

### 1. Secret Key Management

```typescript
// BAD: Hardcoded secret
const config = { secret: 'my-secret-key' };

// GOOD: From environment
const config = { secret: process.env.JWT_SECRET || '' };

// GOOD: Validation
if (!config.secret || config.secret.length < 32) {
  throw new Error('JWT secret must be at least 32 characters');
}
```

### 2. Token Storage

```typescript
// Client-side: Store in memory, not localStorage
class TokenManager {
  private token: string | null = null;  // Memory only

  // For persistence, encrypt first
  encryptForStorage(token: string): string;
  decryptFromStorage(encrypted: string): string;
}
```

### 3. Fingerprint Binding

Token includes hardware fingerprint:
- Prevents token theft (stolen token won't work on different machine)
- Validates machine identity on each use

---

## Integration with Licensing System

```
┌──────────────────────────────────────────────────────────────┐
│                       License Flow                            │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  1. Activation                                                │
│     Client ──── license key + fingerprint ────► Server        │
│     Client ◄──────── JWT token ───────────── Server          │
│                                                               │
│  2. Validation                                                │
│     Client: Validate JWT locally (signature, exp, fingerprint)│
│     Client: If valid, proceed                                 │
│     Client: If expired, request new token                     │
│                                                               │
│  3. Offline Mode                                              │
│     Client: Use cached token if within grace period           │
│     Client: Validate fingerprint                              │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

---

## Common Pitfalls Avoided

### 1. Not Validating All Claims

```typescript
// BAD: Only check expiration
if (!isTokenExpired(payload)) return { valid: true };

// GOOD: Check everything
if (!isSignatureValid(...)) return error;
if (!isIssuerValid(...)) return error;
if (!isAudienceValid(...)) return error;
if (isTokenNotYetValid(...)) return error;
if (isTokenExpired(...)) return error;
if (!isFingerprintValid(...)) return error;
```

### 2. Algorithm Confusion

```typescript
// Header specifies algorithm, but we must enforce it
const parsed = parseToken(token);
// DON'T trust parsed.header.alg
// DO use config.algorithm for verification
```

### 3. Integer Overflow in Timestamps

```typescript
// JWT uses seconds, JavaScript uses milliseconds
const now = Math.floor(Date.now() / 1000);  // Convert to seconds
const exp = now + config.tokenLifetimeMinutes * 60;  // Add minutes in seconds
```

---

## Testing Strategies

### Time-Based Testing

```typescript
// Create tokens with specific expiration times
function createExpiredPayload() {
  const now = Math.floor(Date.now() / 1000);
  return {
    exp: now - 3600,  // 1 hour ago
    iat: now - 7200,  // 2 hours ago
  };
}

function createFuturePayload() {
  const now = Math.floor(Date.now() / 1000);
  return {
    nbf: now + 3600,  // 1 hour from now
    exp: now + 7200,  // 2 hours from now
  };
}
```

### Signature Tampering

```typescript
it('should reject tampered payload', () => {
  const token = createToken(payload, config);
  const parts = token.split('.');

  // Modify payload
  const tampered = base64UrlEncodeJson({ ...payload, features: ['unlimited'] });
  parts[1] = tampered;

  // Signature no longer valid
  expect(isSignatureValid(parts.join('.'), secret, 'HS256')).toBe(false);
});
```

---

## References

- [RFC 7519 - JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519)
- [RFC 7518 - JSON Web Algorithms (JWA)](https://tools.ietf.org/html/rfc7518)
- [JWT.io - JWT Debugger](https://jwt.io/)
- [OWASP JWT Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
