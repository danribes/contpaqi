# T004.6 - Docker Container Build and Run Guide

**Subtask**: 4.6 Test container builds and runs successfully
**Date**: 2025-12-05

---

## Learning Objectives

After completing this guide, you will understand:
1. How to build Docker containers from a Dockerfile
2. Docker image inspection and size optimization
3. Running containers and managing their lifecycle
4. Using docker-compose for development
5. Testing container builds in CI/CD environments
6. Health check verification

---

## 1. Building Docker Containers

### Basic Build Command

```bash
# Navigate to directory with Dockerfile
cd mcp-container

# Build with default name
docker build .

# Build with name and tag
docker build -t mcp-container:latest .

# Build with specific Dockerfile
docker build -f Dockerfile.prod -t mcp-container:prod .
```

### Build Options

| Option | Description | Example |
|--------|-------------|---------|
| `-t` | Tag the image | `-t myimage:v1.0` |
| `-f` | Specify Dockerfile | `-f Dockerfile.dev` |
| `--no-cache` | Don't use cache | `--no-cache` |
| `--build-arg` | Set build arguments | `--build-arg VERSION=1.0` |
| `--target` | Build specific stage | `--target builder` |

### Build Context

```bash
# Current directory as context
docker build -t myimage .

# Different context directory
docker build -t myimage ./path/to/context

# Git repository as context
docker build -t myimage https://github.com/user/repo.git
```

---

## 2. Multi-Stage Build Benefits

### Why Multi-Stage?

```dockerfile
# Stage 1: Builder (larger, has build tools)
FROM python:3.9 as builder
RUN pip wheel --wheel-dir /wheels -r requirements.txt

# Stage 2: Runtime (smaller, no build tools)
FROM python:3.9-slim
COPY --from=builder /wheels /wheels
RUN pip install /wheels/*
```

**Benefits**:
- Smaller final image
- No build tools in production
- Faster deployment
- Better security

### Image Size Comparison

| Stage | Contents | Size |
|-------|----------|------|
| Builder | Python + gcc + build deps | ~1GB |
| Runtime | Python + pip packages only | ~400MB |

---

## 3. Image Inspection

### Checking Image Size

```bash
# List all images
docker images

# Filter by name
docker images mcp-container

# Get specific format
docker images --format "{{.Repository}}:{{.Tag}} {{.Size}}" mcp-container
```

### Inspecting Image Layers

```bash
# Show image history
docker history mcp-container:latest

# Detailed inspection
docker inspect mcp-container:latest

# Get specific fields
docker inspect --format='{{.Config.Cmd}}' mcp-container:latest
```

### Image Size Optimization Tips

1. **Use slim base images**: `python:3.9-slim` vs `python:3.9`
2. **Combine RUN commands**: Reduce layer count
3. **Clean up in same layer**: `apt-get clean` in same RUN
4. **Use .dockerignore**: Exclude unnecessary files
5. **Multi-stage builds**: Only copy what's needed

---

## 4. Running Containers

### Basic Run Commands

```bash
# Run in foreground
docker run mcp-container:latest

# Run in background (detached)
docker run -d mcp-container:latest

# Run with name
docker run -d --name mycontainer mcp-container:latest

# Run with port mapping
docker run -d -p 8000:8000 mcp-container:latest

# Run with environment variables
docker run -d -e LOG_LEVEL=DEBUG mcp-container:latest
```

### Container Lifecycle

```bash
# Start existing container
docker start mycontainer

# Stop container
docker stop mycontainer

# Restart container
docker restart mycontainer

# Remove container
docker rm mycontainer

# Force remove running container
docker rm -f mycontainer
```

### Viewing Logs

```bash
# View logs
docker logs mycontainer

# Follow logs (like tail -f)
docker logs -f mycontainer

# Last N lines
docker logs --tail 100 mycontainer

# With timestamps
docker logs -t mycontainer
```

---

## 5. Container Health Checks

### HEALTHCHECK in Dockerfile

```dockerfile
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1
```

### Health Check Parameters

| Parameter | Description | Default |
|-----------|-------------|---------|
| `--interval` | Time between checks | 30s |
| `--timeout` | Max time for check | 30s |
| `--start-period` | Grace period at start | 0s |
| `--retries` | Failures before unhealthy | 3 |

### Checking Health Status

```bash
# Check container health
docker ps
# HEALTH column shows: starting, healthy, unhealthy

# Detailed health info
docker inspect --format='{{.State.Health.Status}}' mycontainer

# Health check logs
docker inspect --format='{{json .State.Health}}' mycontainer | jq
```

### Testing Health Endpoint

```bash
# From host (if port mapped)
curl http://localhost:8000/health

# From inside container
docker exec mycontainer curl http://localhost:8000/health
```

---

## 6. Docker Compose

### Basic Commands

```bash
# Start services
docker-compose up -d

# Stop services
docker-compose down

# View logs
docker-compose logs -f

# Rebuild and start
docker-compose up -d --build

# Check status
docker-compose ps
```

### docker-compose.yml Example

```yaml
version: '3.8'

services:
  mcp-container:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    volumes:
      - ./src:/app/src:ro
    environment:
      - LOG_LEVEL=DEBUG
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

### Compose vs Run Comparison

| Feature | docker run | docker-compose |
|---------|------------|----------------|
| Single command | Complex | Simple |
| Multiple services | Manual | Easy |
| Reproducible | Script needed | YAML file |
| Volume management | Manual | Automatic |
| Network creation | Manual | Automatic |

---

## 7. CI/CD Testing

### Testing Without Docker

When Docker isn't available (common in some CI environments), test:
1. **File existence** - All required files present
2. **Dockerfile syntax** - Valid instructions
3. **docker-compose syntax** - Valid YAML
4. **Dependencies listed** - requirements.txt complete

### Pytest Skip Markers

```python
import pytest
import subprocess

def is_docker_available():
    try:
        result = subprocess.run(
            ["docker", "--version"],
            capture_output=True
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False

requires_docker = pytest.mark.skipif(
    not is_docker_available(),
    reason="Docker not available"
)

@requires_docker
def test_container_builds():
    # This test only runs if Docker is available
    pass
```

### Build Verification Tests

```python
def test_dockerfile_exists():
    assert Path("Dockerfile").exists()

def test_dockerfile_has_from():
    content = Path("Dockerfile").read_text()
    assert "FROM" in content

def test_requirements_complete():
    content = Path("requirements.txt").read_text()
    assert "fastapi" in content.lower()
```

---

## 8. Troubleshooting

### Build Failures

```bash
# Build with verbose output
docker build --progress=plain -t myimage .

# Build specific stage
docker build --target builder -t myimage:builder .

# Check intermediate images
docker images -a
```

### Container Won't Start

```bash
# Check logs
docker logs mycontainer

# Check exit code
docker inspect --format='{{.State.ExitCode}}' mycontainer

# Run interactively to debug
docker run -it mcp-container:latest /bin/bash
```

### Health Check Failing

```bash
# Check health status
docker inspect --format='{{json .State.Health}}' mycontainer

# Test endpoint manually
docker exec mycontainer curl -v http://localhost:8000/health

# Check if service is running
docker exec mycontainer ps aux
```

### Image Too Large

```bash
# Analyze layers
docker history mcp-container:latest

# Use dive tool
dive mcp-container:latest

# Check for large files
docker run --rm mcp-container:latest du -sh /app/*
```

---

## 9. Best Practices

### Dockerfile Best Practices

1. **Order matters**: Put changing content last
2. **Combine commands**: Reduce layers
3. **Use .dockerignore**: Exclude unnecessary files
4. **Pin versions**: Use specific image tags
5. **Non-root user**: Security best practice
6. **Health checks**: Container monitoring

### docker-compose Best Practices

1. **Use version 3.8**: Latest features
2. **Set resource limits**: Prevent runaway usage
3. **Use read-only volumes**: Security
4. **Environment variables**: Configuration
5. **Restart policies**: Reliability
6. **Health checks**: Monitoring

### Testing Best Practices

1. **Test prerequisites**: Files, structure
2. **Skip when unavailable**: Don't fail CI
3. **Verify configuration**: Syntax validation
4. **Check dependencies**: Requirements complete
5. **Document manual steps**: For local testing

---

## 10. Quick Reference

### Essential Commands

```bash
# Build
docker build -t image:tag .

# Run
docker run -d -p 8000:8000 --name container image:tag

# Stop and remove
docker stop container && docker rm container

# Logs
docker logs -f container

# Shell access
docker exec -it container /bin/bash

# Health check
docker inspect --format='{{.State.Health.Status}}' container
```

### docker-compose Commands

```bash
docker-compose up -d          # Start
docker-compose down           # Stop
docker-compose logs -f        # Logs
docker-compose up -d --build  # Rebuild
docker-compose ps             # Status
docker-compose exec app bash  # Shell
```

---

## Summary

### Key Takeaways

1. **Build with tags**: Always name and tag images
2. **Multi-stage builds**: Smaller, more secure images
3. **Health checks**: Container monitoring essential
4. **docker-compose**: Simplifies development workflow
5. **CI/CD testing**: Test what you can, skip what you can't
6. **Image optimization**: Smaller is better

### Task 4 Complete Checklist

- [x] Dockerfile exists with proper structure
- [x] docker-compose.yml configured
- [x] requirements.txt complete
- [x] Source code structure correct
- [x] Build prerequisites verified
- [ ] Image builds successfully (requires Docker)
- [ ] Image size < 3GB (requires Docker)
- [ ] Container starts and runs (requires Docker)
- [ ] Health endpoint responds (requires Docker)

---

## Further Reading

1. [Docker Build Documentation](https://docs.docker.com/engine/reference/commandline/build/)
2. [Dockerfile Best Practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
3. [Docker Compose Documentation](https://docs.docker.com/compose/)
4. [Container Health Checks](https://docs.docker.com/engine/reference/builder/#healthcheck)
