# COM Interop with P/Invoke - Learning Guide

## Overview
How to call native Windows DLLs from C# using P/Invoke.

## Key Concepts

### 1. DllImport Attribute
```csharp
[DllImport("MGW_SDK.dll", CallingConvention = CallingConvention.Cdecl)]
private static extern int MGW_InicializaSDK(
    [MarshalAs(UnmanagedType.LPStr)] string dataPath);
```

### 2. Calling Conventions
| Convention | Description | Use Case |
|------------|-------------|----------|
| Cdecl | C-style, caller cleans stack | Most C libraries |
| StdCall | Windows API style | Win32 API |
| ThisCall | C++ member functions | COM objects |

### 3. String Marshaling
| Type | .NET | Native | Encoding |
|------|------|--------|----------|
| LPStr | string | char* | ANSI |
| LPWStr | string | wchar_t* | Unicode |
| BStr | string | BSTR | COM string |

```csharp
// ANSI string (for legacy)
[MarshalAs(UnmanagedType.LPStr)] string text

// Unicode string (preferred)
[MarshalAs(UnmanagedType.LPWStr)] string text
```

### 4. Result Pattern
Avoid exceptions for expected errors:
```csharp
public class SdkResult<T>
{
    public bool Success { get; set; }
    public T? Value { get; set; }
    public int ErrorCode { get; set; }
    public string? ErrorMessage { get; set; }
}
```

### 5. Interface Abstraction
Enable testing without native DLL:
```csharp
public interface ISdkInterop
{
    SdkResult<bool> Initialize(string path);
    void Terminate();
}

public class SdkInterop : ISdkInterop { /* P/Invoke calls */ }
public class MockSdkInterop : ISdkInterop { /* Testing */ }
```

### 6. Resource Management
```csharp
public class SdkInterop : ISdkInterop, IDisposable
{
    private bool _disposed;

    public void Dispose()
    {
        if (!_disposed)
        {
            Terminate();
            _disposed = true;
        }
    }
}
```

## Common Pitfalls

1. **Wrong calling convention** - Causes stack corruption
2. **Wrong string marshaling** - Garbage characters
3. **32/64-bit mismatch** - DLL not found
4. **Missing DLL** - DllNotFoundException
5. **Memory leaks** - Not freeing native memory

## Best Practices

1. **Wrap in interface** - For testability
2. **Use result pattern** - For error handling
3. **Implement IDisposable** - For cleanup
4. **Match platform target** - x86 for 32-bit DLLs
5. **Log all errors** - For debugging

## Key Takeaways

1. P/Invoke bridges managed and native code
2. Marshaling converts types between worlds
3. Calling convention must match native code
4. Interface abstraction enables testing
5. Result pattern handles errors gracefully
