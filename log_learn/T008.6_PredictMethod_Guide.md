# T008.6 Predict Method - Learning Guide

## Overview
This guide explains the main `predict()` method that orchestrates the complete invoice extraction pipeline.

## The Facade Pattern

The `predict()` method implements a Facade pattern, hiding the complexity of multiple ML models behind a single interface:

```
┌─────────────────────────────────────────────────────────────────┐
│                        predict(image)                           │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Single Entry Point                    │   │
│  │                                                          │   │
│  │     ┌──────────┐    ┌──────────┐    ┌──────────┐        │   │
│  │     │   OCR    │ -> │   TATR   │ -> │ LayoutLM │        │   │
│  │     └──────────┘    └──────────┘    └──────────┘        │   │
│  │           │              │              │               │   │
│  │           v              v              v               │   │
│  │     words,boxes     table,rows      fields             │   │
│  │           │              │              │               │   │
│  │           └──────────────┴──────────────┘               │   │
│  │                          │                              │   │
│  │                          v                              │   │
│  │                   InvoiceResult                         │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

## Pipeline Steps Explained

### Step 1: OCR
```python
words, boxes, ocr_conf = self._run_ocr(image)
```
Extracts all text from the image with their bounding boxes and confidence scores.

### Step 2: Table Detection
```python
table_structure = self._detect_table_structure(image)
```
Identifies the table region and individual row boundaries.

### Step 3: Field Extraction
```python
fields = self._extract_fields(image, words, boxes)
```
Classifies each word into invoice fields (RFC, date, totals, etc.).

### Step 4: Row Assignment
```python
rows = self._assign_words_to_rows(words, boxes, table_structure['rows'])
```
Maps words to their corresponding table rows for line item extraction.

### Step 5: Build Result
```python
result = InvoiceResult(
    rfc_emisor=self._get_field_value(fields, 'RFC_EMISOR', ''),
    ...
)
```
Populates the structured result from all extracted data.

## Helper Methods

### _get_field_value()

Safely extracts string values with defaults:

```python
def _get_field_value(self, fields, field_name, default=''):
    if field_name not in fields:
        return default
    field = fields[field_name]
    if field.value is None:
        return default
    return field.value
```

**Why?** Fields may be missing or have None values. This provides safe access.

### _parse_amount()

Converts currency strings to float:

```python
def _parse_amount(self, fields, field_name):
    # "$1,234.56" -> 1234.56
    cleaned = field.value.replace('$', '').replace(',', '').strip()
    return float(cleaned)
```

**Why?** Currency values come as strings with formatting. We need clean floats.

### _parse_line_item()

Builds line item dictionaries:

```python
def _parse_line_item(self, row_words):
    words = [w['word'] for w in row_words]
    return {
        'description': ' '.join(words),
        'raw_words': row_words
    }
```

**Why?** Preserves both human-readable description and raw data for debugging.

## Defensive Programming

The method uses several defensive techniques:

1. **Default Values**: Missing fields return '' or 0.0
2. **Exception Handling**: Invalid amounts return 0.0
3. **Empty Lists**: No rows means empty line_items
4. **Warnings List**: Ready for validation errors

```python
# Example: graceful handling of missing field
rfc = self._get_field_value(fields, 'RFC_EMISOR', '')  # '' if missing

# Example: graceful handling of invalid amount
try:
    return float(cleaned)
except (ValueError, AttributeError):
    return 0.0  # Invalid format returns 0
```

## Confidence Score

Currently uses simple OCR confidence average:

```python
confidence = 0.0
if ocr_conf:
    confidence = sum(ocr_conf) / len(ocr_conf)
```

Subtask 8.7 will implement more sophisticated scoring.

## Usage Example

```python
from PIL import Image
from inference import InvoiceInferenceEngine

# Initialize engine (loads models)
engine = InvoiceInferenceEngine()

# Process invoice
image = Image.open("invoice.png")
result = engine.predict(image)

# Access results
print(f"RFC Emisor: {result.rfc_emisor}")
print(f"Date: {result.date}")
print(f"Total: ${result.total:.2f}")
print(f"Confidence: {result.confidence:.0%}")

for item in result.line_items:
    print(f"  - {item['description']}")
```

## Key Takeaways

1. **Facade Pattern**: Single method hides multi-model complexity
2. **Pipeline Architecture**: Sequential steps with clear responsibilities
3. **Defensive Defaults**: Graceful handling of missing/invalid data
4. **Structured Output**: InvoiceResult dataclass for type safety
5. **Testable Design**: Each step can be mocked independently
