# Learning Guide: Subtask 17.8 - First-Run Wizard

## Overview

This guide explains how to create a first-run wizard in PowerShell that provides initial setup and configuration experience after application installation.

## First-Run Detection Pattern

### Using a Marker File

```powershell
$MarkerFile = Join-Path $InstallPath ".firstrun"

function Test-FirstRun {
    if (-not (Test-Path $MarkerFile)) {
        return $true  # First run
    }
    return $false  # Already initialized
}

function Set-FirstRunComplete {
    $content = @{
        initialized = $true
        timestamp = (Get-Date).ToString("o")
        version = "1.0.0"
    }
    $content | ConvertTo-Json | Set-Content -Path $MarkerFile -Encoding UTF8
}
```

### Benefits of Marker Files
- Simple to implement and check
- Survives reboots
- Can store metadata (timestamp, version)
- Easy to reset by deleting file

## System Requirements Checking

### Docker Check
```powershell
function Test-DockerAvailable {
    try {
        # Check if Docker is in PATH
        $dockerPath = Get-Command docker -ErrorAction SilentlyContinue
        if (-not $dockerPath) {
            return $false
        }

        # Check if Docker daemon is running
        $dockerInfo = & docker info 2>&1
        if ($LASTEXITCODE -ne 0) {
            return $false
        }

        return $true
    }
    catch {
        return $false
    }
}
```

### .NET Runtime Check
```powershell
function Test-DotNetAvailable {
    try {
        $dotnetPath = Get-Command dotnet -ErrorAction SilentlyContinue
        if (-not $dotnetPath) {
            return $false
        }

        $version = & dotnet --version 2>&1
        return ($LASTEXITCODE -eq 0)
    }
    catch {
        return $false
    }
}
```

### Windows Service Check
```powershell
function Test-ServiceRunning {
    param([string]$ServiceName)

    $service = Get-Service -Name $ServiceName -ErrorAction SilentlyContinue
    if (-not $service) {
        return $false
    }

    return ($service.Status -eq 'Running')
}
```

### Configuration Validation
```powershell
function Test-Configuration {
    param([string]$ConfigPath)

    # Check directory exists
    if (-not (Test-Path $ConfigPath)) {
        return $false
    }

    # Check settings file
    $settingsFile = Join-Path $ConfigPath "appsettings.json"
    if (-not (Test-Path $settingsFile)) {
        return $false
    }

    # Validate JSON
    try {
        $settings = Get-Content $settingsFile -Raw | ConvertFrom-Json
        return ($null -ne $settings)
    }
    catch {
        return $false
    }
}
```

## User Interaction Patterns

### Interactive Prompts
```powershell
function Request-UserInput {
    param(
        [string]$Prompt,
        [string]$Default = ""
    )

    $input = Read-Host -Prompt "$Prompt [$Default]"
    if ([string]::IsNullOrWhiteSpace($input)) {
        return $Default
    }
    return $input
}
```

### Confirmation Prompts
```powershell
function Request-Confirmation {
    param(
        [string]$Prompt,
        [bool]$Default = $true
    )

    $defaultText = if ($Default) { "Y/n" } else { "y/N" }
    $response = Read-Host -Prompt "$Prompt [$defaultText]"

    if ([string]::IsNullOrWhiteSpace($response)) {
        return $Default
    }

    return $response -match "^[Yy]"
}
```

### Non-Interactive Mode
```powershell
param(
    [switch]$NonInteractive
)

function Request-Confirmation {
    param([string]$Prompt, [bool]$Default = $true)

    if ($NonInteractive) {
        return $Default  # Use default in non-interactive mode
    }

    # Interactive prompt here...
}
```

## Status Summary Pattern

### Track Results in Hashtable
```powershell
$script:CheckResults = @{
    Docker = $false
    DotNet = $false
    Service = $false
    Config = $false
}

function Invoke-SystemChecks {
    $script:CheckResults.Docker = Test-DockerAvailable
    $script:CheckResults.DotNet = Test-DotNetAvailable
    $script:CheckResults.Service = Test-ServiceRunning
    $script:CheckResults.Config = Test-Configuration
}
```

### Display Status Summary
```powershell
function Write-StatusSummary {
    $allPassed = $true

    foreach ($check in $script:CheckResults.GetEnumerator()) {
        if ($check.Value) {
            Write-Host "[OK]    $($check.Key)........... PASS" -ForegroundColor Green
        } else {
            Write-Host "[FAIL]  $($check.Key)........... FAIL" -ForegroundColor Red
            $allPassed = $false
        }
    }

    return $allPassed
}
```

## Opening Browser

### Launch Default Browser
```powershell
function Open-ApplicationBrowser {
    param([string]$Url = "http://localhost:5000")

    try {
        Start-Process $Url
        return $true
    }
    catch {
        Write-Host "Failed to open browser: $($_.Exception.Message)"
        Write-Host "Please navigate to: $Url"
        return $false
    }
}
```

## Welcome Banner Pattern

### ASCII Art Banner
```powershell
function Write-WelcomeBanner {
    $banner = @"

╔═══════════════════════════════════════════════════════════════╗
║                                                               ║
║          Welcome to My Application - First Run Setup          ║
║                                                               ║
╚═══════════════════════════════════════════════════════════════╝

"@
    Write-Host $banner -ForegroundColor Cyan
}
```

## Structured Exit Codes

```powershell
$EXIT_SUCCESS = 0
$EXIT_CHECKS_FAILED = 1
$EXIT_SERVICE_FAILED = 2
$EXIT_CONFIG_FAILED = 3
$EXIT_ALREADY_INITIALIZED = 4

function Start-Wizard {
    if (-not (Test-FirstRun) -and -not $Force) {
        return $EXIT_ALREADY_INITIALIZED
    }

    $checksOk = Invoke-SystemChecks
    if (-not $checksOk) {
        return $EXIT_CHECKS_FAILED
    }

    # ... more logic ...

    Set-FirstRunComplete
    return $EXIT_SUCCESS
}

exit (Start-Wizard)
```

## Integration with Inno Setup

### Post-Install Run
```pascal
[Run]
; Run first-run wizard after installation
Filename: "powershell.exe"; \
    Parameters: "-ExecutionPolicy Bypass -File ""{app}\scripts\first-run-wizard.ps1"""; \
    Flags: postinstall skipifsilent; \
    Description: "Run First-Time Setup"
```

### Silent Installation Support
```pascal
[Run]
; Non-interactive mode for silent installs
Filename: "powershell.exe"; \
    Parameters: "-ExecutionPolicy Bypass -File ""{app}\scripts\first-run-wizard.ps1"" -NonInteractive"; \
    Flags: runhidden waituntilterminated; \
    Check: not WizardSilent
```

## Best Practices

1. **Always Support Non-Interactive Mode**: For automated deployments
2. **Use Exit Codes**: Return meaningful codes for scripting
3. **Graceful Degradation**: Continue if non-critical checks fail
4. **Clear Feedback**: Show progress and results clearly
5. **Idempotency**: Use marker files to prevent re-running
6. **Force Option**: Allow re-running with -Force flag
7. **Logging**: Log all checks and results

## Common Issues

### Permission Errors
- Some checks require admin privileges
- Wrap in try-catch with SilentlyContinue

### Service Not Found
- Service may not be installed yet
- Check exists before checking status

### Browser Not Opening
- May fail in remote/headless environments
- Provide URL as fallback

## Summary

A first-run wizard provides:
1. First-run detection via marker file
2. System requirements verification
3. Service status checking
4. Configuration validation
5. Interactive user prompts
6. Status summary display
7. Next steps guidance
8. Browser launch capability

The implementation in `first-run-wizard.ps1` provides a complete solution with both interactive and non-interactive modes.
