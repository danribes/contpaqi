# T002.6 - Bounding Boxes - Learning Guide

**Subtask**: 2.6 - Implement bounding box calculation for all fields
**Date**: 2025-12-03
**Audience**: Developers working with OCR and document field extraction

---

## What Was Built

A Python module (`bbox_utils.py`) for finding and calculating bounding boxes of text fields in invoice images using OCR data.

---

## Understanding Bounding Boxes

### What is a Bounding Box?

A bounding box (bbox) is a rectangle that encloses a region of interest:

```
   x
   |
   +--------+  width
   |  TEXT  |
   +--------+  height
        y
```

### BBox Structure

```python
bbox = {
    'x': 100,      # Distance from left edge
    'y': 200,      # Distance from top edge
    'width': 150,  # Width of the box
    'height': 30   # Height of the box
}
```

---

## Using pytesseract for OCR

### Basic OCR

```python
import pytesseract
from PIL import Image

# Load image
image = Image.open('invoice.png')

# Get text only
text = pytesseract.image_to_string(image, lang='spa')

# Get detailed data with positions
data = pytesseract.image_to_data(
    image,
    lang='spa',
    output_type=pytesseract.Output.DICT
)
```

### OCR Data Structure

pytesseract returns a dictionary with parallel arrays:

```python
data = {
    'text': ['FACTURA', 'Total:', '$17,400.00'],  # Detected text
    'left': [100, 50, 150],                        # X coordinates
    'top': [50, 200, 200],                         # Y coordinates
    'width': [120, 60, 100],                       # Widths
    'height': [30, 25, 25],                        # Heights
    'conf': [95, 90, 88],                          # Confidence (0-100)
    'level': [5, 5, 5],                            # OCR hierarchy level
    'block_num': [1, 2, 2],                        # Block number
    'line_num': [1, 1, 1],                         # Line number
    'word_num': [1, 1, 2],                         # Word number
}
```

---

## Finding Text Bounding Boxes

### Simple Text Search

```python
def find_text_bbox(ocr_data, search_text):
    for i, text in enumerate(ocr_data['text']):
        if search_text in text:
            return {
                'x': ocr_data['left'][i],
                'y': ocr_data['top'][i],
                'width': ocr_data['width'][i],
                'height': ocr_data['height'][i]
            }
    return None

# Usage
bbox = find_text_bbox(data, 'FACTURA')
```

### Case-Insensitive Search

```python
def find_text_bbox(ocr_data, search_text, case_sensitive=True):
    if not case_sensitive:
        search_text = search_text.lower()

    for i, text in enumerate(ocr_data['text']):
        compare = text if case_sensitive else text.lower()
        if search_text in compare:
            return create_bbox(
                ocr_data['left'][i],
                ocr_data['top'][i],
                ocr_data['width'][i],
                ocr_data['height'][i]
            )
    return None
```

---

## Finding Numeric Values

Numbers can appear in many formats:

```python
def find_numeric_bbox(ocr_data, value):
    # Generate format variations
    patterns = [
        f"{value:.2f}",           # 1234.56
        f"{value:,.2f}",          # 1,234.56
        f"${value:,.2f}",         # $1,234.56
    ]

    for i, text in enumerate(ocr_data['text']):
        for pattern in patterns:
            if pattern in text:
                return create_bbox(...)

    # Also try parsing OCR text as number
    for i, text in enumerate(ocr_data['text']):
        try:
            clean = text.replace('$', '').replace(',', '')
            if abs(float(clean) - value) < 0.01:
                return create_bbox(...)
        except ValueError:
            continue

    return None
```

---

## Filtering OCR Results

### By Confidence

```python
def filter_ocr_by_confidence(ocr_data, min_confidence=60):
    filtered = {key: [] for key in ocr_data.keys()}

    for i in range(len(ocr_data['text'])):
        # Skip low confidence
        if ocr_data['conf'][i] < min_confidence:
            continue

        # Skip empty text
        if not ocr_data['text'][i].strip():
            continue

        # Add to filtered
        for key in ocr_data:
            filtered[key].append(ocr_data[key][i])

    return filtered
```

---

## Normalizing Bounding Boxes

For machine learning, normalize coordinates to 0-1 range:

```python
def normalize_bbox(bbox, image_width, image_height):
    return {
        'x': bbox['x'] / image_width,
        'y': bbox['y'] / image_height,
        'width': bbox['width'] / image_width,
        'height': bbox['height'] / image_height
    }

# Example
bbox = {'x': 100, 'y': 200, 'width': 150, 'height': 30}
normalized = normalize_bbox(bbox, 1000, 1400)
# {'x': 0.1, 'y': 0.143, 'width': 0.15, 'height': 0.021}
```

---

## Merging Bounding Boxes

Combine multiple boxes into one:

```python
def merge_bboxes(bboxes):
    if not bboxes:
        return None

    # Find the overall bounds
    min_x = min(b['x'] for b in bboxes)
    min_y = min(b['y'] for b in bboxes)
    max_x = max(b['x'] + b['width'] for b in bboxes)
    max_y = max(b['y'] + b['height'] for b in bboxes)

    return {
        'x': min_x,
        'y': min_y,
        'width': max_x - min_x,
        'height': max_y - min_y
    }
```

Visual example:

```
Before:            After merge:
+---+    +---+     +------------+
| A |    | B |  â†’  |     A  B   |
+---+    +---+     +------------+
```

---

## Finding Labeled Fields

Many invoice fields have labels like "RFC:" or "Total:":

```python
def find_labeled_field_bbox(ocr_data, label, value):
    # Find the label
    label_bbox = find_text_bbox(ocr_data, label)

    # Find the value directly
    value_bbox = find_text_bbox(ocr_data, value)
    if value_bbox:
        return value_bbox

    # Look for value near label
    if label_bbox:
        label_y = label_bbox['y']
        label_right = label_bbox['x'] + label_bbox['width']

        for i, text in enumerate(ocr_data['text']):
            text_y = ocr_data['top'][i]
            text_x = ocr_data['left'][i]

            # Same line, to the right
            if abs(text_y - label_y) < 10 and text_x > label_right:
                if value in text:
                    return create_bbox(...)

    return None
```

---

## Finding All Invoice Fields

```python
def find_all_field_bboxes(image, invoice_data):
    # Perform OCR
    ocr_data = pytesseract.image_to_data(
        image,
        lang='spa',
        output_type=Output.DICT
    )

    # Filter noise
    ocr_data = filter_ocr_by_confidence(ocr_data)

    # Find each field
    return {
        'rfc_emisor': find_text_bbox(
            ocr_data,
            invoice_data['emisor']['rfc']
        ),
        'rfc_receptor': find_text_bbox(
            ocr_data,
            invoice_data['receptor']['rfc']
        ),
        'total': find_numeric_bbox(
            ocr_data,
            invoice_data['total']
        ),
        # ... more fields
    }
```

---

## Handling Date Formats

Dates appear in many formats:

```python
def find_date_bbox(ocr_data, date_str):
    # Parse YYYY-MM-DD
    year, month, day = date_str.split('-')

    # Try common formats
    formats = [
        date_str,                    # 2024-03-15
        f"{day}/{month}/{year}",     # 15/03/2024
        f"{day}-{month}-{year}",     # 15-03-2024
        f"{day}.{month}.{year}",     # 15.03.2024
    ]

    for fmt in formats:
        bbox = find_text_bbox(ocr_data, fmt)
        if bbox:
            return bbox

    return None
```

---

## Best Practices

### 1. Filter Low Confidence

```python
# Always filter before searching
ocr_data = filter_ocr_by_confidence(ocr_data, min_confidence=50)
```

### 2. Try Multiple Formats

```python
# Numbers can appear many ways
patterns = ['17400.00', '17,400.00', '$17,400.00']
```

### 3. Handle Missing Fields

```python
bbox = find_text_bbox(ocr_data, 'MISSING')
if bbox is None:
    # Field not found - handle gracefully
    pass
```

### 4. Normalize for ML

```python
# Always normalize if using for training
normalized = normalize_bbox(bbox, img.width, img.height)
```

---

## Common Issues

### OCR Errors

- "0" vs "O" confusion
- "1" vs "l" confusion
- Split words (e.g., "FAC" "TURA")
- Merged words

### Solutions

- Use confidence filtering
- Search for partial matches
- Try fuzzy matching
- Use labeled field search

---

## Next Steps

- **Subtask 2.7**: Create JSON sidecar file generator
- Save ground truth labels with bounding boxes
- Format for ML training pipelines
