# T008.1 InvoiceInferenceEngine Class - Learning Guide

## Overview
This guide explains the design of the InvoiceInferenceEngine, the main orchestrator for invoice data extraction.

## The Orchestration Pattern

The InvoiceInferenceEngine follows the **Facade Pattern**, providing a simple interface to a complex subsystem:

```
┌───────────────────────────────────────────────┐
│           InvoiceInferenceEngine              │
│                                               │
│  ┌─────────┐  ┌─────────┐  ┌───────────────┐ │
│  │   OCR   │  │  TATR   │  │   LayoutLM    │ │
│  │ Engine  │  │  Model  │  │    Model      │ │
│  └────┬────┘  └────┬────┘  └───────┬───────┘ │
│       │            │               │          │
│       └────────────┴───────────────┘          │
│                    │                          │
│              predict(image)                   │
│                    │                          │
│                    ▼                          │
│            InvoiceResult                      │
└───────────────────────────────────────────────┘
```

## InvoiceResult Dataclass

Using Python's `dataclass` decorator provides:
- Automatic `__init__` generation
- Automatic `__repr__` for debugging
- `asdict()` for JSON serialization
- Type hints for documentation

```python
from dataclasses import dataclass, asdict

@dataclass
class InvoiceResult:
    rfc_emisor: str
    rfc_receptor: str
    date: str
    subtotal: float
    iva: float
    total: float
    line_items: List[Dict]
    confidence: float
    warnings: List[str]

# Usage
result = InvoiceResult(
    rfc_emisor='XAXX010101000',
    rfc_receptor='XBBB020202000',
    date='2024-01-01',
    subtotal=1000.0,
    iva=160.0,
    total=1160.0,
    line_items=[{'description': 'Product A'}],
    confidence=0.95,
    warnings=[]
)

# Serialize to dict (for JSON)
data = asdict(result)
```

## Lazy Loading Pattern

Heavy models (TATR, LayoutLM) take time to load. The `load_models` parameter enables:

1. **Testing without models**: Fast unit tests
2. **Deferred loading**: Load models when first needed
3. **Memory control**: Don't load until necessary

```python
class InvoiceInferenceEngine:
    def __init__(self, load_models: bool = True):
        self.ocr = None
        self.tatr = None
        self.layoutlm = None

        if load_models:
            self._load_models()

    def _load_models(self):
        self.ocr = OCREngine()
        self.tatr = TATRModel()
        self.layoutlm = LayoutLMModel()
```

## Conditional Imports

Gracefully handle missing dependencies:

```python
try:
    from .utils.ocr import OCREngine
    OCR_AVAILABLE = True
except ImportError:
    OCREngine = None
    OCR_AVAILABLE = False

# Later, in _load_models:
if OCR_AVAILABLE and OCREngine is not None:
    self.ocr = OCREngine()
```

This pattern allows:
- Running tests without all dependencies
- Deploying with subset of features
- Clear error messages when deps missing

## Logging Best Practices

Use module-level logger:

```python
import logging

logger = logging.getLogger(__name__)

class InvoiceInferenceEngine:
    def __init__(self, load_models: bool = True):
        if load_models:
            logger.info("Initializing inference engine...")
            self._load_models()
            logger.info("Inference engine ready")
```

Benefits:
- Hierarchical logging (`inference.InvoiceInferenceEngine`)
- Configurable at runtime
- Works with any logging handler

## Testing Without Dependencies

Use `load_models=False` in tests:

```python
def test_engine_structure():
    engine = InvoiceInferenceEngine(load_models=False)
    assert hasattr(engine, 'ocr')
    assert hasattr(engine, 'tatr')
    assert hasattr(engine, 'layoutlm')
    assert engine.ocr is None  # Not loaded
```

For tests that need models, mock them:

```python
@patch('inference.OCREngine')
def test_with_mock(mock_ocr):
    engine = InvoiceInferenceEngine()
    mock_ocr.assert_called()
```

## Key Takeaways

1. **Facade Pattern**: Single entry point for complex subsystem
2. **Dataclass**: Clean, serializable result objects
3. **Lazy Loading**: Control when heavy models load
4. **Conditional Imports**: Graceful degradation
5. **Module Logger**: Professional logging setup
