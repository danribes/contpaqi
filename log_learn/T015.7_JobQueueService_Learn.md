# Subtask 15.7: Job Queue Service - Learning Guide

## Overview

This guide explains the implementation of a **license-aware job queue service** that integrates license validation into all job processing operations. This is a critical component for commercial software where feature access and usage limits must be enforced based on the user's license type.

---

## Concepts

### 1. License-Gated Job Processing

The core concept is that every job must pass a license check before being processed:

```typescript
// Before processing any job, check license
const licenseCheck = checkLicenseForJob(license, job);
if (!licenseCheck.canProcess) {
  // Block the job with a specific reason
  markJobBlocked(job, licenseCheck.reason);
}
```

This ensures that:
- Expired licenses cannot process jobs
- Features are gated by license type
- Rate limits are enforced per license tier

### 2. Job Blocking vs. Job Failure

There's an important distinction:
- **Blocked**: Job cannot run due to license issues (not retryable)
- **Failed**: Job ran but encountered an error (potentially retryable)

```typescript
type JobStatus = 'pending' | 'processing' | 'completed' | 'failed' | 'blocked';

// Blocked jobs have a specific reason
interface Job {
  status: JobStatus;
  blockReason?: LicenseBlockReason;  // Only set when blocked
}
```

### 3. License Block Reasons

The system tracks why a job was blocked:

```typescript
type LicenseBlockReason =
  | 'NO_LICENSE'           // No license configured
  | 'LICENSE_EXPIRED'      // License past expiration date
  | 'LICENSE_REVOKED'      // License permanently revoked
  | 'LICENSE_SUSPENDED'    // License temporarily suspended
  | 'FEATURE_NOT_AVAILABLE'// Required feature not in license
  | 'RATE_LIMIT_EXCEEDED'  // Too many concurrent jobs
  | 'BATCH_SIZE_EXCEEDED'; // Batch size over limit
```

---

## Architecture

### Service Structure

```
JobQueueService
├── State Management
│   ├── jobs: Job[]
│   ├── currentLicense: License
│   └── processingCount: number
├── License Validation
│   ├── checkLicenseForJob()
│   ├── isLicenseValid()
│   └── hasRequiredFeature()
├── Rate Limiting
│   ├── getMaxConcurrentJobs()
│   ├── getMaxBatchSize()
│   └── isWithinRateLimit()
├── Job Processing
│   ├── processNextJob()
│   └── retryFailedJobs()
└── Event System
    └── onEvent() / offEvent()
```

### License Tier Limits

Different license types have different limits:

| License Type | Concurrent Jobs | Batch Size | Features |
|--------------|-----------------|------------|----------|
| Trial        | 1               | 5          | basic |
| Standard     | 3               | 25         | basic, export |
| Professional | 10              | 100        | basic, export, batch, api |
| Enterprise   | Unlimited       | Unlimited  | All features |

---

## Implementation Patterns

### 1. Feature Gating Pattern

Jobs can specify required features in their data:

```typescript
// Add a job that requires the 'batch' feature
queue.addJob('batch-process', {
  files: fileList,
  requiredFeature: 'batch'  // This will be checked
});

// In checkLicenseForJob:
function checkLicenseForJob(license: License, job: Job): LicenseCheckResult {
  const requiredFeature = job.data.requiredFeature;

  if (requiredFeature && !license.features.includes(requiredFeature)) {
    return {
      canProcess: false,
      reason: 'FEATURE_NOT_AVAILABLE',
      message: `Feature "${requiredFeature}" not available`
    };
  }

  return { canProcess: true, reason: null };
}
```

### 2. Rate Limiting Pattern

Concurrent job limits are enforced before starting each job:

```typescript
// Check rate limit before processing
if (this.config.enableRateLimiting) {
  if (!isWithinRateLimit(license, this.state.processingCount)) {
    return {
      success: false,
      blocked: true,
      reason: 'RATE_LIMIT_EXCEEDED'
    };
  }
}

// Track processing count
this.state.processingCount++;
try {
  await processJob(job);
} finally {
  this.state.processingCount--;
}
```

### 3. Priority Queue Pattern

Jobs are processed by priority:

```typescript
const PRIORITY_ORDER = {
  critical: 4,
  high: 3,
  normal: 2,
  low: 1
};

function getNextJob(state: JobQueueState): Job | null {
  const pendingJobs = state.jobs.filter(j => j.status === 'pending');

  // Sort by priority (highest first)
  pendingJobs.sort((a, b) =>
    PRIORITY_ORDER[b.priority] - PRIORITY_ORDER[a.priority]
  );

  return pendingJobs[0] || null;
}
```

### 4. Event-Driven Updates Pattern

The service emits events for UI updates:

```typescript
// Listen for events
queue.onEvent((event) => {
  switch (event.type) {
    case 'JOB_BLOCKED':
      showLicenseWarning(event.details.reason);
      break;
    case 'JOB_COMPLETED':
      updateUI(event.details.jobId);
      break;
    case 'LICENSE_CHECKED':
      logLicenseCheck(event.details);
      break;
  }
});
```

---

## Integration Points

### With LicenseValidator

```typescript
import { LicenseValidator } from './LicenseValidator';
import { JobQueueService } from './JobQueueService';

const validator = new LicenseValidator();
const queue = new JobQueueService();

// After validating license, set it in the queue
const result = await validator.validate(licenseKey);
if (result.valid && result.license) {
  queue.setLicense(result.license);
}
```

### With OfflineGraceManager

```typescript
import { OfflineGraceManager } from './OfflineGracePeriod';

const graceManager = new OfflineGraceManager();
const queue = new JobQueueService();

// Check offline status
queue.setOfflineMode(graceManager.isInGracePeriod());

// Listen for grace period events
graceManager.onEvent((event) => {
  if (event.type === 'GRACE_EXPIRED') {
    queue.clearLicense();  // Force re-validation
  }
});
```

### With BatchProcessing UI

```typescript
import { useBatchProcessing } from './BatchProcessing';
import { JobQueueService } from './JobQueueService';

const queue = new JobQueueService();

// Connect batch processing to queue
const handleProcessFile = async (file: File) => {
  const jobId = queue.addJob('pdf-process', { file });
  const result = await queue.processNextJob();

  if (result.blocked) {
    throw new Error(`License issue: ${result.reason}`);
  }

  return result.result;
};

const batch = useBatchProcessing({
  onProcessFile: handleProcessFile
});
```

---

## Best Practices

### 1. Always Check License Before Heavy Operations

```typescript
// Good: Check before starting expensive work
async function processLargeFile(file: File) {
  const check = checkLicenseForJob(license, { requiredFeature: 'batch' });
  if (!check.canProcess) {
    throw new LicenseError(check.reason);
  }
  // Now do the expensive processing
}
```

### 2. Graceful Degradation for Feature Restrictions

```typescript
// Show what's available with current license
function getAvailableFeatures(license: License): string[] {
  return license.features;
}

function isFeatureDisabled(license: License, feature: string): boolean {
  return !license.features.includes(feature);
}

// In UI: Show disabled features with upgrade prompt
<Button
  disabled={isFeatureDisabled(license, 'batch')}
  title={isFeatureDisabled(license, 'batch') ? 'Upgrade to use batch processing' : ''}
>
  Batch Process
</Button>
```

### 3. Clear Error Messages for License Issues

```typescript
const BLOCK_MESSAGES: Record<LicenseBlockReason, string> = {
  NO_LICENSE: 'Please enter a valid license key to continue.',
  LICENSE_EXPIRED: 'Your license has expired. Please renew to continue.',
  LICENSE_REVOKED: 'This license has been revoked. Contact support.',
  LICENSE_SUSPENDED: 'License temporarily suspended. Contact support.',
  FEATURE_NOT_AVAILABLE: 'Upgrade your license to access this feature.',
  RATE_LIMIT_EXCEEDED: 'Processing limit reached. Upgrade for more capacity.',
  BATCH_SIZE_EXCEEDED: 'Batch too large for your license. Upgrade or reduce batch size.'
};
```

---

## Testing Strategies

### 1. Test Each License Scenario

```typescript
describe('license scenarios', () => {
  it('blocks with no license', async () => {
    const service = new JobQueueService();
    // Don't set license
    const result = await service.processNextJob();
    expect(result.blocked).toBe(true);
    expect(result.reason).toBe('NO_LICENSE');
  });

  it('blocks with expired license', async () => {
    const service = new JobQueueService();
    service.setLicense(createExpiredLicense());
    const result = await service.processNextJob();
    expect(result.blocked).toBe(true);
    expect(result.reason).toBe('LICENSE_EXPIRED');
  });
});
```

### 2. Test Feature Gating

```typescript
describe('feature gating', () => {
  it('blocks feature for wrong license tier', async () => {
    const service = new JobQueueService();
    service.setLicense(createTrialLicense()); // No 'batch' feature
    service.addJob('batch', { requiredFeature: 'batch' });

    const result = await service.processNextJob();
    expect(result.reason).toBe('FEATURE_NOT_AVAILABLE');
  });
});
```

### 3. Test Rate Limits

```typescript
describe('rate limits', () => {
  it('enforces concurrent job limit', async () => {
    const service = new JobQueueService();
    service.setLicense(createTrialLicense()); // Max 1 concurrent

    service.addJob('job1', {});
    service.addJob('job2', {});

    // Start first job (but don't complete)
    const promise1 = service.processNextJob();

    // Second job should be blocked
    const result2 = await service.processNextJob();
    expect(result2.reason).toBe('RATE_LIMIT_EXCEEDED');

    await promise1;
  });
});
```

---

## Summary

The JobQueueService provides a robust foundation for license-aware job processing by:

1. **Validating licenses** before any job processing
2. **Gating features** based on license type
3. **Enforcing rate limits** per license tier
4. **Providing clear feedback** on why jobs are blocked
5. **Supporting offline mode** with cached licenses
6. **Emitting events** for UI integration

This ensures that commercial software properly enforces licensing while providing a good user experience with clear error messages and graceful degradation.
