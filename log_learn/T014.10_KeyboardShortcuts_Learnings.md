# T014.10 - Keyboard Shortcuts Learnings

**Subtask**: 14.10 - Add keyboard shortcuts for efficiency
**Date**: 2025-12-09

---

## Key Learnings

### 1. Cross-Platform Modifier Key Handling

**Challenge**: Mac uses Command (⌘) while Windows/Linux uses Ctrl.

**Solution**: Treat both as equivalent for shortcut matching:

```typescript
// Treats Cmd (metaKey) as Ctrl for cross-platform support
if (parsed.ctrl !== (event.ctrlKey || event.metaKey)) return false;
```

**Display**: Show platform-appropriate symbols:
```typescript
formatShortcutDisplay('Ctrl+S', false);  // "Ctrl+S" (Windows)
formatShortcutDisplay('Ctrl+S', true);   // "⌘S" (Mac)
```

### 2. Form Element Handling

**Challenge**: Shortcuts shouldn't interfere with typing in form fields.

**Solution**: Block shortcuts in inputs/textareas, except essential ones:

```typescript
function shouldPreventShortcut(event: KeyboardEvent): boolean {
  const tagName = (event.target as HTMLElement).tagName.toLowerCase();

  if (tagName === 'input' || tagName === 'textarea') {
    // Always allow Escape (for cancel) and Ctrl+Enter (for submit)
    if (event.key === 'Escape') return false;
    if ((event.ctrlKey || event.metaKey) && event.key === 'Enter') return false;
    return true;
  }
  return false;
}
```

**Rationale**: Users expect Ctrl+Z to undo text, not trigger app shortcuts.

### 3. Key Normalization

**Challenge**: Key combinations can be expressed inconsistently.

**Solution**: Normalize to a consistent format:

```typescript
// These all become "Ctrl+Shift+S"
normalizeKeyCombination('ctrl+shift+s');    // lowercase
normalizeKeyCombination('shift+ctrl+s');    // different order
normalizeKeyCombination('Ctrl + Shift + S'); // spaces
```

**Order**: Ctrl → Alt → Shift → Meta → Key (consistent ordering)

### 4. Special Key Names

**Challenge**: Browser returns different values for special keys.

**Solution**: Map common variations:

```typescript
// Handle Escape key variations
if (shortcutKey === 'escape' && (eventKey === 'escape' || eventKey === 'esc'))
  return true;

// Handle Space key
if (shortcutKey === 'space' && eventKey === ' ')
  return true;
```

### 5. Registry Pattern for Shortcuts

**Learning**: Using a Map-based registry with normalized keys provides:
- O(1) lookup for shortcut matching
- Easy conflict detection
- Simple enable/disable per-shortcut

```typescript
interface ShortcutRegistry {
  shortcuts: Map<string, KeyboardShortcut>;  // key: normalized combination
  enabled: boolean;
}
```

### 6. Category-Based Organization

**Learning**: Grouping shortcuts by category improves discoverability:

```typescript
type ShortcutCategory = 'navigation' | 'actions' | 'form' | 'batch' | 'pdf';
```

Benefits:
- Help modal shows organized sections
- Users can find shortcuts by context
- Easy to enable/disable by category

### 7. React Hook Design Patterns

**Learning**: Two levels of abstraction work well:

1. **Low-level hook** (`useKeyboardShortcuts`): Direct event handling
   ```typescript
   useKeyboardShortcuts({ shortcuts, enabled, onShortcutTriggered });
   ```

2. **High-level context** (`KeyboardShortcutsProvider`): App-wide management
   ```typescript
   const { register, unregister, showHelp } = useKeyboardShortcutsContext();
   ```

### 8. Test Pattern for Non-JSX Modules

**Pattern**: Define types and functions locally in test files to avoid JSX compilation issues:

```typescript
// In test file - local implementations
interface KeyboardShortcut { ... }
function parseKeyCombination(keys: string): ParsedKeyCombination { ... }

// Tests run without JSX transformer
describe('parseKeyCombination', () => {
  it('should parse Ctrl+key', () => { ... });
});
```

This allows pure function testing without component rendering.

### 9. Mac Symbol Reference

| Key | Mac Symbol | Notes |
|-----|------------|-------|
| Ctrl/Cmd | ⌘ | Command |
| Alt/Option | ⌥ | Option |
| Shift | ⇧ | Up arrow |
| Enter | ↩ | Return |
| Escape | ⎋ | Broken circle |
| Tab | ⇥ | Tab arrow |
| Delete | ⌫ | Backspace |

### 10. Prevent Default vs Stop Propagation

**Learning**: For keyboard shortcuts, use both:

```typescript
if (matchesShortcut(event, shortcut)) {
  event.preventDefault();      // Stop browser default action
  event.stopPropagation();     // Stop event bubbling
  shortcut.handler();
  return;
}
```

- `preventDefault()`: Stops browser actions (e.g., Ctrl+S save dialog)
- `stopPropagation()`: Prevents other handlers from firing

---

## Best Practices Discovered

### 1. Shortcut Documentation in UI

Always show shortcuts in context:
```tsx
<button onClick={onSubmit}>
  Submit <ShortcutBadge keys="Ctrl+Enter" />
</button>
```

### 2. Help Modal Access

Provide multiple ways to access help:
- F1 (standard help key)
- Ctrl+/ or Cmd+/ (common in modern apps)
- UI button with shortcut badge

### 3. Shortcut Conflict Detection

Check for conflicts before registering:
```typescript
if (hasConflict(registry, 'Ctrl+S')) {
  console.warn('Shortcut conflict: Ctrl+S already registered');
}
```

### 4. Enable/Disable Patterns

Disable shortcuts when appropriate:
- During modals (except Escape)
- During drag operations
- When component is not focused

### 5. Factory Functions for Common Shortcuts

Group related shortcuts into factory functions:
```typescript
const formShortcuts = createDefaultFormShortcuts({
  submit: handleSubmit,
  cancel: handleCancel,
});
```

---

## Common Pitfalls

### 1. Event Listener Cleanup

Always clean up listeners:
```typescript
useEffect(() => {
  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, [dependencies]);
```

### 2. Stale Closures

Use `useCallback` with proper dependencies:
```typescript
const handleSubmit = useCallback(() => {
  // Use latest state
  submitForm(formData);
}, [formData]);
```

### 3. Case Sensitivity

Always normalize case for comparison:
```typescript
const eventKey = event.key.toLowerCase();
const shortcutKey = parsed.key.toLowerCase();
```

---

## Architecture Decisions

### Why Map for Registry?

Considered alternatives:
- Array: O(n) lookup, easier iteration
- Object: String keys only, no Map methods
- **Map**: O(1) lookup, any key type, preserves insertion order

### Why Separate Provider and Hook?

- Provider: Global app-level shortcuts (help, search)
- Hook: Component-specific shortcuts (form submit)

This allows flexibility for different use cases.

---

## Future Considerations

1. **Shortcut Sequences**: Support vim-style sequences (g → g)
2. **Chord Shortcuts**: Multiple keys held simultaneously
3. **User Customization**: Allow users to remap shortcuts
4. **Accessibility**: Ensure shortcuts don't conflict with screen readers

