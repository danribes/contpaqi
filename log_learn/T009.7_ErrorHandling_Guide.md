# T009.7 Error Handling - Learning Guide

## Overview
This guide explains how to implement error handling and request logging in FastAPI.

## Exception Handlers

### HTTP Exception Handler
Handle known HTTP errors with custom response:

```python
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    logger.warning(f"HTTP {exc.status_code}: {exc.detail}")
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": exc.detail}
    )
```

### General Exception Handler
Catch-all for unhandled exceptions:

```python
@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    logger.exception(f"Unhandled exception: {exc}")
    return JSONResponse(
        status_code=500,
        content={"error": "Internal server error", "detail": str(exc)}
    )
```

## Request Logging Middleware

```python
@app.middleware("http")
async def log_requests(request: Request, call_next):
    logger.info(f"{request.method} {request.url.path}")
    response = await call_next(request)
    logger.info(f"Response: {response.status_code}")
    return response
```

### Middleware Order
Middleware executes in reverse order of registration:
1. First registered = outermost (executes last)
2. Last registered = innermost (executes first)

## Logging Configuration

### Basic Setup
```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("main")
```

### Log Levels
| Level | Use Case |
|-------|----------|
| DEBUG | Detailed debugging |
| INFO | General information |
| WARNING | Potential issues |
| ERROR | Errors that were handled |
| EXCEPTION | Errors with traceback |

## Error Response Best Practices

### Consistent Structure
```json
{
    "error": "Human-readable message",
    "status_code": 400,
    "detail": "Additional context"
}
```

### What to Include
- `error`: User-friendly message
- `status_code`: HTTP status
- `detail`: Debug info (consider hiding in production)

### What to Avoid
- Stack traces in production
- Internal system details
- Sensitive information

## Security Considerations

### Development vs Production
```python
@app.exception_handler(Exception)
async def handler(request, exc):
    if app.debug:
        detail = str(exc)  # Show details
    else:
        detail = None  # Hide in production

    return JSONResponse(
        status_code=500,
        content={"error": "Internal error", "detail": detail}
    )
```

## Key Takeaways

1. **Always Catch Exceptions**: Never let raw exceptions reach users
2. **Log Everything**: Log requests and errors for debugging
3. **Consistent Responses**: Use same error format everywhere
4. **Hide Sensitive Info**: Don't expose internals in production
5. **Use Appropriate Levels**: DEBUG for dev, INFO for prod
