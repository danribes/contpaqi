# T007.4 Field Extraction - Learning Guide

## Overview
This guide explains how to group BIO-tagged tokens into complete invoice fields.

## What is BIO Tagging?

BIO (Begin, Inside, Outside) is a standard tagging scheme for sequence labeling:

| Tag | Meaning | Example |
|-----|---------|---------|
| **B-X** | Beginning of entity X | First word of RFC |
| **I-X** | Inside/continuation of X | Second+ word of RFC |
| **O** | Outside any entity | "FACTURA", "No." |

### Example Sequence
```
Words:  [RFC:,    XAXX,     010101,   000,     TOTAL:, $1,160.00]
Labels: [O,       B-RFC,    I-RFC,    I-RFC,   O,      B-TOTAL]
```

Result:
- RFC = "XAXX 010101 000"
- TOTAL = "$1,160.00"

## The State Machine

```
                        ┌───────────┐
                        │  IDLE     │◄─────────────┐
                        └─────┬─────┘              │
                              │ B-X                │
                              ▼                    │
                        ┌───────────┐              │
              ┌────────►│ IN_FIELD  │              │
              │         │    X      │              │
              │         └─────┬─────┘              │
              │               │                    │
         I-X  │    ┌──────────┼──────────┐        │
              │    │          │          │        │
              └────┤    O     │    B-Y   │  I-Y   │
                   │          │    (new) │ (diff) │
                   ▼          ▼          ▼        │
              ┌───────────────────────────────────┘
              │         SAVE FIELD X
              └──────────────────────────────────
```

## Implementation Pattern

### Main Loop
```python
def extract_fields(predictions):
    fields = {}
    current_field = None
    current_tokens = []

    for pred in predictions:
        label = pred['label']

        if label.startswith('B-'):
            # Save previous field if exists
            if current_field and current_tokens:
                fields[current_field] = merge_tokens(current_tokens)

            # Start new field
            current_field = label[2:]  # Remove 'B-'
            current_tokens = [pred]

        elif label.startswith('I-') and current_field == label[2:]:
            # Continue current field (matching type)
            current_tokens.append(pred)

        else:
            # End field: O or mismatched I-
            if current_field and current_tokens:
                fields[current_field] = merge_tokens(current_tokens)
            current_field = None
            current_tokens = []

    # Don't forget the last field!
    if current_field and current_tokens:
        fields[current_field] = merge_tokens(current_tokens)

    return fields
```

### Token Merging
```python
def merge_tokens(tokens, field_name):
    # Words: concatenate with spaces
    value = ' '.join(t['word'] for t in tokens)

    # Confidence: average
    confidence = sum(t['confidence'] for t in tokens) / len(tokens)

    # Bounding box: union (enclosing rectangle)
    bbox = (
        min(t['bbox'][0] for t in tokens),  # leftmost x1
        min(t['bbox'][1] for t in tokens),  # topmost y1
        max(t['bbox'][2] for t in tokens),  # rightmost x2
        max(t['bbox'][3] for t in tokens)   # bottommost y2
    )

    return ExtractedField(label=field_name, value=value,
                          confidence=confidence, bbox=bbox)
```

## Bounding Box Union

```
Token 1 bbox: (10, 20, 50, 40)
Token 2 bbox: (55, 15, 120, 45)

Union calculation:
  x1 = min(10, 55)  = 10   (leftmost)
  y1 = min(20, 15)  = 15   (topmost)
  x2 = max(50, 120) = 120  (rightmost)
  y2 = max(40, 45)  = 45   (bottommost)

Result: (10, 15, 120, 45)

  ┌────────────────────────────────────┐
  │                                    │ y1=15
  │   ┌─────────┐     ┌──────────────┐│
  │   │ Token 1 │     │   Token 2    ││
  │   │         │     │              ││
  │   └─────────┘     └──────────────┘│ y2=45
  └────────────────────────────────────┘
x1=10                               x2=120
```

## Edge Cases

### 1. Orphan I- Tags
```python
predictions = [{'word': 'orphan', 'label': 'I-TOTAL', ...}]
# Result: {} (no field, I- needs preceding B-)
```

### 2. Mismatched I- Tags
```python
predictions = [
    {'word': 'ABC', 'label': 'B-RFC_EMISOR', ...},
    {'word': '123', 'label': 'I-RFC_RECEPTOR', ...},  # Different type!
]
# Result: {'RFC_EMISOR': 'ABC'}
# The I-RFC_RECEPTOR is ignored (type mismatch)
```

### 3. Last Field in Sequence
```python
predictions = [
    {'word': 'header', 'label': 'O', ...},
    {'word': '$100', 'label': 'B-TOTAL', ...},
]
# Result: {'TOTAL': '$100'}
# Don't forget to save after the loop!
```

## Confidence Averaging

For multi-token fields, the confidence is the mean:

```python
tokens = [
    {'confidence': 0.80},
    {'confidence': 0.90},
    {'confidence': 0.85},
]
# Average: (0.80 + 0.90 + 0.85) / 3 = 0.85
```

This gives a reasonable estimate, though alternatives exist:
- **Min**: Most conservative (worst token)
- **Max**: Most optimistic (best token)
- **Weighted by length**: Longer words count more

## Key Takeaways

1. **BIO tagging** is a standard NER scheme
2. **B- starts** a new field, **I- continues** it
3. **O or mismatched I-** ends the current field
4. **Don't forget the last field** after the loop
5. **Merge tokens** by concatenating text, averaging confidence, and taking bbox union
