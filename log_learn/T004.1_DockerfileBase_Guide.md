# T004.1 Dockerfile Base - Learning Guide

**Task**: Create Dockerfile with python:3.9-slim-bullseye base
**Date**: 2025-12-04

---

## What is Docker?

Docker is a platform for developing, shipping, and running applications in containers. Containers are lightweight, standalone, executable packages that include everything needed to run a piece of software.

## Multi-Stage Builds

### Why Multi-Stage?

Traditional Dockerfiles often result in large images because build dependencies remain in the final image. Multi-stage builds solve this by:

1. **Stage 1 (Builder)**: Install build tools, compile code, create artifacts
2. **Stage 2 (Runtime)**: Copy only necessary artifacts, minimal dependencies

### Example Pattern

```dockerfile
# Stage 1: Builder
FROM python:3.9-slim-bullseye as builder
RUN apt-get install build-essential  # Heavy tools
RUN pip wheel -r requirements.txt     # Create wheels

# Stage 2: Runtime (much smaller!)
FROM python:3.9-slim-bullseye
COPY --from=builder /app/wheels /wheels
RUN pip install /wheels/*
```

### Benefits

| Benefit | Description |
|---------|-------------|
| Smaller images | Final image doesn't include compilers, headers |
| Faster deploys | Less data to transfer |
| Better security | Fewer packages = smaller attack surface |
| Cleaner separation | Build-time vs runtime dependencies |

## Python Base Image Selection

### Available Python Images

| Image | Size | Use Case |
|-------|------|----------|
| `python:3.9` | ~900MB | Full installation |
| `python:3.9-slim` | ~120MB | Minimal, production |
| `python:3.9-alpine` | ~50MB | Smallest, but musl issues |
| `python:3.9-slim-bullseye` | ~120MB | Slim + specific Debian |

### Why `slim-bullseye`?

1. **Slim**: Removes unnecessary packages (man pages, docs)
2. **Bullseye**: Debian 11 LTS, well-tested, stable
3. **glibc**: Standard C library, better compatibility than Alpine's musl

## Dockerfile Best Practices

### 1. Ordering Layers

Put frequently changing layers last to maximize cache hits:

```dockerfile
# Rarely changes - cached
COPY requirements.txt .
RUN pip install -r requirements.txt

# Changes often - rebuilt each time
COPY src/ ./src/
```

### 2. Combining Commands

Reduce layers by combining related commands:

```dockerfile
# Bad: Multiple layers
RUN apt-get update
RUN apt-get install -y package1
RUN apt-get install -y package2

# Good: Single layer
RUN apt-get update && apt-get install -y \
    package1 \
    package2 \
    && rm -rf /var/lib/apt/lists/*
```

### 3. Cleaning Up

Always clean package manager caches:

```dockerfile
RUN apt-get update && apt-get install -y \
    tesseract-ocr \
    && rm -rf /var/lib/apt/lists/*  # Clean cache!
```

### 4. Using .dockerignore

Create `.dockerignore` to exclude unnecessary files:

```
.git
__pycache__
*.pyc
.env
*.log
```

## Security Best Practices

### Non-Root User

Running as root inside containers is dangerous:

```dockerfile
# Create user
RUN useradd -m appuser && chown -R appuser:appuser /app

# Switch to non-root
USER appuser
```

### No Cached Credentials

Don't cache pip packages (may contain sensitive data):

```dockerfile
RUN pip install --no-cache-dir -r requirements.txt
```

## Health Checks

Docker health checks monitor container status:

```dockerfile
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1
```

| Parameter | Description |
|-----------|-------------|
| `--interval` | How often to check |
| `--timeout` | Max time for check |
| `--retries` | Failures before unhealthy |
| `--start-period` | Grace period on startup |

## Testing Dockerfiles

### Static Analysis

Test Dockerfile syntax and best practices without building:

```python
def test_has_healthcheck(dockerfile_content):
    assert "HEALTHCHECK" in dockerfile_content

def test_no_root_user(dockerfile_content):
    assert "USER" in dockerfile_content
```

### Build Testing

Actually build and test the image:

```bash
# Build
docker build -t myimage:test .

# Verify size
docker images myimage:test

# Run health check
docker run --rm myimage:test curl localhost:8000/health
```

## Key Takeaways

1. **Multi-stage builds** reduce image size and improve security
2. **Slim images** are ideal for production
3. **Layer ordering** affects build cache efficiency
4. **Non-root users** are essential for security
5. **Health checks** enable container orchestration

## Further Reading

- [Docker Best Practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
- [Multi-stage Builds](https://docs.docker.com/build/building/multi-stage/)
- [Python Docker Images](https://hub.docker.com/_/python)
- [Dockerfile Reference](https://docs.docker.com/reference/dockerfile/)
