# T008.3 TATR Integration - Learning Guide

## Overview
This guide explains how the `_detect_table_structure()` method integrates the TATR model for table and row detection.

## What TATR Detects

TATR (Table Transformer) is designed to detect table structures:

```
┌─────────────────────────────────────────────────┐
│  FACTURA                                        │ ◄── Not part of table
├─────────────────────────────────────────────────┤
│  Descripción    │  Cant  │  Precio  │  Importe │ ◄── Header row
├─────────────────────────────────────────────────┤
│  Producto A     │  2     │  $500    │  $1,000  │ ◄── Data row
├─────────────────────────────────────────────────┤
│  Producto B     │  1     │  $160    │  $160    │ ◄── Data row
└─────────────────────────────────────────────────┘
                  │        │          │          │
                  └────────┴──────────┴──────────┘
                        Table bounds (x1, y1, x2, y2)
```

## Method Design

### Simple Orchestration
The method simply calls two TATR methods and packages the results:

```python
def _detect_table_structure(self, image):
    # Get overall table bounds
    table_bounds = self.tatr.get_table_bounds(image)

    # Get individual row bounds
    rows = self.tatr.get_table_rows(image)

    return {'table': table_bounds, 'rows': rows}
```

### Why a Dictionary Return?
A dictionary provides named access to results:

```python
# ✅ Clear and readable
result = engine._detect_table_structure(image)
if result['table']:
    process_table(result['rows'])

# ❌ Tuple would be less clear
table, rows = engine._detect_table_structure(image)
```

## Handling No Table Found

When no table is detected, `get_table_bounds()` returns `None`:

```python
result = engine._detect_table_structure(image)

if result['table'] is None:
    # No table found - image might not be an invoice
    # or table detection failed
    logger.warning("No table detected in image")
    return
```

## Row Order

Rows are returned in reading order (top to bottom):

```python
rows = [
    (50, 100, 550, 130),  # y1=100 - Header
    (50, 135, 550, 165),  # y1=135 - Row 1
    (50, 170, 550, 200),  # y1=170 - Row 2
    (50, 205, 550, 235),  # y1=205 - Row 3
]

# First row is typically the header
header_row = rows[0]
data_rows = rows[1:]
```

## Integration with OCR

The table structure helps filter OCR results:

```python
def get_words_in_row(words, row_bbox):
    """Get words that fall within a row's bounds."""
    rx1, ry1, rx2, ry2 = row_bbox
    return [
        w for w in words
        if ry1 <= w.bbox[1] <= ry2  # Word's y is within row
    ]

# Usage
structure = engine._detect_table_structure(image)
for row in structure['rows']:
    row_words = get_words_in_row(ocr_words, row)
    # Process words in this row
```

## Why Separate Methods?

Instead of a single `detect_all()` method, we have:

1. `get_table_bounds()` - Just the outer rectangle
2. `get_table_rows()` - Individual row rectangles

This allows flexibility:
- Some use cases only need bounds (cropping)
- Some need rows (line item extraction)
- Calling both is cheap (model runs once internally)

## Error Handling

The method fails naturally when `tatr` is None:

```python
engine = InvoiceInferenceEngine(load_models=False)
engine._detect_table_structure(image)  # AttributeError!
```

This is intentional - calling detection without a loaded model is a programming error.

## Key Takeaways

1. **Simple orchestration**: Calls two TATR methods, packages results
2. **Dict return**: Named keys for clarity
3. **None for no table**: Explicit handling of missing tables
4. **Row order**: Top-to-bottom, header first
5. **Fail fast**: No silent failures when TATR unavailable
