# Learning Guide - Subtask 18.10
## Writing Unit Tests for i18n Functionality

**Date:** 2025-12-12

---

## What Was Developed

This subtask creates comprehensive unit tests for validating the i18n (internationalization) system in a React/Electron application using i18next.

---

## Why This Was Needed

1. **Quality Assurance:** Ensure translations are complete and consistent
2. **Key Parity:** Verify both languages have the same keys
3. **Interpolation:** Validate variable placeholders match between languages
4. **Configuration:** Ensure i18next is properly configured
5. **Regression Prevention:** Catch missing or broken translations early

---

## i18next Testing Strategy

### Challenge: Testing Without Runtime

i18next runs in a browser/Electron context, but tests run in Node.js. We can't easily initialize the full i18next instance in tests.

### Solution: Static Analysis

Instead of testing runtime behavior, we:
1. Parse JSON translation files directly
2. Analyze TypeScript source code patterns
3. Validate structure without executing i18next

```typescript
// Load translation files for testing
const enTranslations = JSON.parse(
  fs.readFileSync(path.join(__dirname, '../src/i18n/locales/en.json'), 'utf-8')
);
const esTranslations = JSON.parse(
  fs.readFileSync(path.join(__dirname, '../src/i18n/locales/es.json'), 'utf-8')
);

// Load i18n config for pattern matching
const i18nIndexContent = fs.readFileSync(
  path.join(__dirname, '../src/i18n/index.ts'),
  'utf-8'
);
```

---

## Key Testing Patterns

### 1. Key Parity Testing

Ensure both languages have identical keys:

```typescript
function getAllKeys(obj: Record<string, unknown>, prefix = ''): string[] {
  const keys: string[] = [];
  for (const key in obj) {
    const fullKey = prefix ? `${prefix}.${key}` : key;
    if (typeof obj[key] === 'object' && obj[key] !== null) {
      keys.push(...getAllKeys(obj[key], fullKey));
    } else {
      keys.push(fullKey);
    }
  }
  return keys;
}

it('should have all English keys in Spanish', () => {
  const missingInSpanish = enKeys.filter(key => !esKeys.includes(key));
  expect(missingInSpanish).toEqual([]);
});
```

### 2. Interpolation Variable Testing

i18next uses `{{variable}}` syntax. Both languages must use the same variables:

```typescript
function findInterpolationVars(str: string): string[] {
  const matches = str.match(/\{\{(\w+)\}\}/g) || [];
  return matches.map(m => m.replace(/\{\{|\}\}/g, ''));
}

it('should have same interpolation vars', () => {
  const enVars = findInterpolationVars(enValue);
  const esVars = findInterpolationVars(esValue);
  expect(esVars.sort()).toEqual(enVars.sort());
});
```

**Example:**
```json
// English
"daysRemaining": "{{days}} days remaining"

// Spanish - MUST use same variable name
"daysRemaining": "{{days}} dÃ­as restantes"
```

### 3. Configuration Pattern Matching

Test i18next config without running it:

```typescript
it('should have English as fallback language', () => {
  expect(i18nIndexContent).toMatch(/fallbackLng:\s*['"]en['"]/);
});

it('should use localStorage for caching', () => {
  expect(i18nIndexContent).toMatch(/caches:\s*\[['"]localStorage['"]\]/);
});
```

### 4. Nested Key Access

Helper to access deeply nested values:

```typescript
function getNestedValue(obj: Record<string, unknown>, key: string): unknown {
  const parts = key.split('.');
  let current: unknown = obj;
  for (const part of parts) {
    if (current && typeof current === 'object' && part in current) {
      current = current[part];
    } else {
      return undefined;
    }
  }
  return current;
}

// Usage
expect(getNestedValue(enTranslations, 'invoice.form.title')).toBe('Invoice Details');
```

---

## Test Categories to Consider

### 1. Structure Tests
- File existence
- Valid JSON format
- Expected categories present
- No empty objects

### 2. Key Parity Tests
- Same number of keys
- No missing keys in either language
- Same nesting structure

### 3. Content Quality Tests
- No empty strings
- No null values
- Translations are actually different (not just copied English)
- Proper nouns are identical

### 4. Interpolation Tests
- Same variables in both languages
- Correct variable names
- No orphan variables

### 5. Configuration Tests
- Fallback language set
- Supported languages defined
- Detection order configured
- Persistence enabled

### 6. Integration Tests
- Registry loading function exists
- localStorage key defined
- React bindings configured

---

## Common i18next Configuration Options

```typescript
i18n
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    resources,
    fallbackLng: 'en',           // Fallback language
    supportedLngs: ['en', 'es'], // Supported languages
    defaultNS: 'translation',    // Default namespace

    detection: {
      order: ['localStorage', 'navigator', 'htmlTag'],
      caches: ['localStorage'],
      lookupLocalStorage: 'i18nextLng',
    },

    interpolation: {
      escapeValue: false,  // React handles XSS
    },

    react: {
      useSuspense: true,
    },

    debug: process.env.NODE_ENV === 'development',
  });
```

---

## Testing Interpolation Examples

### Common Patterns

| Key | English | Spanish | Variables |
|-----|---------|---------|-----------|
| `app.version` | `Version {{version}}` | `VersiÃ³n {{version}}` | version |
| `license.daysRemaining` | `{{days}} days remaining` | `{{days}} dÃ­as restantes` | days |
| `batch.filesProcessed` | `{{processed}} of {{total}} files` | `{{processed}} de {{total}} archivos` | processed, total |

### Test Code

```typescript
const interpolationExamples = [
  { key: 'app.version', vars: ['version'] },
  { key: 'license.daysRemaining', vars: ['days'] },
  { key: 'batch.filesProcessed', vars: ['processed', 'total'] },
];

interpolationExamples.forEach(({ key, vars }) => {
  it(`should have correct vars for "${key}"`, () => {
    const enValue = getNestedValue(enTranslations, key) as string;
    const foundVars = findInterpolationVars(enValue);
    expect(foundVars.sort()).toEqual(vars.sort());
  });
});
```

---

## Handling Edge Cases

### Same Word in Both Languages

Some words are identical in English and Spanish:

```typescript
// "No" is the same in both languages
const sameInBothLanguages = ['app.name', 'common.no'];
if (!sameInBothLanguages.includes(key)) {
  expect(esValue).not.toBe(enValue);
}
```

### Proper Nouns

Brand names should be identical:

```typescript
it('should have same app name in both languages', () => {
  expect(esTranslations.app.name).toBe(enTranslations.app.name);
});
```

---

## Test Statistics Output

Include a statistics test for visibility:

```typescript
it('should report translation statistics', () => {
  const stats = {
    totalEnglishKeys: enKeys.length,
    totalSpanishKeys: esKeys.length,
    keysWithInterpolation: enKeys.filter(key => {
      const value = getNestedValue(enTranslations, key);
      return typeof value === 'string' && value.includes('{{');
    }).length,
    categories: Object.keys(enTranslations).length
  };

  console.log('\nðŸ“Š Translation Statistics:');
  console.log(`   Total English keys: ${stats.totalEnglishKeys}`);
  console.log(`   Total Spanish keys: ${stats.totalSpanishKeys}`);
  console.log(`   Keys with interpolation: ${stats.keysWithInterpolation}`);
  console.log(`   Categories: ${stats.categories}`);

  expect(stats.totalEnglishKeys).toBeGreaterThan(100);
});
```

---

## Key Takeaways

1. **Static analysis** can test i18n without runtime initialization
2. **Key parity** is critical - missing translations break the app
3. **Interpolation variables** must match exactly between languages
4. **Pattern matching** TypeScript source validates configuration
5. **Edge cases** like identical words need special handling
6. **Statistics** help track translation coverage over time

---

## Files Summary

| File | Purpose |
|------|---------|
| `tests/i18n.test.ts` | 161 comprehensive tests |
| `src/i18n/index.ts` | i18next configuration |
| `src/i18n/locales/en.json` | English translations (338 keys) |
| `src/i18n/locales/es.json` | Spanish translations (338 keys) |
