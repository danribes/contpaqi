# T014.7 - Manual Correction Interface Guide

**Subtask**: 14.7 - Create manual correction interface
**Date**: 2025-12-09
**Purpose**: Educational documentation explaining the implementation

---

## Overview

This guide explains how to implement a manual correction interface for AI-extracted data in a React application. The interface allows users to edit values, track corrections, and revert changes.

---

## Why Manual Corrections?

AI document extraction isn't perfect. Users need to:

1. **Review** - See what the AI extracted
2. **Correct** - Fix any mistakes
3. **Track** - Know which fields were changed
4. **Revert** - Undo changes if needed
5. **Audit** - Keep history of modifications

---

## Core Concepts

### 1. Original vs Current Value

Always track both the original extracted value and the current (possibly corrected) value:

```typescript
interface FieldState {
  originalValue: string;  // What AI extracted
  currentValue: string;   // What user sees/edited
}
```

### 2. Correction Detection

A simple comparison tells us if the field was corrected:

```typescript
function hasBeenCorrected(original: string, current: string): boolean {
  return original !== current;
}
```

### 3. Confidence Adjustment

Manual corrections are "100% confident" because the user verified them:

```typescript
const MANUAL_OVERRIDE_CONFIDENCE = 1.0;

function getConfidenceAfterCorrection(
  originalConfidence: number,
  hasCorrection: boolean
): number {
  return hasCorrection ? MANUAL_OVERRIDE_CONFIDENCE : originalConfidence;
}
```

---

## Implementation Pattern

### State Structure

```typescript
interface CorrectionState {
  originalValue: string;
  currentValue: string;
  originalConfidence: number;
  currentConfidence: number;
  hasBeenCorrected: boolean;
  isManualOverride: boolean;
  correctionReason?: string;
}
```

### Creating Initial State

When populating from AI extraction:

```typescript
function createCorrectionState(
  originalValue: string,
  currentValue: string,
  originalConfidence: number,
  reason?: string
): CorrectionState {
  const corrected = hasBeenCorrected(originalValue, currentValue);
  return {
    originalValue,
    currentValue,
    originalConfidence,
    currentConfidence: getConfidenceAfterCorrection(originalConfidence, corrected),
    hasBeenCorrected: corrected,
    isManualOverride: corrected,
    correctionReason: corrected ? reason : undefined,
  };
}
```

### Applying Corrections

When user edits a field:

```typescript
function applyCorrection(
  state: CorrectionState,
  newValue: string,
  reason?: string
): CorrectionState {
  const corrected = newValue !== state.originalValue;
  return {
    ...state,
    currentValue: newValue,
    currentConfidence: corrected ? MANUAL_OVERRIDE_CONFIDENCE : state.originalConfidence,
    hasBeenCorrected: corrected,
    isManualOverride: corrected,
    correctionReason: corrected ? reason : undefined,
  };
}
```

### Reverting Changes

Allow users to undo their corrections:

```typescript
function revertToOriginal(state: CorrectionState): CorrectionState {
  return {
    ...state,
    currentValue: state.originalValue,
    currentConfidence: state.originalConfidence,
    hasBeenCorrected: false,
    isManualOverride: false,
    correctionReason: undefined,
  };
}
```

---

## React Components

### 1. CorrectionBadge

Visual indicator that a field was corrected:

```tsx
function CorrectionBadge({ hasBeenCorrected }: { hasBeenCorrected: boolean }) {
  if (!hasBeenCorrected) return null;

  return (
    <span className="bg-blue-100 text-blue-700 text-xs px-1.5 py-0.5 rounded">
      Corrected
    </span>
  );
}
```

### 2. OriginalValueDisplay

Show what the AI originally extracted:

```tsx
function OriginalValueDisplay({ originalValue, hasBeenCorrected }: Props) {
  if (!hasBeenCorrected) return null;

  return (
    <div className="text-xs text-gray-500">
      <span className="line-through">{originalValue}</span>
      <span className="ml-1 text-blue-600">(original)</span>
    </div>
  );
}
```

### 3. RevertButton

Allow undoing corrections:

```tsx
function RevertButton({ onRevert }: { onRevert: () => void }) {
  return (
    <button
      onClick={onRevert}
      title="Revert to original value"
      className="p-1 text-gray-500 hover:text-blue-600"
    >
      <UndoIcon />
    </button>
  );
}
```

---

## Integration with Form Fields

### Enhanced Form Field

```tsx
function FormFieldInput({
  label,
  value,
  originalValue,
  confidence,
  onChange,
  onRevert,
}: FormFieldProps) {
  const isCorrected = originalValue !== undefined && value !== originalValue;
  const displayConfidence = isCorrected ? 1.0 : confidence;

  return (
    <div className="mb-4">
      <label>
        {label}
        {isCorrected && <CorrectionBadge hasBeenCorrected />}
      </label>
      <div className="relative">
        <input
          value={value}
          onChange={(e) => onChange(e.target.value)}
          className={isCorrected ? 'border-blue-300 bg-blue-50' : ''}
        />
        {isCorrected && onRevert && <RevertButton onRevert={onRevert} />}
      </div>
      <OriginalValueDisplay
        originalValue={originalValue}
        hasBeenCorrected={isCorrected}
      />
    </div>
  );
}
```

---

## Visual Design Principles

### Color Coding

| State | Color | Meaning |
|-------|-------|---------|
| Corrected | Blue | User has modified the value |
| Low Confidence | Orange | AI uncertain, needs review |
| Math Error | Red | Calculation is wrong |
| High Confidence | Green | AI is confident |

### Visual Hierarchy

1. **Badge** - Quick indicator of correction status
2. **Border/Background** - Subtle color change for state
3. **Original Value** - Below field, strikethrough
4. **Revert Button** - Inside field, right side

---

## Correction History

Track all corrections for audit purposes:

```typescript
interface FieldCorrection {
  fieldName: string;
  originalValue: string;
  correctedValue: string;
  correctedAt: Date;
  reason?: string;
}

interface CorrectionHistory {
  corrections: FieldCorrection[];
  totalCorrections: number;
  fieldsWithCorrections: string[];
}
```

### Adding to History

```typescript
function addToHistory(
  history: CorrectionHistory,
  correction: FieldCorrection
): CorrectionHistory {
  return {
    corrections: [...history.corrections, correction],
    totalCorrections: history.corrections.length + 1,
    fieldsWithCorrections: [
      ...new Set([...history.fieldsWithCorrections, correction.fieldName])
    ],
  };
}
```

---

## Review Detection

Help users know which fields still need attention:

```typescript
function fieldNeedsReview(
  confidence: number,
  hasBeenCorrected: boolean,
  threshold: number = 0.90
): boolean {
  // Low confidence + not yet corrected = needs review
  return confidence < threshold && !hasBeenCorrected;
}

function getFieldsNeedingReview(
  fields: Record<string, CorrectionState>
): string[] {
  return Object.entries(fields)
    .filter(([_, state]) =>
      fieldNeedsReview(state.originalConfidence, state.hasBeenCorrected)
    )
    .map(([name, _]) => name);
}
```

---

## React Hooks

### Single Field Correction

```typescript
function useFieldCorrection(originalValue: string, initialValue: string, confidence: number) {
  const [state, setState] = useState(() =>
    createCorrectionState(originalValue, initialValue, confidence)
  );

  const setValue = useCallback((value: string, reason?: string) => {
    setState(prev => applyCorrection(prev, value, reason));
  }, []);

  const revert = useCallback(() => {
    setState(prev => revertToOriginal(prev));
  }, []);

  return { state, setValue, revert };
}
```

### Multiple Fields

```typescript
function useMultiFieldCorrection(initialFields: Record<string, FieldData>) {
  const [fields, setFields] = useState(() => {
    const result: Record<string, CorrectionState> = {};
    for (const [name, data] of Object.entries(initialFields)) {
      result[name] = createCorrectionState(data.value, data.value, data.confidence);
    }
    return result;
  });

  const updateField = useCallback((name: string, value: string, reason?: string) => {
    setFields(prev => ({
      ...prev,
      [name]: applyCorrection(prev[name], value, reason),
    }));
  }, []);

  const revertField = useCallback((name: string) => {
    setFields(prev => ({
      ...prev,
      [name]: revertToOriginal(prev[name]),
    }));
  }, []);

  return { fields, updateField, revertField };
}
```

---

## Best Practices

### 1. Always Track Original

Never lose the original extracted value. Users may need to reference it.

### 2. Visual Feedback

Make it obvious when a field has been corrected:
- Badge on the label
- Different border color
- Show original value below

### 3. Easy Revert

One-click revert should be available for all corrected fields.

### 4. Correction Reasons

Allow optional reasons for corrections (for audit trail).

### 5. Confidence Adjustment

Manually corrected fields should always show 100% confidence.

---

## Testing Approach

### Unit Tests

1. **State Creation** - Initial state is correct
2. **Correction Detection** - Correctly identifies changes
3. **State Updates** - Applying corrections works
4. **Revert** - Returns to original state
5. **Confidence** - Updates correctly

### Integration Tests

1. **Form Integration** - Fields show correction indicators
2. **User Flow** - Edit → Save → Revert works
3. **Visual States** - Correct colors/badges shown

---

## Common Pitfalls

1. **Losing Original** - Not storing originalValue
2. **No Visual Feedback** - User doesn't know what was changed
3. **Can't Revert** - No way to undo mistakes
4. **No History** - Can't audit changes
5. **Complex State** - Over-engineering the solution

---

## Summary

A good manual correction interface:

1. **Tracks** both original and current values
2. **Visualizes** correction status clearly
3. **Allows** easy revert to original
4. **Records** history for audit
5. **Integrates** smoothly with existing forms

This creates a trustworthy system where users can confidently review and correct AI-extracted data.
