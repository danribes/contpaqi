# T009.3 Process PDF Endpoint - Learning Guide

## Overview
This guide explains implementing file upload endpoints in FastAPI with PDF processing.

## FastAPI File Upload

### Basic File Upload
```python
from fastapi import UploadFile, File

@app.post("/upload")
async def upload(file: UploadFile = File(...)):
    contents = await file.read()
    return {"filename": file.filename, "size": len(contents)}
```

### UploadFile Properties
- `file.filename` - Original filename
- `file.content_type` - MIME type
- `file.file` - File-like object
- `await file.read()` - Read all bytes

## PDF to Image Conversion

### Using pdf2image
```python
from pdf2image import convert_from_bytes

# Convert PDF bytes to PIL Images
images = convert_from_bytes(pdf_bytes, dpi=300)

# Process first page
first_page = images[0]
```

### Handling Optional Dependencies
```python
try:
    from pdf2image import convert_from_bytes
    PDF2IMAGE_AVAILABLE = True
except ImportError:
    PDF2IMAGE_AVAILABLE = False

# In endpoint
if not PDF2IMAGE_AVAILABLE:
    raise HTTPException(status_code=503, detail="PDF processing not available")
```

## File Validation

### Content Type Validation
```python
@app.post("/process_pdf")
async def process_pdf(file: UploadFile = File(...)):
    # Check extension
    if not file.filename.lower().endswith('.pdf'):
        # Fall back to content type
        if file.content_type != "application/pdf":
            raise HTTPException(status_code=400, detail="File must be PDF")
```

### Empty File Check
```python
contents = await file.read()
if not contents:
    raise HTTPException(status_code=400, detail="Empty file")
```

## Response Models

### Using Pydantic Response Model
```python
from pydantic import BaseModel

class InvoiceResponse(BaseModel):
    success: bool
    invoice: Optional[Invoice] = None
    confidence: float

@app.post("/process_pdf", response_model=InvoiceResponse)
async def process_pdf(...):
    return InvoiceResponse(...)
```

## Error Handling Pattern

### Graceful Exception Handling
```python
@app.post("/process")
async def process(file: UploadFile = File(...)):
    try:
        # Processing logic
        result = engine.predict(image)
        return InvoiceResponse(success=True, ...)
    except HTTPException:
        raise  # Re-raise HTTP exceptions as-is
    except Exception as e:
        logger.error(f"Processing failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

## Testing File Uploads

### Using TestClient
```python
from fastapi.testclient import TestClient

def test_upload():
    client = TestClient(app)
    response = client.post(
        "/process_pdf",
        files={"file": ("test.pdf", b"content", "application/pdf")}
    )
    assert response.status_code == 200
```

### Mocking Engine
```python
from unittest.mock import Mock, patch

def test_with_mock_engine():
    mock_engine = Mock()
    mock_engine.predict.return_value = MockResult()

    with patch('main.engine', mock_engine):
        response = client.post(...)
```

## Key Takeaways

1. **Use UploadFile**: Async file handling with metadata
2. **Validate Early**: Check file type before processing
3. **Handle Dependencies**: Graceful fallback for optional libraries
4. **Response Models**: Type-safe responses with Pydantic
5. **Error Handling**: Separate HTTP from processing errors
