# T014.3 - InvoiceForm Component Learning Guide

**Subtask**: 14.3 - Create InvoiceForm component with auto-population
**Date**: 2025-12-08
**Type**: React Component Development

---

## Overview

This guide covers the creation of a form component that displays ML-extracted invoice data with confidence-based visual feedback and validation for Mexican invoices.

---

## Key Concepts

### 1. Confidence-Based UI Design

When displaying ML/OCR extraction results, visual feedback helps users identify uncertain fields:

```
High Confidence (>=90%)   → Green border  → Auto-accept
Medium Confidence (70-89%) → Orange border → Review recommended
Low Confidence (<70%)     → Red border   → Attention required
```

**Implementation Pattern**:
```typescript
function getConfidenceLevel(confidence: number): 'high' | 'medium' | 'low' {
  if (confidence >= 0.90) return 'high';
  if (confidence >= 0.70) return 'medium';
  return 'low';
}

// Use with Tailwind classes
const borderClass = {
  high: 'border-green-500 bg-green-50',
  medium: 'border-orange-500 bg-orange-50',
  low: 'border-red-500 bg-red-50',
}[getConfidenceLevel(field.confidence)];
```

### 2. Mexican Invoice Structure

Mexican invoices (CFDI) have specific required fields:

| Field | Description | Format |
|-------|-------------|--------|
| RFC Emisor | Issuer tax ID | 12-13 alphanumeric |
| RFC Receptor | Receiver tax ID | 12-13 alphanumeric |
| Fecha | Invoice date | YYYY-MM-DD |
| Subtotal | Pre-tax amount | Currency |
| IVA | Tax (16%) | Currency |
| Total | Final amount | Currency |

**RFC Validation Pattern**:
```typescript
const RFC_PATTERN = /^[A-Z&Ñ]{3,4}\d{6}[A-Z0-9]{3}$/;

// Persona Moral (company): 12 characters - 3 letters + 6 digits + 3 chars
// Persona Fisica (individual): 13 characters - 4 letters + 6 digits + 3 chars
```

### 3. Form State Management Pattern

Track multiple state properties per field:

```typescript
interface FormFieldState {
  value: string;
  confidence?: number;  // From extraction
  touched: boolean;     // User interacted
  error?: string;       // Validation error
}

// Initial state from extraction
function createInitialField(extracted?: ExtractedField): FormFieldState {
  return {
    value: extracted?.value ?? '',
    confidence: extracted?.confidence,
    touched: false,
    error: undefined,
  };
}
```

### 4. Financial Validation

Mexican invoices require:
- IVA = 16% of subtotal
- Total = Subtotal + IVA

```typescript
function validateMath(
  subtotal: number,
  iva: number,
  total: number,
  tolerance: number = 0.01  // 1% for rounding
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  const expectedIva = subtotal * 0.16;
  const expectedTotal = subtotal + iva;

  if (Math.abs(iva - expectedIva) > tolerance * subtotal) {
    errors.push('IVA should be 16% of subtotal');
  }
  if (Math.abs(total - expectedTotal) > tolerance * total) {
    errors.push('Total should equal subtotal + IVA');
  }

  return { valid: errors.length === 0, errors };
}
```

---

## Design Decisions

### 1. Pure Function Approach for Validation

**Decision**: Export validation functions for testing.

**Rationale**:
- Easier to unit test without DOM
- Reusable across components
- Separation of concerns

```typescript
// Export for testing
export function validateRFC(rfc: string): boolean { ... }
export function validateMath(...): { valid, errors } { ... }
export function getConfidenceLevel(confidence: number): string { ... }
```

### 2. Field Configuration Array

**Decision**: Define fields as configuration objects.

**Rationale**:
- Easy to add/modify fields
- Consistent rendering
- Centralized validation rules

```typescript
interface FieldConfig {
  name: string;
  label: string;
  type: 'text' | 'date' | 'currency';
  required: boolean;
  pattern?: RegExp;
}

const INVOICE_FIELDS: FieldConfig[] = [
  { name: 'rfcEmisor', label: 'RFC Emisor', type: 'text', required: true, pattern: RFC_PATTERN },
  // ...
];

// Render dynamically
{INVOICE_FIELDS.map(field => <FormField key={field.name} {...field} />)}
```

### 3. Confidence Color Strategy

**Decision**: Use border + background color combination.

**Rationale**:
- Border provides clear boundary indicator
- Light background maintains readability
- Consistent with accessibility guidelines

```typescript
const colors = {
  high: 'border-green-500 bg-green-50',    // Subtle but visible
  medium: 'border-orange-500 bg-orange-50', // Draws attention
  low: 'border-red-500 bg-red-50',          // Requires action
};
```

### 4. Dirty Form Detection

**Decision**: Compare current values to original extracted values.

**Rationale**:
- Detect user modifications
- Warn before discarding changes
- Enable save/reset functionality

```typescript
function isFormDirty(
  formState: Record<string, FormFieldState>,
  originalData: InvoiceData
): boolean {
  return Object.keys(formState).some(key => {
    const current = formState[key].value;
    const original = originalData[key]?.value ?? '';
    return current !== original;
  });
}
```

---

## Testing Strategy

### 1. Test Pure Functions Separately

```typescript
describe('Confidence Level Handling', () => {
  it('should classify high confidence (>=0.90)', () => {
    expect(getConfidenceLevel(0.95)).toBe('high');
    expect(getConfidenceLevel(0.90)).toBe('high');
  });

  it('should classify medium confidence (0.70-0.89)', () => {
    expect(getConfidenceLevel(0.85)).toBe('medium');
    expect(getConfidenceLevel(0.70)).toBe('medium');
  });
});
```

### 2. Test Edge Cases

```typescript
describe('Form Validation', () => {
  it('should handle empty RFC gracefully', () => {
    expect(validateRFC('')).toBe(false);
  });

  it('should accept RFC with Ñ', () => {
    expect(validateRFC('XAÑX010101ABC')).toBe(true);
  });
});
```

### 3. Test Mathematical Tolerance

```typescript
describe('Math Validation', () => {
  it('should allow small rounding differences', () => {
    // 10000 * 0.16 = 1600, but allow 1599.99
    const result = validateMath(10000, 1599.99, 11599.99);
    expect(result.valid).toBe(true);
  });
});
```

---

## Common Patterns

### 1. Conditional Styling Based on State

```tsx
<input
  className={`
    border-2 rounded px-3 py-2
    ${field.error ? 'border-red-500' : ''}
    ${field.confidence && getConfidenceColor(getConfidenceLevel(field.confidence))}
    ${field.touched && field.error ? 'ring-2 ring-red-300' : ''}
  `}
  value={field.value}
  onChange={(e) => handleChange(fieldName, e.target.value)}
  onBlur={() => handleBlur(fieldName)}
/>
```

### 2. Form Field with Label and Error

```tsx
function FormField({ config, state, onChange, onBlur }) {
  return (
    <div className="mb-4">
      <label className="block text-sm font-medium text-gray-700 mb-1">
        {config.label}
        {config.required && <span className="text-red-500">*</span>}
      </label>
      <input
        type={config.type}
        value={state.value}
        onChange={(e) => onChange(e.target.value)}
        onBlur={onBlur}
        className={getInputClasses(state)}
      />
      {state.touched && state.error && (
        <p className="text-red-500 text-sm mt-1">{state.error}</p>
      )}
      {state.confidence && (
        <span className="text-xs text-gray-500">
          Confidence: {(state.confidence * 100).toFixed(0)}%
        </span>
      )}
    </div>
  );
}
```

### 3. Line Items Table with Validation

```tsx
<table className="w-full">
  <thead>
    <tr>
      <th>Description</th>
      <th>Qty</th>
      <th>Unit Price</th>
      <th>Amount</th>
    </tr>
  </thead>
  <tbody>
    {lineItems.map((item) => {
      const calculated = item.quantity * item.unitPrice;
      const hasError = Math.abs(calculated - item.amount) > 0.01;
      return (
        <tr key={item.id} className={hasError ? 'bg-red-50' : ''}>
          <td>{item.description}</td>
          <td>{item.quantity}</td>
          <td>{formatCurrency(item.unitPrice)}</td>
          <td>
            {formatCurrency(item.amount)}
            {hasError && <span className="text-red-500 text-xs"> (mismatch)</span>}
          </td>
        </tr>
      );
    })}
  </tbody>
</table>
```

---

## Best Practices

1. **Always validate on blur, not just submit** - Immediate feedback
2. **Show confidence alongside extracted values** - User trust
3. **Allow tolerance in math validation** - Account for rounding
4. **Export validation functions** - Enable unit testing
5. **Use field configuration objects** - Maintainability
6. **Track touched state** - Show errors only after interaction
7. **Provide clear visual hierarchy** - High/medium/low confidence

---

## Related Resources

- Mexican CFDI specification
- RFC validation rules (SAT Mexico)
- React form state patterns
- Accessibility guidelines for form validation
