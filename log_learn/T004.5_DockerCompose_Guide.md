# T004.5 - Docker Compose for Local Development Guide

**Subtask**: 4.5 Create docker-compose.yml for local development
**Date**: 2025-12-05

---

## Learning Objectives

After completing this guide, you will understand:
1. What Docker Compose is and why it's useful
2. Docker Compose file structure and syntax
3. Service configuration options
4. Volume mounts for development
5. Environment variables and configuration
6. Resource limits and health checks
7. Best practices for development environments

---

## 1. What is Docker Compose?

### Definition

Docker Compose is a tool for defining and running multi-container Docker applications. It uses YAML files to configure application services.

### Why Use Docker Compose?

```
Without Compose:
docker run -d \
  -p 8000:8000 \
  -v ./src:/app/src:ro \
  -e LOG_LEVEL=DEBUG \
  --memory=4g \
  --name mcp-container \
  my-image

With Compose:
docker-compose up -d
```

**Benefits**:
- **Reproducibility**: Same command works everywhere
- **Documentation**: Configuration is self-documenting
- **Simplicity**: One file, one command
- **Multi-container**: Easily manage multiple services

---

## 2. Docker Compose File Structure

### Basic Structure

```yaml
version: '3.8'           # Compose file format version

services:                # Container definitions
  service-name:
    build: .             # Build configuration
    ports: []            # Port mappings
    volumes: []          # Volume mounts
    environment: []      # Environment variables
```

### Version Numbers

| Version | Features |
|---------|----------|
| 2.x | Legacy, volume/network syntax |
| 3.x | Swarm mode support |
| 3.8 | Latest v3 with all features |

**Note**: Version 3.8 is recommended for most projects.

---

## 3. Service Configuration

### Build Configuration

```yaml
services:
  app:
    # Simple build (current directory)
    build: .

    # Extended build configuration
    build:
      context: .           # Build context path
      dockerfile: Dockerfile  # Dockerfile name
      args:                # Build arguments
        - VERSION=1.0
```

### Image vs Build

```yaml
# Build from Dockerfile
services:
  app:
    build: .

# Pull existing image
services:
  db:
    image: postgres:15
```

---

## 4. Port Mappings

### Syntax

```yaml
ports:
  - "HOST:CONTAINER"
  - "8000:8000"      # Same port
  - "3000:8000"      # Different ports
  - "127.0.0.1:8000:8000"  # Bind to localhost only
```

### Security Consideration

```yaml
# Exposed to all interfaces (development)
ports:
  - "8000:8000"

# Localhost only (more secure)
ports:
  - "127.0.0.1:8000:8000"
```

---

## 5. Volume Mounts

### Types of Volumes

```yaml
volumes:
  # Bind mount (host path : container path)
  - ./src:/app/src

  # Named volume
  - data-volume:/app/data

  # Anonymous volume
  - /app/temp
```

### Read-Only Mounts

```yaml
volumes:
  - ./src:/app/src:ro      # Read-only
  - ./config:/app/config   # Read-write (default)
```

**Why Read-Only?**
1. Prevents container from modifying source code
2. Changes on host immediately visible in container
3. Safer for development

### Mount Options

```yaml
volumes:
  - type: bind
    source: ./src
    target: /app/src
    read_only: true
```

---

## 6. Environment Variables

### List Format

```yaml
environment:
  - LOG_LEVEL=DEBUG
  - PYTHONUNBUFFERED=1
```

### Dictionary Format

```yaml
environment:
  LOG_LEVEL: DEBUG
  PYTHONUNBUFFERED: "1"
```

### Using .env File

```yaml
# docker-compose.yml
services:
  app:
    env_file:
      - .env
```

```bash
# .env
LOG_LEVEL=DEBUG
API_KEY=secret123
```

### Common Development Variables

| Variable | Value | Purpose |
|----------|-------|---------|
| `LOG_LEVEL` | DEBUG | Verbose logging |
| `PYTHONUNBUFFERED` | 1 | Immediate log output |
| `DEBUG` | true | Enable debug mode |
| `RELOAD` | true | Hot-reload enabled |

---

## 7. Restart Policies

### Available Policies

```yaml
restart: no              # Never restart
restart: always          # Always restart
restart: on-failure      # Restart on non-zero exit
restart: unless-stopped  # Restart unless manually stopped
```

### Development vs Production

| Environment | Policy | Reason |
|-------------|--------|--------|
| Development | `unless-stopped` | Respect manual stops |
| Production | `always` | Maximum availability |

---

## 8. Resource Limits

### Memory Limits

```yaml
services:
  app:
    deploy:
      resources:
        limits:
          memory: 4G      # Maximum memory
        reservations:
          memory: 2G      # Guaranteed minimum
```

### CPU Limits

```yaml
deploy:
  resources:
    limits:
      cpus: '2'         # Max 2 CPUs
    reservations:
      cpus: '0.5'       # Guaranteed 0.5 CPUs
```

### Why Set Limits?

1. **Prevent Runaway Usage**: Container can't consume all host memory
2. **Predictable Performance**: Known resource allocation
3. **AI/ML Workloads**: Models can be memory-intensive

---

## 9. Health Checks

### Basic Health Check

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
  interval: 30s
  timeout: 10s
  retries: 3
  start_period: 10s
```

### Health Check Parameters

| Parameter | Description | Example |
|-----------|-------------|---------|
| `test` | Command to run | `curl -f http://localhost/health` |
| `interval` | Time between checks | `30s` |
| `timeout` | Max time for check | `10s` |
| `retries` | Failures before unhealthy | `3` |
| `start_period` | Grace period at startup | `10s` |

### Test Command Formats

```yaml
# Shell form
test: curl -f http://localhost:8000/health || exit 1

# Exec form (recommended)
test: ["CMD", "curl", "-f", "http://localhost:8000/health"]

# CMD-SHELL form
test: ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"]
```

### Health Status

```bash
# Check container health
docker ps
# Shows: healthy, unhealthy, starting

# Inspect health details
docker inspect --format='{{.State.Health.Status}}' container_name
```

---

## 10. Development Best Practices

### Volume Mounts for Hot Reload

```yaml
volumes:
  - ./src:/app/src:ro    # Source code
  - ./config:/app/config:ro  # Configuration
```

**Enables**:
- Code changes reflect immediately
- No container rebuild needed
- Fast development cycle

### Debug Logging

```yaml
environment:
  - LOG_LEVEL=DEBUG
  - PYTHONUNBUFFERED=1
```

**Provides**:
- Verbose output for debugging
- Immediate log visibility
- Full stack traces

### Separate Development Config

```yaml
# docker-compose.yml (base)
version: '3.8'
services:
  app:
    build: .

# docker-compose.override.yml (development)
services:
  app:
    volumes:
      - ./src:/app/src:ro
    environment:
      - LOG_LEVEL=DEBUG
```

**Usage**:
```bash
# Automatically merges both files
docker-compose up -d
```

---

## 11. Common Commands

### Lifecycle Commands

```bash
# Start services
docker-compose up -d

# Stop services
docker-compose down

# Restart services
docker-compose restart

# Rebuild and start
docker-compose up -d --build
```

### Monitoring Commands

```bash
# View logs
docker-compose logs -f

# View logs for specific service
docker-compose logs -f app

# Check status
docker-compose ps

# Check resource usage
docker-compose top
```

### Execution Commands

```bash
# Execute command in running container
docker-compose exec app bash

# Run one-off command
docker-compose run --rm app python -m pytest
```

---

## 12. Complete Example

```yaml
version: '3.8'

services:
  mcp-container:
    # Build configuration
    build:
      context: .
      dockerfile: Dockerfile

    # Port mapping
    ports:
      - "8000:8000"

    # Volume mounts (development)
    volumes:
      - ./src:/app/src:ro       # Source code
      - ./models:/app/models:ro  # AI models

    # Environment variables
    environment:
      - LOG_LEVEL=DEBUG
      - PYTHONUNBUFFERED=1

    # Restart policy
    restart: unless-stopped

    # Resource limits
    deploy:
      resources:
        limits:
          memory: 4G
        reservations:
          memory: 2G

    # Health check
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
```

---

## 13. Troubleshooting

### Container Won't Start

```bash
# Check logs
docker-compose logs app

# Check container status
docker-compose ps -a
```

### Health Check Failing

```bash
# Inspect health check details
docker inspect app | grep -A 20 Health

# Test endpoint manually
docker-compose exec app curl http://localhost:8000/health
```

### Volume Mount Issues

```bash
# Verify mount
docker-compose exec app ls -la /app/src

# Check permissions
docker-compose exec app id
```

### Resource Limit Problems

```bash
# Check memory usage
docker stats

# View resource limits
docker inspect app | grep -A 10 Memory
```

---

## 14. Summary

### Key Takeaways

1. **Version 3.8**: Use for full feature support
2. **Build vs Image**: Build from Dockerfile or use existing image
3. **Ports**: Map host:container for access
4. **Volumes**: Mount directories with optional read-only flag
5. **Environment**: Configure application behavior
6. **Restart**: `unless-stopped` for development
7. **Resources**: Set limits to prevent runaway usage
8. **Health**: Configure checks for container monitoring

### Checklist for Development Setup

- [ ] Version specification
- [ ] Service definition with build
- [ ] Port mappings
- [ ] Volume mounts for source code
- [ ] Environment variables for debugging
- [ ] Restart policy
- [ ] Resource limits
- [ ] Health check configuration
- [ ] Comments for documentation

---

## Further Reading

1. [Docker Compose Documentation](https://docs.docker.com/compose/)
2. [Compose File Reference](https://docs.docker.com/compose/compose-file/)
3. [Deploy Resources](https://docs.docker.com/compose/compose-file/deploy/)
4. [Health Check Reference](https://docs.docker.com/compose/compose-file/#healthcheck)
