# Container Lifecycle Management - Learning Guide

## Overview
How to manage Docker container lifecycle (start/stop/restart) from an Electron application using docker-compose.

## Key Concepts

### 1. Docker Compose Commands

#### Start Container
```bash
# Start in detached mode
docker-compose up -d

# Start and rebuild images
docker-compose up -d --build

# Start and force recreate
docker-compose up -d --force-recreate
```

#### Stop Container
```bash
# Stop and remove containers
docker-compose down

# Also remove volumes
docker-compose down --volumes

# Remove orphan containers
docker-compose down --remove-orphans
```

#### Other Commands
```bash
# Pull latest images
docker-compose pull

# Build images
docker-compose build

# Build without cache
docker-compose build --no-cache
```

### 2. Docker Compose v1 vs v2

```bash
# v1 (standalone)
docker-compose up -d

# v2 (plugin)
docker compose up -d
```

Both produce the same result, but v2 is the modern approach.

### 3. Spawning docker-compose in Node.js

```typescript
import { spawn } from 'child_process';

async function runDockerCompose(
  args: string[],
  cwd: string
): Promise<{ success: boolean; error?: string }> {
  return new Promise((resolve) => {
    const process = spawn('docker-compose', args, {
      cwd,        // Working directory with docker-compose.yml
      shell: true // Needed for Windows compatibility
    });

    let stderr = '';

    process.stderr?.on('data', (data) => {
      stderr += data.toString();
    });

    process.on('close', (code) => {
      if (code === 0) {
        resolve({ success: true });
      } else {
        resolve({ success: false, error: stderr });
      }
    });

    process.on('error', (err) => {
      resolve({ success: false, error: err.message });
    });
  });
}
```

### 4. Result Interface

```typescript
interface ContainerLifecycleResult {
  success: boolean;
  message?: string; // Success message or output
  error?: string;   // Error message on failure
}
```

### 5. Options Pattern

```typescript
interface StartOptions {
  build?: boolean;        // --build flag
  forceRecreate?: boolean; // --force-recreate flag
  env?: Record<string, string>; // Environment variables
}

async function startContainer(options: StartOptions = {}) {
  const args = ['up', '-d'];

  if (options.build) args.push('--build');
  if (options.forceRecreate) args.push('--force-recreate');

  const env = options.env
    ? { ...process.env, ...options.env }
    : process.env;

  return spawn('docker-compose', args, { cwd, shell: true, env });
}
```

### 6. Restart Pattern

```typescript
async function restartContainer(): Promise<ContainerLifecycleResult> {
  // First stop
  const stopResult = await stopContainer();
  if (!stopResult.success) {
    return stopResult; // Propagate stop error
  }

  // Then start
  return startContainer();
}
```

### 7. Timeout Protection

```typescript
async function withTimeout<T>(
  operation: Promise<T>,
  ms: number
): Promise<T | { success: false; error: string }> {
  const timeoutPromise = new Promise<{ success: false; error: string }>(
    (resolve) => setTimeout(() => resolve({
      success: false,
      error: 'Operation timed out'
    }), ms)
  );

  return Promise.race([operation, timeoutPromise]);
}
```

## Common Patterns

### Environment Variables
```typescript
// Pass env vars to container
await startContainer({
  env: {
    NODE_ENV: 'production',
    API_KEY: 'secret'
  }
});
```

### Build on Start
```typescript
// Rebuild images when starting
await startContainer({ build: true });
```

### Clean Stop
```typescript
// Remove everything including volumes
await stopContainer({
  removeVolumes: true,
  removeOrphans: true
});
```

## Error Handling

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| spawn ENOENT | Docker not installed | Install Docker |
| Cannot connect to daemon | Docker not running | Start Docker Desktop |
| No such file: docker-compose.yml | Wrong working directory | Check composePath |
| Permission denied | Insufficient privileges | Run as admin/sudo |

### Error Propagation
```typescript
process.on('close', (code) => {
  if (code !== 0) {
    resolve({
      success: false,
      error: stderr.trim() || 'Command failed with exit code ' + code
    });
  }
});
```

## Electron Integration

### IPC Handler
```typescript
// Main process
ipcMain.handle('docker:start', async () => {
  return dockerManager.startContainer();
});

ipcMain.handle('docker:stop', async () => {
  return dockerManager.stopContainer();
});

ipcMain.handle('docker:restart', async () => {
  return dockerManager.restartContainer();
});
```

### Renderer Usage
```typescript
// React component
const handleStart = async () => {
  setLoading(true);
  const result = await window.electronAPI.dockerStart();
  if (!result.success) {
    setError(result.error);
  }
  setLoading(false);
};
```

## Best Practices

1. **Use --detach (-d)** - Don't block the main process
2. **Set working directory** - docker-compose needs to find the yml file
3. **Handle timeouts** - Docker operations can take time
4. **Capture stderr** - Docker often sends output to stderr
5. **Use shell: true** - Required for Windows PATH resolution
6. **Propagate errors** - Return meaningful error messages
7. **Support both v1/v2** - Some systems have only one version

## Key Takeaways

1. docker-compose is the standard for container orchestration
2. Always specify the working directory with docker-compose.yml
3. Use options interfaces for flexible command building
4. Restart = stop + start (not a single command)
5. Handle timeouts for long-running operations
6. Support both docker-compose v1 and docker compose v2
