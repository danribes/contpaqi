# T014.8 - Submission Confirmation Flow Guide

**Learning Topic**: Implementing submission confirmation dialogs with state machines
**Subtask**: 14.8 - Implement submission confirmation flow
**Date**: 2025-12-09

---

## What We Built

A submission confirmation flow that:
1. Shows a modal before submitting the invoice
2. Displays a summary of all invoice data
3. Highlights any corrections the user made
4. Shows loading, success, and error states
5. Auto-closes after successful submission

---

## Why a Confirmation Flow?

### User Experience Benefits

1. **Prevents Accidental Submissions**: Users can review before committing
2. **Shows Summary**: Condenses form data into readable format
3. **Highlights Changes**: Makes corrections visible for verification
4. **Clear Feedback**: Loading spinner, success checkmark, error messages
5. **Graceful Recovery**: Retry option on failure

### Business Benefits

1. **Reduces Errors**: Users catch mistakes before submission
2. **Audit Trail**: Corrections are visible
3. **Support Reduction**: Clear error messages help users self-serve

---

## Key Concepts Explained

### State Machine Pattern

A state machine is a design pattern where:
- The system can only be in one state at a time
- Transitions between states follow defined rules
- Invalid transitions are prevented

Our states:
```
idle → confirming → submitting → success
                  ↘            ↘
                   error ←←←←←←←
```

Why use a state machine?
- **Predictable behavior**: No impossible states
- **Easy to test**: Each transition is testable
- **Clear UI logic**: Each state has specific UI

### React Hooks for State Management

We created two hooks:

**useSubmissionState** - Low-level state management:
```typescript
const {
  state,           // Current state
  showConfirmation,// Transition to confirming
  cancel,          // Back to idle
  submit,          // Start submission
  success,         // Mark success
  error,           // Mark error
  reset,           // Back to idle
} = useSubmissionState();
```

**useSubmissionFlow** - High-level flow management:
```typescript
const {
  state,
  showConfirmation,
  cancelConfirmation,
  confirmAndSubmit, // Combines submit + API call + success/error
  closeModal,
} = useSubmissionFlow(async () => {
  await api.submit(data);
});
```

The separation allows:
- Fine-grained control when needed
- Simple API for common cases
- Easy testing of each layer

---

## Implementation Patterns

### 1. State Transition Functions

Each state transition is a pure function:

```typescript
// Pure function - same input always gives same output
export function startConfirmation(state: SubmissionState): SubmissionState {
  if (state.status !== 'idle') return state; // Guard clause
  return { status: 'confirming' };
}
```

Benefits:
- Easy to test (no side effects)
- Reusable across components
- Predictable behavior

### 2. Auto-Close with useEffect

The modal auto-closes after success:

```typescript
useEffect(() => {
  if (state.status === 'success') {
    const timer = setTimeout(() => {
      onClose();
    }, AUTO_CLOSE_DELAY);
    return () => clearTimeout(timer);
  }
}, [state.status, onClose]);
```

Key patterns:
- **Cleanup function**: Prevents memory leaks if unmounted
- **Dependency array**: Only runs when status changes
- **Constant for delay**: Easy to adjust (3 seconds)

### 3. Corrections Detection

Detecting what changed is simple comparison:

```typescript
const correctedFields: string[] = [];

if (formData.rfcEmisor.value !== formData.rfcEmisor.originalValue) {
  correctedFields.push('rfcEmisor');
}
// ... repeat for each field
```

This approach:
- No complex diff algorithms needed
- Works with the existing form state
- Clear and maintainable

### 4. Mexican Locale Formatting

For currency:
```typescript
export function formatCurrency(amount: number): string {
  return `$${amount.toLocaleString('es-MX', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  })}`;
}
// Result: $1,234.56
```

For dates:
```typescript
export function formatDate(dateStr: string): string {
  const date = new Date(dateStr);
  return date.toLocaleDateString('es-MX', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  });
}
// Result: "9 de diciembre de 2025"
```

Using `toLocaleString` with 'es-MX' ensures:
- Correct decimal separators
- Correct date format
- Proper month names in Spanish

---

## Component Architecture

### Modal Composition

The modal is composed of smaller pieces:

```
ConfirmationModal
├── Header (title based on state)
├── Content
│   ├── confirming: InvoiceSummaryDisplay + CorrectionsSummary
│   ├── submitting: LoadingSpinner
│   ├── success: SuccessDisplay
│   └── error: ErrorDisplay
└── Footer (buttons, only in confirming state)
```

Benefits:
- Each piece is independently testable
- Easy to modify individual states
- Reusable components

### Conditional Rendering Pattern

```tsx
{state.status === 'confirming' && (
  <>
    <InvoiceSummaryDisplay summary={summary} />
    <CorrectionsSummary correctedFields={summary.correctedFields} />
  </>
)}

{state.status === 'submitting' && <LoadingSpinner />}

{state.status === 'success' && <SuccessDisplay onClose={onClose} />}

{state.status === 'error' && (
  <ErrorDisplay error={state.error} onRetry={onRetry} onCancel={onCancel} />
)}
```

Only one branch renders at a time, keeping the DOM clean.

---

## Integration with InvoiceForm

### Before Integration

```typescript
const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault();
  if (!validateForm()) return;

  // Direct submission
  onSubmit?.(data);
};
```

### After Integration

```typescript
const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault();
  if (!validateForm()) return;

  // Show confirmation modal
  showConfirmation();
};

// Modal handles the actual submission
<ConfirmationModal
  isOpen={submissionState.status !== 'idle'}
  onConfirm={confirmAndSubmit}
  // ...
/>
```

The form's responsibility is reduced:
- Form validates data
- Modal handles confirmation flow
- Hook handles submission state

---

## UI/UX Patterns

### Visual Feedback Hierarchy

1. **Confirming State**: Neutral white modal
2. **Submitting State**: Animated spinner
3. **Success State**: Green checkmark, auto-close message
4. **Error State**: Red X, clear error message, retry option

### Corrections Highlighting

Corrected fields are highlighted in two ways:
1. **In data rows**: Blue text + "Corrected" badge
2. **In summary box**: Blue info box listing all corrections

This double-indication ensures users notice changes.

### Button States

| State | Submit Button | Cancel Button |
|-------|---------------|---------------|
| confirming | "Confirm & Submit" | Visible |
| submitting | Disabled, "Submitting..." | Hidden |
| success | Disabled, "Submitted" | Hidden |
| error | Hidden (use Retry) | Visible |

---

## Testing Approach

### Unit Tests for State Logic

```typescript
it('should transition from idle to confirming', () => {
  const state = createInitialState();
  const next = startConfirmation(state);
  expect(next.status).toBe('confirming');
});
```

### Unit Tests for Formatting

```typescript
it('should format currency with Mexican locale', () => {
  const result = formatCurrency(1234.56);
  expect(result).toBe('$1,234.56');
});
```

### Guard Tests

```typescript
it('should not transition from non-idle to confirming', () => {
  const state: SubmissionState = { status: 'submitting' };
  const next = startConfirmation(state);
  expect(next.status).toBe('submitting'); // Unchanged
});
```

Testing guards ensures invalid transitions are blocked.

---

## Common Patterns Reference

### Creating a Modal with State Machine

1. Define states as string literals
2. Create transition functions
3. Create hook that wraps useState
4. Render different content per state
5. Handle cleanup (timers, etc.)

### Async Submission Flow

1. User action triggers showConfirmation
2. User confirms → startSubmission
3. Await async operation
4. On success → submitSuccess
5. On error → submitError with message
6. Handle retry/cancel

### Auto-Close Pattern

```typescript
useEffect(() => {
  if (shouldAutoClose) {
    const timer = setTimeout(onClose, DELAY);
    return () => clearTimeout(timer);
  }
}, [shouldAutoClose, onClose]);
```

---

## Files Created

| File | Purpose | Lines |
|------|---------|-------|
| SubmissionConfirmation.tsx | Components, hooks, utilities | ~850 |
| submission-confirmation.test.ts | 47 unit tests | ~700 |

---

## Key Takeaways

1. **State machines** prevent impossible UI states
2. **Pure functions** for state transitions are easy to test
3. **Composition** makes complex modals maintainable
4. **Localization** should be considered from the start
5. **Auto-close** needs cleanup to prevent memory leaks
6. **Visual hierarchy** guides users through the flow
7. **TDD** ensures all edge cases are covered

---

## Further Reading

- React useEffect cleanup patterns
- State machine libraries (XState)
- Modal accessibility (ARIA)
- toLocaleString API for internationalization
