# T009.2 Pydantic Schemas - Learning Guide

## Overview
This guide explains how to define Pydantic models for API data validation.

## What is Pydantic?

Pydantic is a data validation library that uses Python type hints to validate and serialize data.

```python
from pydantic import BaseModel

class User(BaseModel):
    name: str
    age: int
```

## Key Features

### 1. Type Validation
```python
class LineItem(BaseModel):
    description: str     # Must be string
    quantity: float      # Must be numeric
    confidence: float    # Must be numeric
```

### 2. Field Constraints
```python
from pydantic import Field

class LineItem(BaseModel):
    quantity: float = Field(ge=0)           # >= 0
    confidence: float = Field(ge=0, le=1)   # 0.0 to 1.0
```

### 3. Optional Fields
```python
from typing import Optional

class Invoice(BaseModel):
    folio: Optional[str] = None  # Can be None
```

### 4. Default Values
```python
class ValidationResult(BaseModel):
    is_valid: bool
    errors: List[str] = []      # Default empty list
    warnings: List[str] = []    # Default empty list
```

### 5. Nested Models
```python
class Invoice(BaseModel):
    line_items: List[LineItem] = []  # List of LineItem models
```

## Common Patterns

### Response Models
```python
class InvoiceResponse(BaseModel):
    success: bool
    invoice: Optional[Invoice] = None
    validation: ValidationResult
    confidence: float
```

### Error Models
```python
class ErrorResponse(BaseModel):
    success: bool = False  # Always False
    error: str
```

## Validation Examples

### Valid Data
```python
item = LineItem(
    description="Product A",
    quantity=2.0,
    unit_price=100.0,
    amount=200.0,
    confidence=0.95
)
# Works fine
```

### Invalid Data
```python
# Missing required field
LineItem(quantity=1.0, ...)  # ValidationError

# Value out of range
LineItem(confidence=1.5, ...)  # ValidationError (> 1.0)

# Negative amount
Invoice(subtotal=-100.0, ...)  # ValidationError (< 0)
```

## Serialization

### To Dictionary
```python
invoice = Invoice(...)
data = invoice.model_dump()
# {'rfc_emisor': 'XAXX...', 'total': 1160.0, ...}
```

### To JSON
```python
json_str = invoice.model_dump_json()
# '{"rfc_emisor": "XAXX...", "total": 1160.0, ...}'
```

### From Dictionary
```python
data = {"description": "Test", "quantity": 1.0, ...}
item = LineItem.model_validate(data)
```

## FastAPI Integration

FastAPI automatically uses Pydantic models:

```python
@app.post("/process")
async def process(file: UploadFile) -> InvoiceResponse:
    # Return type is validated by Pydantic
    return InvoiceResponse(
        success=True,
        invoice=invoice,
        validation=ValidationResult(is_valid=True),
        confidence=0.9
    )
```

## Best Practices

1. **Use Field Constraints**: Validate ranges with `Field(ge=0, le=100)`
2. **Optional with Default**: `Optional[str] = None` for nullable fields
3. **Nested Models**: Compose complex structures from simple models
4. **Meaningful Names**: Match API documentation terminology
5. **Docstrings**: Document each model and field

## Key Takeaways

1. **Type Safety**: Pydantic validates all incoming data
2. **Field Constraints**: Enforce business rules (non-negative, ranges)
3. **Serialization**: Easy conversion to/from JSON
4. **FastAPI Integration**: Automatic validation in endpoints
5. **Error Messages**: Clear validation error messages
