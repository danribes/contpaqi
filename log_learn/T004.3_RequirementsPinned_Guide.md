# T004.3 - Python Requirements and Version Pinning Guide

**Subtask**: 4.3 Create requirements.txt with pinned versions
**Date**: 2025-12-04

---

## Learning Objectives

After completing this guide, you will understand:
1. Why version pinning matters for production applications
2. Different version specifier formats and when to use them
3. How to organize requirements.txt for maintainability
4. Best practices for Docker and Python dependency management

---

## 1. Understanding requirements.txt

### What is requirements.txt?

A `requirements.txt` file lists all Python packages your project depends on. It's the standard way to define dependencies in Python projects.

### Basic Format

```
# Simple format
package_name==version

# With extras
package_name[extra]==version

# Comment
# This is a comment
```

### Example

```
fastapi==0.104.1
uvicorn[standard]==0.24.0
```

---

## 2. Version Specifiers

### Types of Version Specifiers

| Specifier | Example | Meaning |
|-----------|---------|---------|
| `==` | `fastapi==0.104.1` | Exact version (recommended) |
| `>=` | `fastapi>=0.100.0` | Minimum version |
| `<=` | `fastapi<=0.105.0` | Maximum version |
| `~=` | `fastapi~=0.104.0` | Compatible release |
| `!=` | `fastapi!=0.103.0` | Exclude version |
| `*` | `fastapi` | Any version (avoid!) |

### Why Use Exact Pinning (==)?

```
# Good: Reproducible
fastapi==0.104.1

# Bad: Unpredictable
fastapi>=0.100.0
```

**Problems with range specifiers:**
1. Different versions on different machines
2. Updates can break your application
3. Hard to debug version-specific issues
4. CI/CD builds may differ from local

---

## 3. Semantic Versioning

### Understanding Version Numbers

```
MAJOR.MINOR.PATCH
  │     │     │
  │     │     └── Bug fixes (backwards compatible)
  │     └──────── New features (backwards compatible)
  └────────────── Breaking changes
```

### Example: FastAPI Versions

```
0.104.1
│  │  │
│  │  └── Patch: Bug fix
│  └───── Minor: New feature
└──────── Major: Still pre-1.0 (can have breaking changes)
```

### Pre-1.0 Software

Packages with version `0.x.y` may have breaking changes in minor versions because they haven't reached stable 1.0 yet. This is common in fast-moving ecosystems.

---

## 4. Package Categories in requirements.txt

### Organizing Your Dependencies

```
# Web framework
fastapi==0.104.1
uvicorn[standard]==0.24.0
python-multipart==0.0.6

# AI/ML
torch==2.1.0
transformers==4.35.0

# OCR
pytesseract==0.3.10
pdf2image==1.16.3
Pillow==10.1.0

# Validation
pydantic==2.5.0

# Utilities
python-dotenv==1.0.0
```

### Benefits of Organization

1. **Readability**: Easy to find packages
2. **Maintenance**: Update related packages together
3. **Review**: Clear what each section does
4. **Debugging**: Isolate problem areas

---

## 5. Package Dependencies Deep Dive

### Web Framework Stack

```
FastAPI
├── starlette (ASGI framework)
├── pydantic (data validation)
└── python-multipart (file uploads)

Uvicorn
├── uvloop (faster event loop)
├── httptools (HTTP parsing)
└── websockets (WebSocket support)
```

### AI/ML Stack

```
PyTorch
├── torch (core library)
├── torchvision (optional, for vision)
└── torchaudio (optional, for audio)

Transformers
├── tokenizers (fast tokenization)
├── safetensors (safe model loading)
└── huggingface-hub (model downloads)
```

### OCR Stack

```
pytesseract
└── PIL/Pillow (image handling)

pdf2image
├── Pillow (image output)
└── poppler (system dependency)
```

---

## 6. Version Compatibility

### Checking Compatibility

When combining packages, check their compatibility:

| Package A | Package B | Compatible? |
|-----------|-----------|-------------|
| Pydantic 2.x | FastAPI < 0.100 | No |
| Pydantic 2.x | FastAPI >= 0.100 | Yes |
| PyTorch 2.x | Transformers >= 4.30 | Yes |
| PyTorch 1.x | Transformers >= 4.0 | Yes |

### Breaking Changes to Watch

**Pydantic 1.x → 2.x**:
- Complete rewrite with Rust core
- API changes in validators
- FastAPI needed updates

**PyTorch 1.x → 2.x**:
- New compilation features
- Some API deprecations
- Generally backwards compatible

---

## 7. Extras in Requirements

### What are Extras?

Extras are optional dependencies that provide additional functionality:

```
# Base uvicorn
uvicorn==0.24.0

# With all extras (recommended)
uvicorn[standard]==0.24.0
```

### Uvicorn Extras Explained

```
uvicorn[standard] includes:
├── uvloop      → Faster event loop (Linux/Mac)
├── httptools   → Faster HTTP parsing
├── watchfiles  → File watching for reload
└── websockets  → WebSocket support
```

### Common Extras

| Package | Extra | Provides |
|---------|-------|----------|
| uvicorn | standard | Performance optimizations |
| fastapi | all | All optional features |
| torch | cpu | CPU-only (smaller) |
| torch | cu118 | CUDA 11.8 support |

---

## 8. Docker and Requirements

### Multi-Stage Build Pattern

```dockerfile
# Stage 1: Build wheels
FROM python:3.9-slim AS builder
COPY requirements.txt .
RUN pip wheel --wheel-dir=/wheels -r requirements.txt

# Stage 2: Runtime
FROM python:3.9-slim
COPY --from=builder /wheels /wheels
RUN pip install --no-cache /wheels/*
```

### Benefits of Wheels

1. **Faster installs**: Pre-compiled binaries
2. **Smaller images**: No build tools needed in runtime
3. **Reproducible**: Same binaries every time
4. **Cacheable**: Docker layer caching works better

### pip Cache in Docker

```dockerfile
# Bad: Leaves cache in image
RUN pip install -r requirements.txt

# Good: No cache
RUN pip install --no-cache-dir -r requirements.txt
```

---

## 9. Security Considerations

### Package Hash Verification

For high-security environments:

```
# requirements.txt with hashes
fastapi==0.104.1 \
    --hash=sha256:abc123...
```

Generate hashes:
```bash
pip hash downloaded-package.whl
```

### Vulnerability Scanning

Tools to check for vulnerable packages:
- `pip-audit`: Checks for known vulnerabilities
- `safety`: Scans requirements.txt
- `snyk`: Commercial security scanner

```bash
# Install and run pip-audit
pip install pip-audit
pip-audit -r requirements.txt
```

---

## 10. Updating Dependencies

### Safe Update Process

1. **Create branch**: `git checkout -b update-deps`
2. **Update one at a time**: Change one version
3. **Run tests**: Verify nothing breaks
4. **Check changelog**: Read release notes
5. **Commit**: Document what changed

### Tools for Updates

```bash
# pip-tools: Compile and sync dependencies
pip install pip-tools
pip-compile requirements.in  # Generate pinned requirements.txt
pip-sync requirements.txt    # Install exact versions

# pip-review: See available updates
pip install pip-review
pip-review --local
```

---

## 11. Common Pitfalls

### Pitfall 1: Unpinned Dependencies

```
# Bad
fastapi
torch

# Good
fastapi==0.104.1
torch==2.1.0
```

### Pitfall 2: Conflicting Versions

```
# May conflict!
tensorflow==2.14.0
torch==2.1.0
# Both want different numpy versions
```

**Solution**: Check compatibility or use separate environments.

### Pitfall 3: Missing Transitive Dependencies

```
# Direct dependency
fastapi==0.104.1

# Transitive (installed automatically)
starlette==0.27.0  # May vary!
```

**Solution**: Pin important transitive dependencies.

### Pitfall 4: Platform-Specific Packages

```
# This may not work on all platforms
pywin32==306  # Windows only
```

**Solution**: Use environment markers:
```
pywin32==306; sys_platform == 'win32'
```

---

## 12. Summary

### Best Practices Checklist

- [ ] Use exact version pinning (`==`)
- [ ] Organize packages by category
- [ ] Add comments explaining categories
- [ ] Include extras where needed (`[standard]`)
- [ ] Test after any version changes
- [ ] Check version compatibility
- [ ] Use `--no-cache-dir` in Docker
- [ ] Consider security scanning

### Quick Reference

```
# requirements.txt template
# Web framework
fastapi==0.104.1
uvicorn[standard]==0.24.0

# Database
sqlalchemy==2.0.23

# Utilities
python-dotenv==1.0.0

# Testing (usually in requirements-dev.txt)
pytest==7.4.3
```

---

## Further Reading

1. [PEP 440 - Version Identification](https://peps.python.org/pep-0440/)
2. [pip Documentation](https://pip.pypa.io/en/stable/)
3. [pip-tools](https://pip-tools.readthedocs.io/)
4. [Docker Python Best Practices](https://docs.docker.com/language/python/)
