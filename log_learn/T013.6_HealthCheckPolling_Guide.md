# Health Check Polling with Retry - Learning Guide

## Overview
How to implement robust health check polling with retry logic, exponential backoff, and status change notifications in an Electron application.

## Key Concepts

### 1. Health Check Result Structure

```typescript
interface HealthCheckResult {
  healthy: boolean;      // Whether the service is healthy
  status?: string;       // Status from the service (e.g., "healthy", "unhealthy")
  error?: string;        // Error message if check failed
  retryCount?: number;   // Number of retries attempted
  timestamp: Date;       // When the check was performed
}
```

### 2. Single Health Check with Timeout

```typescript
async checkHealth(): Promise<HealthCheckResult> {
  const timestamp = new Date();

  try {
    // Create abort controller for timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeoutMs);

    const response = await fetch(this.healthUrl, {
      method: 'GET',
      headers: { Accept: 'application/json' },
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      return { healthy: false, error: `HTTP ${response.status}`, timestamp };
    }

    const data = await response.json();
    const isHealthy = data.status === 'healthy';

    return {
      healthy: isHealthy,
      status: data.status,
      timestamp,
    };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    const isTimeout = errorMessage.includes('abort');

    return {
      healthy: false,
      error: isTimeout ? 'Request timeout' : errorMessage,
      timestamp,
    };
  }
}
```

### 3. Retry Logic with Exponential Backoff

```typescript
interface RetryOptions {
  maxRetries?: number;        // Default: 3
  initialDelayMs?: number;    // Default: 1000
  maxDelayMs?: number;        // Default: 30000
  backoffMultiplier?: number; // Default: 2
  onRetry?: (attempt: number, error: string) => void;
}

async checkHealthWithRetry(options: RetryOptions = {}): Promise<HealthCheckResult> {
  const {
    maxRetries = 3,
    initialDelayMs = 1000,
    maxDelayMs = 30000,
    backoffMultiplier = 2,
    onRetry,
  } = options;

  let lastResult: HealthCheckResult;
  let currentDelay = initialDelayMs;

  // First attempt
  lastResult = await this.checkHealth();
  if (lastResult.healthy) {
    return { ...lastResult, retryCount: 0 };
  }

  // Retry loop
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    // Wait before retry
    await this.delay(currentDelay);

    // Call onRetry callback
    if (onRetry && lastResult.error) {
      onRetry(attempt, lastResult.error);
    }

    // Attempt health check
    lastResult = await this.checkHealth();
    if (lastResult.healthy) {
      return { ...lastResult, retryCount: attempt };
    }

    // Calculate next delay with exponential backoff
    currentDelay = Math.min(currentDelay * backoffMultiplier, maxDelayMs);
  }

  return { ...lastResult, retryCount: maxRetries };
}
```

### 4. Polling with Status Change Detection

```typescript
interface PollingOptions {
  intervalMs?: number;                                      // Default: 10000
  onStatusChange?: (status: HealthStatus, error?: string) => void;
  onError?: (error: string) => void;
}

startPolling(options: PollingOptions = {}): void {
  const { intervalMs = 10000, onStatusChange, onError } = options;

  // Stop existing polling
  this.stopPolling();
  this._isPolling = true;

  let lastStatus: HealthStatus | null = null;

  const doCheck = async () => {
    const result = await this.checkHealth();

    // Determine current status
    let newStatus: HealthStatus;
    let errorMessage: string | undefined;

    if (result.error) {
      newStatus = 'error';
      errorMessage = result.error;
      if (onError) onError(result.error);
    } else if (result.status) {
      newStatus = result.status === 'healthy' ? 'healthy' : 'unhealthy';
    } else {
      newStatus = 'error';
      errorMessage = 'Unknown response';
    }

    // Only call onStatusChange if status actually changed
    if (newStatus !== lastStatus && onStatusChange) {
      onStatusChange(newStatus, errorMessage);
    }

    lastStatus = newStatus;
  };

  // Initial check (immediate)
  doCheck();

  // Start interval
  this.pollingInterval = setInterval(doCheck, intervalMs);
}

stopPolling(): void {
  if (this.pollingInterval) {
    clearInterval(this.pollingInterval);
    this.pollingInterval = null;
  }
  this._isPolling = false;
}
```

### 5. Wait for Healthy State

```typescript
interface WaitForHealthyOptions {
  timeoutMs?: number;   // Default: 60000
  intervalMs?: number;  // Default: 2000
  onProgress?: (checkCount: number, isHealthy: boolean, error?: string) => void;
}

async waitForHealthy(options: WaitForHealthyOptions = {}): Promise<WaitForHealthyResult> {
  const { timeoutMs = 60000, intervalMs = 2000, onProgress } = options;

  const startTime = Date.now();
  let checkCount = 0;

  while (Date.now() - startTime < timeoutMs) {
    checkCount++;

    const result = await this.checkHealth();

    if (onProgress) {
      onProgress(checkCount, result.healthy, result.error);
    }

    if (result.healthy) {
      return { success: true, checkCount };
    }

    // Wait before next check
    if (Date.now() - startTime + intervalMs < timeoutMs) {
      await this.delay(intervalMs);
    }
  }

  return {
    success: false,
    checkCount,
    error: `Service did not become healthy within ${timeoutMs / 1000} seconds (timeout)`,
  };
}
```

## IPC Integration Pattern

### Main Process
```typescript
// Import
import { HealthCheckManager } from './health-check-manager';

// Create instance
const healthCheckManager = new HealthCheckManager('http://localhost:8000/health');

// Register IPC handlers
ipcMain.handle('health:check', async () => {
  return healthCheckManager.checkHealth();
});

ipcMain.handle('health:startPolling', async (_event, intervalMs) => {
  healthCheckManager.startPolling({
    intervalMs: intervalMs || 10000,
    onStatusChange: (status, error) => {
      // Push updates to renderer
      mainWindow?.webContents.send('health:statusChanged', { status, error });
    },
    onError: (error) => {
      mainWindow?.webContents.send('health:error', { error });
    },
  });
  return { success: true };
});

ipcMain.handle('health:stopPolling', async () => {
  healthCheckManager.stopPolling();
  return { success: true };
});
```

### Preload Script
```typescript
contextBridge.exposeInMainWorld('electronAPI', {
  // Invoke-based (request/response)
  healthCheck: () => ipcRenderer.invoke('health:check'),
  startHealthPolling: (intervalMs) => ipcRenderer.invoke('health:startPolling', intervalMs),
  stopHealthPolling: () => ipcRenderer.invoke('health:stopPolling'),

  // Event listeners (pushed from main)
  onHealthStatusChange: (callback) => {
    ipcRenderer.on('health:statusChanged', (_event, data) => callback(data));
  },
  onHealthError: (callback) => {
    ipcRenderer.on('health:error', (_event, data) => callback(data));
  },
  removeHealthListeners: () => {
    ipcRenderer.removeAllListeners('health:statusChanged');
    ipcRenderer.removeAllListeners('health:error');
  },
});
```

### React Component Usage
```tsx
function HealthStatusIndicator() {
  const [healthStatus, setHealthStatus] = useState<HealthStatus>('unknown');
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // Subscribe to status changes
    window.electronAPI.onHealthStatusChange((event) => {
      setHealthStatus(event.status);
      setError(event.error || null);
    });

    // Start polling
    window.electronAPI.startHealthPolling(10000);

    return () => {
      // Cleanup
      window.electronAPI.stopHealthPolling();
      window.electronAPI.removeHealthListeners();
    };
  }, []);

  return (
    <div className={`status-indicator ${healthStatus}`}>
      <span className={`dot ${healthStatus}`} />
      <span>{healthStatus}</span>
      {error && <span className="error">{error}</span>}
    </div>
  );
}
```

## Best Practices

### 1. Exponential Backoff
- Start with a reasonable initial delay (1-2 seconds)
- Use a multiplier of 2 for doubling
- Cap the maximum delay to prevent excessive waits
- Add jitter for distributed systems

### 2. Status Change Deduplication
- Only notify on actual status changes
- Prevent UI flickering from repeated identical states
- Track last known status for comparison

### 3. Timeout Handling
- Use AbortController for native timeout support
- Clean up timeouts on successful responses
- Distinguish between network errors and timeouts

### 4. Resource Cleanup
- Always clear intervals when stopping
- Provide cleanup methods for React components
- Remove event listeners to prevent memory leaks

### 5. Error Classification
- Distinguish between:
  - Network errors (connection refused)
  - HTTP errors (5xx status codes)
  - Application errors (unhealthy status)
  - Timeouts

## Common Patterns

### Startup Wait Pattern
```typescript
// Wait for service to be ready before showing UI
async function initializeApp() {
  const result = await healthCheckManager.waitForHealthy({
    timeoutMs: 30000,
    intervalMs: 1000,
    onProgress: (count, healthy, error) => {
      updateSplashScreen(`Connecting... (attempt ${count})`);
    }
  });

  if (!result.success) {
    showError('Service unavailable');
    return;
  }

  showMainUI();
}
```

### Graceful Degradation
```typescript
healthCheckManager.startPolling({
  intervalMs: 10000,
  onStatusChange: (status, error) => {
    switch (status) {
      case 'healthy':
        enableFeatures();
        break;
      case 'unhealthy':
        enableReadOnlyMode();
        break;
      case 'error':
        showOfflineBanner();
        break;
    }
  }
});
```

### Retry with Progress UI
```typescript
const result = await healthCheckManager.checkHealthWithRetry({
  maxRetries: 5,
  initialDelayMs: 1000,
  onRetry: (attempt, error) => {
    showToast(`Connection failed. Retrying... (${attempt}/5)`);
  }
});

if (!result.healthy) {
  showError(`Unable to connect after ${result.retryCount} retries`);
}
```

## Key Takeaways

1. Use AbortController for timeout handling with fetch
2. Implement exponential backoff to avoid overwhelming failing services
3. Deduplicate status change notifications to prevent UI flicker
4. Push updates from main process using IPC events
5. Clean up resources (intervals, listeners) on component unmount
6. Provide progress callbacks for long-running operations
7. Distinguish between different types of failures for appropriate handling
