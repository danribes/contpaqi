# T015.1 - Hardware Fingerprint Collection Learnings

**Subtask**: 15.1 - Implement hardware fingerprint collection (UUID)
**Date**: 2025-12-09

---

## Key Learnings

### 1. Windows UUID Collection Methods

**SMBIOS/DMI UUID via WMIC**:
```cmd
wmic csproduct get uuid
```
- Returns motherboard UUID from BIOS
- Most reliable hardware identifier
- Survives OS reinstalls
- Output needs parsing (header + value format)

**Machine GUID from Registry**:
```cmd
reg query HKLM\SOFTWARE\Microsoft\Cryptography /v MachineGuid
```
- Generated on Windows install
- Changes with OS reinstall
- Good secondary identifier
- Output format: `MachineGuid    REG_SZ    xxxxx`

### 2. Cross-Platform UUID Sources

| Platform | Primary Source | Fallback |
|----------|---------------|----------|
| Windows | `wmic csproduct` | Registry MachineGuid |
| Linux | `/sys/class/dmi/id/product_uuid` | `/etc/machine-id` |
| macOS | `ioreg IOPlatformUUID` | System serial |

**Important**: DMI/SMBIOS data requires root/admin on some systems.

### 3. UUID Format Handling

UUIDs can come in various formats:
```
A1B2C3D4-E5F6-7890-ABCD-EF1234567890  // Standard
a1b2c3d4-e5f6-7890-abcd-ef1234567890  // Lowercase
A1B2C3D4E5F67890ABCDEF1234567890      // No dashes
A1B2C3D4 E5F6 7890 ABCD EF1234567890  // Spaces
```

**Solution**: Normalize all UUIDs to uppercase with dashes:
```typescript
function normalizeUuid(uuid: string): string {
  const cleaned = uuid.trim().toUpperCase();
  const hex = cleaned.replace(/[^0-9A-F]/g, '');
  if (hex.length === 32) {
    return `${hex.slice(0,8)}-${hex.slice(8,12)}-...`;
  }
  return cleaned;
}
```

### 4. Fingerprint Component Selection

**What to include**:
- Machine ID (essential) - 40% weight
- System UUID (essential) - 30% weight
- CPU model (recommended) - 15% weight
- Platform (context) - 10% weight

**What to exclude by default**:
- Hostname (changes frequently)
- Memory size (can change with upgrades)
- IP address (too volatile)

**Configurable for specific needs**:
```typescript
const config: FingerprintConfig = {
  includeHostname: false,    // Volatile
  includeCpuInfo: true,      // Stable
  includeMemory: false,      // May change
  hashAlgorithm: 'sha256',   // Standard
};
```

### 5. Fingerprint Strength Scoring

Create a scoring system to assess fingerprint reliability:

```typescript
function getFingerprintStrength(identifiers): number {
  let score = 0;
  if (identifiers.machineId) score += 40;   // Most important
  if (identifiers.systemUuid) score += 30;  // Very reliable
  if (identifiers.cpuModel) score += 15;    // Adds uniqueness
  if (identifiers.cpuCores > 0) score += 5; // Minor factor
  if (identifiers.platform) score += 10;    // Context
  return Math.min(score, 100);
}
```

**Usage**: Warn if strength < 70, reject if < 50.

### 6. Async Command Execution Pattern

Using promisified exec for cleaner async code:

```typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

async function getWindowsUuid(): Promise<string | null> {
  try {
    const { stdout } = await execAsync('wmic csproduct get uuid', {
      timeout: 5000,  // Prevent hanging
    });
    return parseWmicUuidOutput(stdout);
  } catch {
    return null;  // Graceful fallback
  }
}
```

**Key points**:
- Always set timeout for system commands
- Return null on failure (don't throw)
- Parse output carefully (varies by locale/version)

### 7. Output Parsing Strategies

WMIC output format:
```
UUID
A1B2C3D4-E5F6-7890-ABCD-EF1234567890
```

Registry query output:
```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Cryptography
    MachineGuid    REG_SZ    xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
```

**Strategy**: Line-by-line parsing with validation:
```typescript
function parseWmicUuidOutput(output: string): string | null {
  const lines = output.split('\n')
    .map(l => l.trim())
    .filter(l => l.length > 0);

  for (const line of lines) {
    if (isValidUuid(line)) {
      return normalizeUuid(line);
    }
  }
  return null;
}
```

### 8. Caching for Performance

System commands are slow. Cache fingerprints:

```typescript
let cachedFingerprint: FingerprintResult | null = null;
let cacheTimestamp: number = 0;
const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour

async function getCachedFingerprint(forceRefresh = false) {
  const now = Date.now();

  if (!forceRefresh && cachedFingerprint && (now - cacheTimestamp) < CACHE_TTL_MS) {
    return cachedFingerprint;  // Return cached
  }

  cachedFingerprint = await generateSystemFingerprint();
  cacheTimestamp = now;
  return cachedFingerprint;
}
```

### 9. Security Considerations

**Masking for display**:
```typescript
function maskFingerprint(fp: string, visibleChars = 8): string {
  const start = fp.slice(0, visibleChars);
  const end = fp.slice(-visibleChars);
  return `${start}...${end}`;
}

// "a1b2c3d4...ef123456" instead of full hash
```

**Why mask?**
- Prevents shoulder surfing
- Sufficient for verification ("does it look right?")
- Full hash only transmitted, never displayed

### 10. Serialization for Persistence

Store fingerprints between sessions:

```typescript
// Serialize
function serializeFingerprint(result: FingerprintResult): string {
  return JSON.stringify({
    ...result,
    generatedAt: result.generatedAt.toISOString(),  // Date → string
  });
}

// Deserialize
function deserializeFingerprint(json: string): FingerprintResult | null {
  try {
    const data = JSON.parse(json);
    return {
      ...data,
      generatedAt: new Date(data.generatedAt),  // string → Date
    };
  } catch {
    return null;
  }
}
```

**Storage options**:
- Electron: `electron-store` or localStorage
- File: `~/.config/app/fingerprint.json`
- Registry: Windows-specific storage

---

## Best Practices Discovered

### 1. Graceful Degradation

Always have fallbacks:
```typescript
async function getMachineId(): Promise<string> {
  // Try Windows GUID
  const guid = await getWindowsMachineGuid();
  if (guid) return guid;

  // Fallback: generate from available info
  return hashString(`${os.hostname()}|${cpuModel}|${platform}`);
}
```

### 2. Minimum Requirements

Require at least one reliable identifier:
```typescript
function hasMinimumIdentifiers(identifiers): boolean {
  return !!(identifiers.machineId || identifiers.systemUuid);
}
```

### 3. Consistent Fingerprint Generation

Same input = same output:
```typescript
// Sort components, join with delimiter, hash
const components = [machineId, platform, uuid, cpu].sort();
return hash(components.join('|'));
```

### 4. Expiration Handling

Support time-based validation:
```typescript
function validateFingerprint(result, expected, maxAgeMs) {
  const age = Date.now() - result.generatedAt.getTime();
  if (maxAgeMs && age > maxAgeMs) {
    return { status: 'expired', isValid: false };
  }
  // ...
}
```

---

## Common Pitfalls

### 1. WMIC Deprecation

WMIC is deprecated in newer Windows versions. Future-proofing:
```powershell
# Alternative: PowerShell
Get-CimInstance -ClassName Win32_ComputerSystemProduct | Select-Object UUID
```

### 2. Locale-Dependent Output

Command output varies by system locale. Parse defensively:
```typescript
// Don't rely on exact format strings
// Do look for patterns (UUID regex, registry format)
```

### 3. Virtual Machine Detection

VMs may have:
- Generic UUIDs (00000000-0000-0000-0000-000000000000)
- Missing DMI data
- Cloned identifiers

**Solution**: Use multiple identifiers, check for suspicious patterns.

---

## Architecture Decisions

### Why Service Class?

Encapsulation benefits:
- Stateful caching
- Configuration management
- Easy mocking in tests
- Clean API surface

### Why Separate Functions?

Pure functions for:
- Testing in isolation
- Reuse across service methods
- Clear single responsibility

---

## Future Considerations

1. **MAC Address Fallback** (Subtask 15.2)
2. **PowerShell Commands** (WMIC alternative)
3. **VM Detection** (Warn about cloned fingerprints)
4. **Hardware Change Detection** (Track component changes)

