# Retry Logic and Graceful Shutdown - Learning Guide

## Overview
How to implement reliable job processing with retries and clean shutdown.

## Key Concepts

### 1. Exponential Backoff
Increase delay between retries:
```csharp
private const int MaxRetries = 3;
private const int BaseDelayMs = 1000;

for (int retry = 0; retry <= MaxRetries; retry++)
{
    try
    {
        await ProcessAsync();
        return;
    }
    catch (Exception ex)
    {
        if (retry == MaxRetries) throw;

        var delay = BaseDelayMs * (int)Math.Pow(2, retry);
        await Task.Delay(delay);
    }
}
```

**Delay Schedule:**
| Retry | Delay | Cumulative |
|-------|-------|------------|
| 0 | 0ms | 0ms |
| 1 | 1000ms | 1s |
| 2 | 2000ms | 3s |
| 3 | 4000ms | 7s |

### 2. Job State Tracking
```csharp
public class Job
{
    public JobStatus Status { get; set; } = JobStatus.Pending;
    public int RetryCount { get; set; }
    public string? ErrorMessage { get; set; }
    public DateTime? CompletedAt { get; set; }
}

public enum JobStatus
{
    Pending,
    Processing,
    Completed,
    Failed
}
```

### 3. Thread-Safe Storage
```csharp
private readonly ConcurrentDictionary<string, Job> _jobs = new();

// Add
_jobs[job.Id] = job;

// Get
if (_jobs.TryGetValue(id, out var job)) { ... }

// Update (atomic)
_jobs.AddOrUpdate(id, job, (k, v) => job);
```

### 4. Graceful Shutdown
```csharp
protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    try
    {
        await foreach (var job in channel.ReadAllAsync(stoppingToken))
        {
            await ProcessAsync(job, stoppingToken);
        }
    }
    catch (OperationCanceledException)
    {
        _logger.LogInformation("Shutdown requested");
    }
    finally
    {
        await CleanupAsync();
    }
}
```

### 5. Cancellable Delays
```csharp
// Respects cancellation
await Task.Delay(1000, stoppingToken);

// Also respects cancellation
await channel.Reader.ReadAsync(stoppingToken);
```

## Patterns

### Retry with State Tracking
```csharp
async Task ProcessWithRetry(Job job, CancellationToken ct)
{
    job.Status = JobStatus.Processing;

    while (job.RetryCount <= MaxRetries)
    {
        try
        {
            await ProcessAsync(job);
            job.Status = JobStatus.Completed;
            return;
        }
        catch (Exception ex)
        {
            job.RetryCount++;
            job.ErrorMessage = ex.Message;

            if (job.RetryCount > MaxRetries)
            {
                job.Status = JobStatus.Failed;
                return;
            }

            await Task.Delay(GetDelay(job.RetryCount), ct);
        }
    }
}
```

## Best Practices

1. **Limit retries** - 3-5 max for most cases
2. **Exponential backoff** - Don't hammer failing services
3. **Track state** - For visibility and debugging
4. **Use ConcurrentDictionary** - For thread-safe access
5. **Always cleanup** - Use finally blocks
6. **Log everything** - Retries, failures, shutdowns

## Key Takeaways

1. Exponential backoff prevents thundering herd
2. State tracking enables monitoring
3. ConcurrentDictionary is thread-safe
4. CancellationToken enables graceful shutdown
5. Finally blocks ensure cleanup
