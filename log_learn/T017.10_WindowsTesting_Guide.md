# Learning Guide: Subtask 17.10 - Windows Installation Testing

## Overview

This guide explains how to create comprehensive installation validation tests for Windows applications, designed to run on clean Windows 10/11 machines.

## Why Installation Testing?

Installation testing validates:
1. All files are correctly placed
2. Services are properly configured
3. Dependencies are available
4. Application is functional
5. Shortcuts work correctly

## Windows Version Detection

### Get Windows Version Info
```powershell
$os = Get-CimInstance -ClassName Win32_OperatingSystem

# Key properties
$os.Caption        # "Microsoft Windows 11 Pro"
$os.BuildNumber    # "22621"
$os.Version        # "10.0.22621"
```

### Check Windows 10 vs 11
```powershell
$caption = $os.Caption
$buildNumber = [int]$os.BuildNumber

if ($caption -match "Windows 11") {
    # Windows 11 (Build 22000+)
    $isSupported = $buildNumber -ge 22000
}
elseif ($caption -match "Windows 10") {
    # Windows 10 (Build 19041+ for 2004)
    $isSupported = $buildNumber -ge 19041
}
```

### Windows Build Numbers
| Windows Version | Build Number |
|-----------------|--------------|
| Windows 10 2004 | 19041 |
| Windows 10 21H2 | 19044 |
| Windows 10 22H2 | 19045 |
| Windows 11 21H2 | 22000 |
| Windows 11 22H2 | 22621 |
| Windows 11 23H2 | 22631 |

## Test Result Tracking

### Using Custom Objects
```powershell
$script:TestResults = @()

function Add-TestResult {
    param(
        [string]$TestName,
        [string]$Category,
        [bool]$Passed,
        [string]$Message = ""
    )

    $result = [PSCustomObject]@{
        TestName = $TestName
        Category = $Category
        Passed = $Passed
        Message = $Message
        Timestamp = Get-Date
    }

    $script:TestResults += $result

    if ($Passed) {
        Write-Host "  [PASS] $TestName" -ForegroundColor Green
    } else {
        Write-Host "  [FAIL] $TestName - $Message" -ForegroundColor Red
    }

    return $Passed
}
```

### Counting Results
```powershell
$passed = ($script:TestResults | Where-Object { $_.Passed }).Count
$failed = ($script:TestResults | Where-Object { -not $_.Passed }).Count
$total = $script:TestResults.Count
```

## Installation Verification Patterns

### Check Directory Structure
```powershell
function Test-InstallationDirectories {
    $installPath = "C:\Program Files\MyApp"

    $directories = @(
        $installPath,
        "$installPath\bin",
        "$installPath\config",
        "$installPath\logs"
    )

    foreach ($dir in $directories) {
        $exists = Test-Path $dir
        Add-TestResult -TestName "Directory: $dir" `
                       -Category "Installation" `
                       -Passed $exists
    }
}
```

### Check Required Files
```powershell
function Test-RequiredFiles {
    $files = @(
        "bin\MyApp.exe",
        "config\appsettings.json",
        "config\logging.json"
    )

    foreach ($file in $files) {
        $path = Join-Path $InstallPath $file
        $exists = Test-Path $path
        Add-TestResult -TestName "File: $file" `
                       -Category "Files" `
                       -Passed $exists
    }
}
```

### Validate JSON Configuration
```powershell
function Test-ConfigurationValid {
    $configPath = "$InstallPath\config\appsettings.json"

    try {
        $content = Get-Content $configPath -Raw
        $json = $content | ConvertFrom-Json

        Add-TestResult -TestName "Valid JSON Configuration" `
                       -Category "Configuration" `
                       -Passed $true
    }
    catch {
        Add-TestResult -TestName "Valid JSON Configuration" `
                       -Category "Configuration" `
                       -Passed $false `
                       -Message $_.Exception.Message
    }
}
```

## Service Testing

### Check Service Installation
```powershell
function Test-ServiceInstalled {
    $serviceName = "MyAppService"

    $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue

    Add-TestResult -TestName "Service Installed" `
                   -Category "Service" `
                   -Passed ($null -ne $service) `
                   -Message $(if ($service) { "Found" } else { "Not found" })

    if ($service) {
        # Check status
        Add-TestResult -TestName "Service Running" `
                       -Category "Service" `
                       -Passed ($service.Status -eq 'Running') `
                       -Message "Status: $($service.Status)"

        # Check startup type
        Add-TestResult -TestName "Service Auto-Start" `
                       -Category "Service" `
                       -Passed ($service.StartType -in @('Automatic', 'AutomaticDelayedStart')) `
                       -Message "StartType: $($service.StartType)"
    }
}
```

## Health Check Testing

### Test API Endpoint
```powershell
function Test-HealthEndpoint {
    $url = "http://localhost:5000/health"

    try {
        $response = Invoke-WebRequest -Uri $url -UseBasicParsing -TimeoutSec 10

        $statusOk = $response.StatusCode -eq 200
        Add-TestResult -TestName "Health Endpoint Responds" `
                       -Category "Health" `
                       -Passed $statusOk `
                       -Message "Status: $($response.StatusCode)"

        if ($statusOk) {
            $healthy = $response.Content -match "healthy|ok"
            Add-TestResult -TestName "Health Status OK" `
                           -Category "Health" `
                           -Passed $healthy
        }
    }
    catch {
        Add-TestResult -TestName "Health Endpoint Responds" `
                       -Category "Health" `
                       -Passed $false `
                       -Message $_.Exception.Message
    }
}
```

## Shortcut Verification

### Check Desktop Shortcut
```powershell
function Test-DesktopShortcut {
    # Check Public Desktop (All Users)
    $publicDesktop = [Environment]::GetFolderPath('CommonDesktopDirectory')
    $publicShortcut = Join-Path $publicDesktop "MyApp.lnk"

    # Check User Desktop
    $userDesktop = [Environment]::GetFolderPath('Desktop')
    $userShortcut = Join-Path $userDesktop "MyApp.lnk"

    $exists = (Test-Path $publicShortcut) -or (Test-Path $userShortcut)

    Add-TestResult -TestName "Desktop Shortcut Exists" `
                   -Category "Shortcuts" `
                   -Passed $exists
}
```

### Check Start Menu
```powershell
function Test-StartMenuShortcut {
    $startMenu = [Environment]::GetFolderPath('CommonPrograms')
    $appFolder = Join-Path $startMenu "MyApp"

    Add-TestResult -TestName "Start Menu Folder Exists" `
                   -Category "Shortcuts" `
                   -Passed (Test-Path $appFolder)

    if (Test-Path $appFolder) {
        $mainShortcut = Join-Path $appFolder "MyApp.lnk"
        Add-TestResult -TestName "Start Menu Main Shortcut" `
                       -Category "Shortcuts" `
                       -Passed (Test-Path $mainShortcut)
    }
}
```

## Report Generation

### Generate Summary Report
```powershell
function Write-TestReport {
    $passed = ($script:TestResults | Where-Object { $_.Passed }).Count
    $failed = ($script:TestResults | Where-Object { -not $_.Passed }).Count
    $total = $script:TestResults.Count

    Write-Host ""
    Write-Host "═══════════════════════════════════════════════════════════════"
    Write-Host "                    TEST RESULTS SUMMARY"
    Write-Host "═══════════════════════════════════════════════════════════════"
    Write-Host ""
    Write-Host "  Total Tests:  $total"
    Write-Host "  Passed:       $passed" -ForegroundColor Green
    Write-Host "  Failed:       $failed" -ForegroundColor $(if ($failed -gt 0) { "Red" } else { "Green" })
    Write-Host ""

    # Category breakdown
    $categories = $script:TestResults | Group-Object Category
    foreach ($cat in $categories) {
        $catPassed = ($cat.Group | Where-Object { $_.Passed }).Count
        $catTotal = $cat.Group.Count
        Write-Host "    $($cat.Name): $catPassed/$catTotal"
    }

    Write-Host ""
    Write-Host "═══════════════════════════════════════════════════════════════"

    # Overall result
    if ($failed -eq 0) {
        Write-Host "  ✓ ALL TESTS PASSED" -ForegroundColor Green
    } else {
        Write-Host "  ✗ SOME TESTS FAILED" -ForegroundColor Red
    }
}
```

### Save Report to File
```powershell
function Save-TestReport {
    param([string]$Path)

    $report = @"
Installation Test Report
Generated: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")

RESULTS
=======
"@

    foreach ($result in $script:TestResults) {
        $status = if ($result.Passed) { "PASS" } else { "FAIL" }
        $report += "`n[$status] $($result.Category): $($result.TestName)"
        if ($result.Message) { $report += " - $($result.Message)" }
    }

    $report | Out-File -FilePath $Path -Encoding UTF8
}
```

## Clean Machine Testing Checklist

### Before Testing
1. Start with fresh Windows 10/11 VM
2. Install only the application being tested
3. Note any automatic Windows updates

### Test Categories
1. **Prerequisites**: .NET, Docker, PowerShell
2. **Files**: All required files present
3. **Configuration**: Valid config files
4. **Services**: Installed and running
5. **Shortcuts**: Desktop and Start Menu
6. **Functionality**: Health checks pass

### Exit Codes
```powershell
$EXIT_SUCCESS = 0        # All tests passed
$EXIT_SOME_FAILED = 1    # Non-critical failures
$EXIT_CRITICAL = 2       # Critical failures

exit $(if ($failed -eq 0) { $EXIT_SUCCESS }
       elseif ($criticalFailed) { $EXIT_CRITICAL }
       else { $EXIT_SOME_FAILED })
```

## Summary

Installation testing on clean Windows machines ensures:
1. Complete installation verification
2. Service functionality validation
3. Shortcut correctness
4. Health endpoint availability
5. Comprehensive reporting

The `test-installation.ps1` script provides automated validation that can be run:
- Manually after installation
- As part of CI/CD pipelines
- During QA testing
- For customer support verification
