# T015.2 - Fallback Identifiers Learnings

**Subtask**: 15.2 - Add fallback identifiers (MAC address)
**Date**: 2025-12-09

---

## Key Learnings

### 1. MAC Address Structure

MAC addresses are 48-bit hardware identifiers:

```
OUI (24 bits)      NIC (24 bits)
XX:XX:XX           XX:XX:XX
└─────┘            └─────┘
Manufacturer       Device-specific
```

**First byte special bits**:
- Bit 0 (LSB): Unicast (0) / Multicast (1)
- Bit 1: Universal (0) / Locally Administered (1)

```typescript
// Check locally administered bit
const firstByte = parseInt(mac.substring(0, 2), 16);
const isLocal = (firstByte & 0x02) !== 0;
```

### 2. Virtual Machine Detection via OUI

Virtual machine hypervisors use specific OUI prefixes:

| OUI | Vendor | Notes |
|-----|--------|-------|
| 00:50:56 | VMware | vSphere, Workstation |
| 00:0C:29 | VMware | Older products |
| 08:00:27 | VirtualBox | All versions |
| 52:54:00 | QEMU/KVM | Linux virtualization |
| 00:15:5D | Hyper-V | Windows Server |

**Why this matters**: Virtual MACs change frequently and shouldn't be primary identifiers.

### 3. Docker/Container MAC Detection

Docker bridges use locally administered MACs:

```
02:42:AC:XX:XX:XX  (Docker default bridge)
      ↑
      Locally administered bit set
```

The `02` prefix indicates locally administered, making detection easy:

```typescript
function isVirtualMacAddress(mac: string): boolean {
  const firstByte = parseInt(mac.substring(0, 2), 16);
  return (firstByte & 0x02) !== 0;
}
```

### 4. Network Interface Filtering Strategy

Multi-layer filtering for reliable MACs:

```typescript
function filterPhysicalInterfaces(interfaces) {
  return interfaces.filter(iface => {
    // Layer 1: Skip internal (loopback)
    if (iface.internal) return false;

    // Layer 2: Skip zero/unset MACs
    if (iface.mac === '00:00:00:00:00:00') return false;

    // Layer 3: Skip locally administered
    if (isVirtualMacAddress(iface.mac)) return false;

    // Layer 4: Skip known VM vendors
    if (isKnownVirtualVendor(iface.mac)) return false;

    return true;
  });
}
```

### 5. Ethernet vs WiFi Priority

Ethernet MACs are more stable than WiFi:
- Ethernet: Wired, rarely changes
- WiFi: Can change with MAC randomization

```typescript
function getPrimaryMacAddress(interfaces) {
  const physical = filterPhysicalInterfaces(interfaces);

  // Prefer Ethernet
  const ethernet = physical.find(iface =>
    iface.name.includes('eth') ||    // Linux
    iface.name.includes('en0') ||    // macOS
    iface.name.includes('Ethernet')  // Windows
  );

  return ethernet?.mac || physical[0]?.mac;
}
```

### 6. WMIC Placeholder Values

Windows WMIC returns placeholder values for missing data:

```
To Be Filled By O.E.M.   // Common placeholder
Default string           // Generic placeholder
```

Always filter these out:

```typescript
function parseWmicBiosSerial(output: string): string | null {
  for (const line of lines) {
    if (line === 'To Be Filled By O.E.M.') continue;
    if (line === 'Default string') continue;
    if (line.length >= 4) return line;
  }
  return null;
}
```

### 7. Identifier Priority System

Create a scoring system for identifier reliability:

| Identifier | Score | Reliability |
|------------|-------|-------------|
| UUID | 40 | Hardware-level, survives reinstalls |
| Machine ID | 35 | OS-level, changes with reinstall |
| MAC | 25 | Hardware, but can be spoofed |
| Disk Serial | 20 | Hardware, but drives change |
| BIOS Serial | 15 | Hardware, often placeholder |

**Total Score Calculation**:
```typescript
function calculateTotalStrength(...): number {
  const total = strengths.reduce((sum, s) => sum + s.score, 0);
  return Math.min(total, 100);  // Cap at 100
}
```

### 8. Fallback Chain Design

Implement graceful degradation:

```typescript
function getBestIdentifier(uuid, machineId, fallback) {
  // Priority chain
  if (uuid) return uuid;
  if (machineId) return machineId;
  if (fallback.primaryMac) return fallback.primaryMac;
  if (fallback.diskSerial) return fallback.diskSerial;
  if (fallback.biosSerial) return fallback.biosSerial;

  return null;  // All failed
}
```

### 9. Cross-Platform Serial Collection

Different commands per platform:

**Disk Serial**:
```bash
# Windows
wmic diskdrive get serialnumber

# Linux
lsblk -dno SERIAL /dev/sda

# macOS
system_profiler SPSerialATADataType | grep "Serial Number"
```

**BIOS Serial**:
```bash
# Windows
wmic bios get serialnumber

# Linux
cat /sys/class/dmi/id/product_serial

# macOS
system_profiler SPHardwareDataType | grep "Serial Number"
```

### 10. Enhanced Fingerprint Design

Extend base fingerprint with fallback data:

```typescript
interface EnhancedFingerprintResult extends FingerprintResult {
  identifiers: EnhancedHardwareIdentifiers;
  fallbackUsed: boolean;    // True if primary IDs unavailable
  strengthScore: number;    // 0-100 reliability indicator
}
```

**Benefits**:
- Clear indication when fallback is used
- Quantified reliability for licensing decisions

---

## Best Practices Discovered

### 1. Validate Before Use

Always validate fallback data:

```typescript
function validateFallbackIdentifiers(fallback): boolean {
  if (fallback.primaryMac && !isValidMacAddress(fallback.primaryMac)) {
    return false;
  }
  return true;
}
```

### 2. Minimum Identifier Check

Require at least one identifier:

```typescript
function hasMinimumFallbackIdentifiers(fallback): boolean {
  return !!(
    fallback.primaryMac ||
    fallback.diskSerial ||
    fallback.biosSerial
  );
}
```

### 3. Composable Components

Generate fingerprint components separately:

```typescript
function generateFallbackComponent(fallback): string {
  const components = [];
  if (fallback.primaryMac) components.push(`mac:${fallback.primaryMac}`);
  if (fallback.diskSerial) components.push(`disk:${fallback.diskSerial}`);
  return components.join('|');
}
```

### 4. Strength Transparency

Expose strength scores to users:

```typescript
async getIdentifiersSummary(): Promise<IdentifierStrength[]> {
  return [
    { identifier: 'uuid', available: true, score: 40 },
    { identifier: 'mac', available: true, score: 25 },
    // ...
  ];
}
```

---

## Common Pitfalls

### 1. MAC Address Format Variations

MACs come in multiple formats:

```
00:1A:2B:3C:4D:5E  // Colon-separated (Unix)
00-1A-2B-3C-4D-5E  // Dash-separated (Windows)
001A2B3C4D5E      // No separator (compact)
```

**Solution**: Normalize to standard format:

```typescript
function normalizeMacAddress(mac: string): string {
  const cleaned = mac.replace(/[:-]/g, '').toUpperCase();
  return cleaned.match(/.{2}/g)?.join(':') || mac;
}
```

### 2. Case Sensitivity

MACs can be upper or lower case. Always normalize:

```typescript
// Bad
if (mac === '00:1a:2b:3c:4d:5e') // May not match

// Good
if (normalizeMacAddress(mac) === '00:1A:2B:3C:4D:5E')
```

### 3. Network Interface Naming

Interface names vary by OS and configuration:

```
eth0, eth1, enp3s0    // Linux Ethernet
en0, en1              // macOS
Ethernet, Wi-Fi       // Windows
docker0, veth123      // Docker
```

Use pattern matching, not exact names.

---

## Architecture Decisions

### Why Separate Service File?

- **Separation of Concerns**: Base fingerprint vs fallback logic
- **Single Responsibility**: Each file handles one domain
- **Testability**: Can test fallback logic independently
- **Extensibility**: Easy to add more fallback sources

### Why Enhanced vs Replacement?

Extended the base service rather than replacing:

```typescript
// Inheritance-like pattern
interface EnhancedHardwareIdentifiers extends HardwareIdentifiers {
  fallback: FallbackIdentifiers;
}
```

**Benefits**:
- Backward compatible
- Base service still usable
- Clear upgrade path

---

## Future Considerations

1. **TPM-based Identifiers**: More secure than MAC
2. **Hardware Change Detection**: Track when MACs change
3. **Mobile MAC Randomization**: iOS/Android randomize MACs
4. **USB Device Serials**: Additional fallback option

