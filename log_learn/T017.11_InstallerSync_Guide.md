# Automated Installer Sync - Learning Guide

**Task**: Automated synchronization of downloadable installer between repositories
**Date**: 2025-12-11
**Difficulty**: Intermediate to Advanced

---

## Overview

This guide explains how to set up automated synchronization between a software repository (builds and releases) and a website repository (downloads and distribution). The pattern is commonly used for:

- Software distribution websites
- Documentation sites with downloadable assets
- Multi-repository projects needing coordinated releases

---

## Key Concepts

### 1. GitHub Actions

GitHub Actions is a CI/CD platform that automates workflows directly in your repository.

**Key Terms:**
- **Workflow**: An automated process defined in YAML
- **Job**: A set of steps that run on the same runner
- **Step**: Individual tasks within a job
- **Runner**: The server that runs your workflows
- **Artifact**: Files produced during workflow execution

### 2. Repository Dispatch

A way to trigger workflows in one repository from another repository.

```yaml
# Sending (source repo)
- uses: peter-evans/repository-dispatch@v2
  with:
    token: ${{ secrets.PAT_TOKEN }}
    repository: owner/target-repo
    event-type: custom-event
    client-payload: '{"key": "value"}'

# Receiving (target repo)
on:
  repository_dispatch:
    types: [custom-event]
```

### 3. Personal Access Tokens (PAT)

Tokens that authenticate actions across repositories.

**Required Scopes:**
- `repo` - Access to repositories
- `workflow` - Permission to trigger workflows

---

## Architecture Pattern

```
┌─────────────────────────────────────────────────────────────┐
│                      Source Repository                       │
│                         (contpaqi)                           │
│                                                              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐     │
│  │   Code      │───▶│   Build     │───▶│   Release   │     │
│  │   Changes   │    │   Process   │    │   Assets    │     │
│  └─────────────┘    └─────────────┘    └──────┬──────┘     │
│                                               │             │
│                                    repository_dispatch      │
│                                               │             │
└───────────────────────────────────────────────┼─────────────┘
                                                │
                                                ▼
┌───────────────────────────────────────────────┼─────────────┐
│                      Target Repository        │              │
│                     (contpaqi-website)        │              │
│                                               │              │
│  ┌─────────────┐    ┌─────────────┐    ┌─────┴───────┐     │
│  │   Update    │◀───│   Process   │◀───│   Receive   │     │
│  │   Website   │    │   Payload   │    │   Event     │     │
│  └─────────────┘    └─────────────┘    └─────────────┘     │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

---

## Step-by-Step Implementation

### Step 1: Create the Build Workflow

```yaml
# .github/workflows/build.yml
name: Build and Release

on:
  push:
    tags:
      - 'v*'  # Trigger on version tags

jobs:
  build:
    runs-on: windows-latest  # Use Windows for .exe builds
    steps:
      - uses: actions/checkout@v4

      - name: Build Application
        run: |
          # Your build commands here
          npm ci
          npm run build

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: my-app
          path: dist/

  release:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: my-app
          path: release-files/

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: release-files/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

### Step 2: Trigger Cross-Repository Update

```yaml
  notify-website:
    needs: release
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Website Update
        uses: peter-evans/repository-dispatch@v2
        with:
          token: ${{ secrets.WEBSITE_REPO_TOKEN }}
          repository: owner/website-repo
          event-type: new-release
          client-payload: |
            {
              "version": "${{ github.ref_name }}",
              "download_url": "https://github.com/${{ github.repository }}/releases/download/${{ github.ref_name }}/app.exe"
            }
```

### Step 3: Create Website Update Workflow

```yaml
# In website repo: .github/workflows/update-download.yml
name: Update Download Info

on:
  repository_dispatch:
    types: [new-release]

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Update download info
        run: |
          cat > public/download.json << EOF
          {
            "version": "${{ github.event.client_payload.version }}",
            "url": "${{ github.event.client_payload.download_url }}"
          }
          EOF

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add public/download.json
          git commit -m "Update to ${{ github.event.client_payload.version }}"
          git push
```

### Step 4: Create Download Component

```tsx
// React component to display download info
'use client';

import { useEffect, useState } from 'react';

interface DownloadInfo {
  version: string;
  url: string;
}

export function DownloadButton() {
  const [info, setInfo] = useState<DownloadInfo | null>(null);

  useEffect(() => {
    fetch('/download.json')
      .then(res => res.json())
      .then(setInfo);
  }, []);

  if (!info) return <p>Loading...</p>;

  return (
    <a href={info.url} className="btn-primary">
      Download v{info.version}
    </a>
  );
}
```

---

## Security Best Practices

### 1. Token Management

```yaml
# DON'T: Hardcode tokens
token: ghp_xxxxxxxxxxxx

# DO: Use secrets
token: ${{ secrets.WEBSITE_REPO_TOKEN }}
```

### 2. Minimal Scopes

Only request necessary permissions:
- `repo` for repository access
- `workflow` for triggering workflows
- Avoid `admin:org` or `delete_repo`

### 3. Token Rotation

- Set calendar reminder to rotate tokens
- Use short-lived tokens when possible
- Audit token usage regularly

### 4. Payload Validation

```yaml
- name: Validate payload
  run: |
    if [ -z "${{ github.event.client_payload.version }}" ]; then
      echo "Missing version in payload"
      exit 1
    fi
```

---

## Common Patterns

### Pattern 1: Semantic Versioning

```yaml
- name: Extract version
  id: version
  run: |
    VERSION=${GITHUB_REF#refs/tags/v}
    echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
```

### Pattern 2: Checksum Generation

```powershell
# Windows PowerShell
$hash = Get-FileHash -Path "app.exe" -Algorithm SHA256
echo "SHA256=$($hash.Hash)" >> $GITHUB_OUTPUT
```

```bash
# Linux/macOS
SHA256=$(sha256sum app.exe | cut -d' ' -f1)
echo "SHA256=$SHA256" >> $GITHUB_OUTPUT
```

### Pattern 3: Conditional Releases

```yaml
- name: Create Release
  if: startsWith(github.ref, 'refs/tags/v')
  uses: softprops/action-gh-release@v1
```

### Pattern 4: Matrix Builds

```yaml
jobs:
  build:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
```

---

## Troubleshooting

### Issue: Workflow Not Triggering

**Symptoms**: Push tag but workflow doesn't run

**Solutions**:
1. Check workflow syntax: `act -n` or GitHub's workflow editor
2. Verify tag pattern matches: `v*` vs `v*.*.*`
3. Check branch protection rules

### Issue: Repository Dispatch Fails

**Symptoms**: 404 or 403 errors

**Solutions**:
1. Verify PAT has `repo` and `workflow` scopes
2. Check repository name is correct (case-sensitive)
3. Ensure target repo has workflow with matching event type

### Issue: Checkout Fails in Target Repo

**Symptoms**: "Permission denied" during push

**Solutions**:
```yaml
- uses: actions/checkout@v4
  with:
    token: ${{ secrets.GITHUB_TOKEN }}
    # Or use PAT for cross-repo
    token: ${{ secrets.PAT_TOKEN }}
```

---

## Advanced Topics

### Reusable Workflows

```yaml
# .github/workflows/reusable-build.yml
on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string

# Usage in another workflow
jobs:
  call-build:
    uses: owner/repo/.github/workflows/reusable-build.yml@main
    with:
      version: "1.0.0"
```

### Environment Protection

```yaml
jobs:
  deploy:
    environment: production
    runs-on: ubuntu-latest
```

### Caching Dependencies

```yaml
- uses: actions/cache@v3
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
```

---

## Resources

- [GitHub Actions Documentation](https://docs.github.com/en/actions)
- [Repository Dispatch Action](https://github.com/peter-evans/repository-dispatch)
- [GitHub Release Action](https://github.com/softprops/action-gh-release)
- [Workflow Syntax Reference](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions)

---

## Summary

Cross-repository automation enables:

1. **Separation of Concerns**: Build logic separate from website
2. **Automatic Updates**: No manual intervention needed
3. **Consistent Releases**: Same process every time
4. **Audit Trail**: Git history tracks all changes

The key components are:
- Source workflow that builds and releases
- Repository dispatch to communicate between repos
- Target workflow that updates website
- React/frontend component to display information
