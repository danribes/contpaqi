# Learning Guide: Subtask 17.4 - Bundle Docker Image (docker save)

## Overview

This guide explains how to bundle Docker images for offline distribution. The `docker save` command exports Docker images to tar archives that can be transported and loaded on machines without internet access.

## Why Bundle Docker Images?

1. **Offline Installation**: Install on air-gapped systems
2. **Consistent Deployment**: Same image version everywhere
3. **Faster Installation**: No need to download during install
4. **Enterprise Environments**: Restricted network access
5. **Version Control**: Bundle specific tested versions

## Docker Save Command

### Basic Syntax
```bash
docker save -o <output-file.tar> <image-name>:<tag>
```

### Examples
```bash
# Save single image
docker save -o myapp.tar myapp:latest

# Save multiple images
docker save -o images.tar image1:v1 image2:v2

# Save with compression (piped)
docker save myapp:latest | gzip > myapp.tar.gz
```

### Output Format
- Creates a tar archive containing:
  - Layer blobs (filesystem changes)
  - Image manifest
  - Configuration JSON
  - Repository metadata

## Docker Load Command

To restore a saved image:
```bash
docker load -i myapp.tar
# or
docker load < myapp.tar
```

### Verification
```bash
# After loading, verify image exists
docker images | grep myapp
```

## PowerShell Implementation

### Checking Docker Availability
```powershell
function Test-DockerAvailable {
    $dockerCmd = Get-Command "docker" -ErrorAction SilentlyContinue
    return $null -ne $dockerCmd
}
```

### Checking Docker Daemon
```powershell
function Test-DockerRunning {
    try {
        $result = & docker info 2>&1
        return $LASTEXITCODE -eq 0
    }
    catch {
        return $false
    }
}
```

### Checking Image Exists
```powershell
function Test-DockerImageExists {
    param([string]$Image)

    try {
        $result = & docker image inspect $Image 2>&1
        return $LASTEXITCODE -eq 0
    }
    catch {
        return $false
    }
}
```

### Saving the Image
```powershell
$saveResult = & docker save -o $OutputFile $FullImageName 2>&1

if ($LASTEXITCODE -ne 0) {
    Write-Error "Docker save failed: $saveResult"
    exit 1
}
```

## Compression Options

### Uncompressed (.tar)
- Faster to create and load
- Larger file size
- Better for local distribution

### Compressed (.tar.gz)
- Smaller file size (typically 30-50% reduction)
- Slower to create and load
- Better for network transfer

### PowerShell Compression
```powershell
# Using .NET GZipStream
$inputStream = [System.IO.File]::OpenRead($tarFile)
$outputStream = [System.IO.File]::Create($gzipFile)
$gzipStream = New-Object System.IO.Compression.GZipStream(
    $outputStream,
    [System.IO.Compression.CompressionMode]::Compress
)

$inputStream.CopyTo($gzipStream)

$gzipStream.Close()
$outputStream.Close()
$inputStream.Close()
```

## File Size Considerations

### Typical Image Sizes
| Image Type | Uncompressed | Compressed |
|------------|--------------|------------|
| Alpine-based | 50-100 MB | 20-40 MB |
| Debian-based | 200-500 MB | 80-200 MB |
| ML/AI images | 2-10 GB | 1-4 GB |

### Formatting File Sizes
```powershell
function Format-FileSize {
    param([long]$Bytes)

    if ($Bytes -ge 1GB) {
        return "{0:N2} GB" -f ($Bytes / 1GB)
    } elseif ($Bytes -ge 1MB) {
        return "{0:N2} MB" -f ($Bytes / 1MB)
    } else {
        return "{0:N2} KB" -f ($Bytes / 1KB)
    }
}
```

## Integration with Inno Setup

### Directory Structure
```
installer/
├── dist/
│   └── docker/
│       └── contpaqi-mcp.tar    ← Generated by bundle-docker.ps1
├── scripts/
│   └── bundle-docker.ps1
└── contpaqi-bridge.iss
```

### ISS File Reference
```pascal
[Files]
Source: "dist\docker\contpaqi-mcp.tar"; DestDir: "{app}\docker"; Flags: ignoreversion
```

### Build Process
1. Build Docker image: `docker build -t contpaqi-mcp:latest .`
2. Bundle image: `.\bundle-docker.ps1`
3. Build installer: `iscc contpaqi-bridge.iss`

## Error Handling

### Common Issues

**Docker not installed:**
```powershell
if (-not (Test-DockerAvailable)) {
    Write-Error "Docker CLI not found"
    exit 1
}
```

**Docker not running:**
```powershell
if (-not (Test-DockerRunning)) {
    Write-Error "Docker daemon not running"
    exit 2
}
```

**Image not found:**
```powershell
if (-not (Test-DockerImageExists $ImageName)) {
    Write-Error "Image not found: $ImageName"
    exit 3
}
```

**Disk space:**
```powershell
# Check available space before saving
$drive = (Get-Item $OutputPath).PSDrive
$freeSpace = $drive.Free
$imageSize = Get-DockerImageSize $ImageName

if ($freeSpace -lt ($imageSize * 1.5)) {
    Write-Warning "Low disk space"
}
```

## Best Practices

1. **Tag Images**: Always use specific tags, not just `latest`
2. **Verify After Save**: Check the tar file was created
3. **Document Versions**: Record which image version was bundled
4. **Test Loading**: Test the load process before distribution
5. **Include Checksums**: Generate SHA256 for verification

### Checksum Generation
```powershell
$hash = Get-FileHash -Path $OutputFile -Algorithm SHA256
Write-Output "SHA256: $($hash.Hash)"
```

## Summary

Docker image bundling enables offline distribution of containerized applications. The `docker save` command creates portable tar archives that can be loaded anywhere Docker is installed. This is essential for enterprise deployments and air-gapped environments.

Key points:
- Use `docker save -o file.tar image:tag` to export
- Use `docker load -i file.tar` to import
- Consider compression for network distribution
- Always verify images exist before saving
- Integrate into build pipelines for consistent deployments
