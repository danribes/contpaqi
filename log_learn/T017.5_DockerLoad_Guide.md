# Learning Guide: Subtask 17.5 - Silent Docker Image Loading

## Overview

This guide explains how to load Docker images from tar files during application installation. The `docker load` command imports images that were previously exported with `docker save`, enabling offline installation without internet access.

## Why Silent Loading?

1. **Offline Installation**: No internet required during setup
2. **Consistent Versions**: Exact same image on all machines
3. **Faster Deployment**: No download time during install
4. **Enterprise Ready**: Works in restricted network environments
5. **Seamless UX**: Runs in background without user interaction

## Docker Load Command

### Basic Syntax
```bash
docker load -i <input-file.tar>
# or
docker load < input-file.tar
```

### Output Format
```
Loaded image: contpaqi-mcp:latest
```

### Options
| Flag | Description |
|------|-------------|
| `-i, --input` | Read from tar archive file |
| `-q, --quiet` | Suppress load output |

## PowerShell Implementation

### Checking Prerequisites

**Docker CLI Available:**
```powershell
function Test-DockerAvailable {
    $dockerCmd = Get-Command "docker" -ErrorAction SilentlyContinue
    return $null -ne $dockerCmd
}
```

**Docker Daemon Running:**
```powershell
function Test-DockerRunning {
    try {
        $result = & docker info 2>&1
        return $LASTEXITCODE -eq 0
    }
    catch {
        return $false
    }
}
```

**Image Already Exists:**
```powershell
function Test-DockerImageExists {
    param([string]$Image)

    try {
        $result = & docker image inspect $Image 2>&1
        return $LASTEXITCODE -eq 0
    }
    catch {
        return $false
    }
}
```

### Loading the Image

```powershell
# Load image from tar file
$loadResult = & docker load -i $ImagePath 2>&1

if ($LASTEXITCODE -ne 0) {
    Write-Error "Docker load failed: $loadResult"
    exit 4
}

# Parse loaded image name
if ($loadResult -match "Loaded image:\s*(.+)") {
    $loadedImage = $Matches[1].Trim()
    Write-Host "Loaded: $loadedImage"
}
```

### Verifying the Load

```powershell
# Verify image exists after load
if (-not (Test-DockerImageExists "contpaqi-mcp:latest")) {
    Write-Error "Image verification failed"
    exit 5
}

# Get image details
$size = & docker image inspect $Image --format "{{.Size}}" 2>&1
$id = & docker image inspect $Image --format "{{.Id}}" 2>&1
```

## Silent Mode for Installers

### Suppressing Output

```powershell
param(
    [switch]$Quiet,
    [switch]$Silent
)

# Treat -Silent as alias for -Quiet
if ($Silent) { $Quiet = $true }

function Write-Log {
    param([string]$Message, [string]$Level = "Info")

    # In quiet mode, only show errors
    if ($Quiet -and $Level -ne "Error") {
        return
    }

    Write-Host $Message
}
```

### Exit Codes for Automation

```powershell
$EXIT_SUCCESS = 0
$EXIT_DOCKER_NOT_FOUND = 1
$EXIT_DOCKER_NOT_RUNNING = 2
$EXIT_FILE_NOT_FOUND = 3
$EXIT_LOAD_FAILED = 4
$EXIT_VERIFY_FAILED = 5
$EXIT_ALREADY_LOADED = 6
```

Exit codes allow the installer to detect and handle failures appropriately.

## Integration with Inno Setup

### Running During Installation

```pascal
[Run]
; Load Docker image after files are copied
Filename: "{app}\scripts\load-docker-image.ps1";
    Flags: runhidden waituntilterminated;
    StatusMsg: "Loading Docker image...";
    Check: DockerInstalled
```

### Key Flags
- `runhidden`: Don't show PowerShell window
- `waituntilterminated`: Wait for script to complete
- `Check: DockerInstalled`: Only run if Docker is installed

### Conditional Execution

The `Check: DockerInstalled` condition prevents the script from running if Docker isn't installed, avoiding unnecessary errors.

## Handling Edge Cases

### Image Already Loaded

```powershell
if (Test-DockerImageExists $FullImageName) {
    if ($SkipIfLoaded) {
        Write-Log "Image already loaded. Skipping."
        return $EXIT_ALREADY_LOADED
    } elseif ($Force) {
        Write-Log "Reloading image..."
    } else {
        Write-Log "Image exists. Use -Force to reload."
        return $EXIT_ALREADY_LOADED
    }
}
```

### Missing Tar File

```powershell
if (-not (Test-Path $ImagePath)) {
    Write-Log "Image file not found: $ImagePath" -Level Error
    return $EXIT_FILE_NOT_FOUND
}
```

### Docker Not Running

```powershell
if (-not (Test-DockerRunning)) {
    Write-Log "Docker daemon not running. Please start Docker Desktop." -Level Error
    return $EXIT_DOCKER_NOT_RUNNING
}
```

## Complete Workflow

### Installation Process
```
1. Installer copies files to {app}
   └── docker/contpaqi-mcp.tar

2. [Run] section executes load-docker-image.ps1
   ├── Check Docker available
   ├── Check Docker running
   ├── Load image from tar
   └── Verify image loaded

3. Installation completes
   └── Image ready for use
```

### Build Process
```
1. Build Docker image
   docker build -t contpaqi-mcp:latest .

2. Bundle image (17.4)
   .\bundle-docker.ps1

3. Load image (17.5) - during install
   .\load-docker-image.ps1
```

## Best Practices

1. **Always Verify**: Check image was actually loaded
2. **Handle Existing**: Support skip/force for upgrades
3. **Silent Mode**: Essential for installer integration
4. **Exit Codes**: Enable proper error handling
5. **Default Paths**: Use relative paths from script location
6. **Logging**: Conditional based on quiet mode

## Troubleshooting

### Common Issues

**Docker not running:**
```
Start Docker Desktop before installation
```

**Tar file missing:**
```
Verify bundle-docker.ps1 was run during build
```

**Permission denied:**
```
Run installer as Administrator
```

**Image verification fails:**
```
Check image name and tag match expected values
```

### Manual Loading

If automatic loading fails:
```powershell
cd "C:\Program Files\ContPAQi AI Bridge"
docker load -i docker\contpaqi-mcp.tar
```

## Summary

Silent Docker image loading enables seamless offline installation of containerized applications. Key components:

- Use `docker load -i` to import tar archives
- Check prerequisites before loading
- Support quiet mode for installer integration
- Verify image after loading
- Handle existing images gracefully
- Return meaningful exit codes

This completes the Docker bundling workflow started in subtask 17.4, providing end-to-end offline Docker image distribution.
