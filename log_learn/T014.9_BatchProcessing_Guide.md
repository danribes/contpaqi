# T014.9 - Batch Processing View Guide

**Learning Topic**: Implementing batch file processing with queue management
**Subtask**: 14.9 - Add batch processing view for multiple invoices
**Date**: 2025-12-09

---

## What We Built

A batch processing interface that allows users to:
1. Upload multiple PDF invoices at once
2. Track processing status for each file
3. See overall progress
4. Handle errors with retry capability
5. Clear completed files

---

## Why Batch Processing?

### User Benefits

1. **Efficiency**: Process many invoices without manual intervention
2. **Visibility**: See progress of entire batch at a glance
3. **Error Recovery**: Retry failed files without re-uploading
4. **Control**: Stop, clear, or modify queue as needed

### Business Benefits

1. **Throughput**: Process high volumes of invoices
2. **Reduced Errors**: Automated handling reduces mistakes
3. **Time Savings**: Users can start batch and do other work

---

## Key Concepts

### Queue-Based Processing

A queue manages items waiting to be processed:

```
[Upload] → [Pending Queue] → [Processing] → [Completed/Error]
```

Benefits:
- **Order**: Files processed in sequence
- **Status**: Each file has clear state
- **Recovery**: Failed files can be retried

### File Status State Machine

```
        ┌──────────────────────────────┐
        │                              │
        ▼                              │
    [pending] ──────► [processing] ────┴──► [completed]
        ▲                   │
        │                   ▼
        └──────────── [error]
```

Each status has meaning:
- **pending**: Waiting to be processed
- **processing**: Currently being processed
- **completed**: Successfully processed
- **error**: Failed, can be retried

---

## Implementation Patterns

### 1. Immutable State Updates

All state updates create new objects:

```typescript
function updateFileStatus(state: BatchState, fileId: string, status: FileStatus): BatchState {
  return {
    ...state,
    files: state.files.map((f) =>
      f.id === fileId ? { ...f, status } : f
    ),
  };
}
```

Why?
- **Predictable**: State changes are traceable
- **Safe**: Original state unchanged
- **React-friendly**: Triggers re-renders correctly

### 2. Filter-Based Queries

Get subsets of files by filtering:

```typescript
function getPendingFiles(state: BatchState): QueuedFile[] {
  return state.files.filter((f) => f.status === 'pending');
}

function getCompletedFiles(state: BatchState): QueuedFile[] {
  return state.files.filter((f) => f.status === 'completed');
}
```

Benefits:
- **Simple**: One-line implementations
- **Composable**: Combine with other operations
- **Type-safe**: Returns typed array

### 3. Progress Calculation

Progress is computed from state:

```typescript
function calculateProgress(state: BatchState): BatchProgress {
  const files = state.files;
  return {
    total: files.length,
    completed: files.filter((f) => f.status === 'completed').length,
    processing: files.filter((f) => f.status === 'processing').length,
    pending: files.filter((f) => f.status === 'pending').length,
    failed: files.filter((f) => f.status === 'error').length,
  };
}

function getProgressPercentage(progress: BatchProgress): number {
  if (progress.total === 0) return 0;
  return Math.round((progress.completed / progress.total) * 100);
}
```

### 4. PDF File Filtering

Only accept PDF files:

```typescript
function addFilesToQueue(state: BatchState, files: File[]): BatchState {
  const pdfFiles = files.filter(
    (file) => file.type === 'application/pdf' ||
              file.name.toLowerCase().endsWith('.pdf')
  );
  // ...
}
```

Two checks:
1. MIME type: `application/pdf`
2. Extension: `.pdf` (fallback for some browsers)

### 5. Unique ID Generation

Each file gets a unique ID:

```typescript
function generateFileId(): string {
  return `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
```

Components:
- Timestamp: Unique per millisecond
- Random: Prevents collision in same millisecond

---

## Component Architecture

### Composition Pattern

Main component composed of smaller pieces:

```
BatchProcessingView
├── FileDropZone
├── BatchSummary
│   └── ProgressBar
├── BatchActions
└── FileListItem (multiple)
    └── StatusIcon
```

Benefits:
- **Testable**: Each component isolated
- **Reusable**: Components can be used elsewhere
- **Maintainable**: Changes localized

### Drag & Drop Implementation

```typescript
function FileDropZone({ onFilesSelected, disabled }: FileDropZoneProps) {
  const [isDragging, setIsDragging] = useState(false);

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    if (!disabled) setIsDragging(true);
  }, [disabled]);

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    if (disabled) return;

    const files = Array.from(e.dataTransfer.files);
    onFilesSelected(files);
  }, [disabled, onFilesSelected]);

  // ...
}
```

Key events:
- `dragOver`: Show visual feedback
- `dragLeave`: Remove feedback
- `drop`: Handle files

### File Input Fallback

Hidden file input for clicking:

```tsx
<input
  ref={inputRef}
  type="file"
  multiple
  accept=".pdf,application/pdf"
  onChange={handleChange}
  className="hidden"
/>
```

Click handler triggers input:
```typescript
const handleClick = () => inputRef.current?.click();
```

---

## Custom Hook Pattern

### useBatchProcessing Hook

Encapsulates all batch logic:

```typescript
function useBatchProcessing(options: UseBatchProcessingOptions = {}) {
  const [state, setState] = useState<BatchState>(createInitialBatchState);

  const addFiles = useCallback((files: File[]) => {
    setState((prev) => addFilesToQueue(prev, files));
  }, []);

  const processNext = useCallback(async () => {
    const current = getNextPendingFile(state);
    if (!current || state.isProcessing) return;

    setState((prev) => ({
      ...markFileProcessing(prev, current.id),
      isProcessing: true,
    }));

    try {
      const result = await options.onProcessFile?.(current.file);
      setState((prev) => ({
        ...markFileCompleted(prev, current.id, result),
        isProcessing: false,
      }));
    } catch (error) {
      setState((prev) => ({
        ...markFileError(prev, current.id, error.message),
        isProcessing: false,
      }));
    }
  }, [state, options.onProcessFile]);

  return {
    state,
    progress: calculateProgress(state),
    addFiles,
    processNext,
    // ...
  };
}
```

Benefits:
- **Encapsulation**: Logic separated from UI
- **Reusability**: Use in different components
- **Testing**: Hook can be tested independently

---

## UI Feedback Patterns

### Status-Based Colors

```typescript
function getStatusColor(status: FileStatus): string {
  switch (status) {
    case 'pending': return 'text-gray-500';
    case 'processing': return 'text-blue-500';
    case 'completed': return 'text-green-500';
    case 'error': return 'text-red-500';
  }
}
```

Color meanings:
- Gray: Neutral, waiting
- Blue: Active, in progress
- Green: Success
- Red: Error

### Progress Bar Colors

```typescript
function getProgressBarColor(progress: BatchProgress): string {
  if (progress.total === 0) return 'bg-gray-300';
  if (progress.failed === progress.total) return 'bg-red-500';
  if (progress.failed > 0) return 'bg-yellow-500';
  return 'bg-green-500';
}
```

Logic:
- Green: No failures (default)
- Yellow: Some failures (warning)
- Red: All failed (error)

### Dynamic Summary Text

```typescript
function getSummaryText(progress: BatchProgress): string {
  if (progress.processing > 0) {
    return `Processing ${progress.completed + 1} of ${progress.total}...`;
  }
  if (progress.completed === progress.total) {
    return `All ${progress.total} files completed successfully`;
  }
  // ...
}
```

Shows relevant information based on current state.

---

## File Size Formatting

Human-readable file sizes:

```typescript
function formatFileSize(bytes: number): string {
  if (bytes < 1024) {
    return `${bytes} B`;
  }
  if (bytes < 1024 * 1024) {
    return `${(bytes / 1024).toFixed(1)} KB`;
  }
  return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
```

Examples:
- 500 → "500 B"
- 1024 → "1.0 KB"
- 1048576 → "1.0 MB"

---

## Action Button States

Conditional button enabling:

```typescript
function getActionButtonState(state: BatchState): ActionButtonState {
  return {
    canStart: !state.isProcessing && hasPendingFiles(state),
    canRetry: !state.isProcessing && hasErrors(state),
    canClear: getCompletedFiles(state).length > 0,
    canClearAll: state.files.length > 0 && !state.isProcessing,
  };
}
```

Rules:
- **Start**: Pending files exist, not processing
- **Retry**: Error files exist, not processing
- **Clear**: Completed files exist
- **Clear All**: Any files, not processing

---

## Testing Approach

### Local Implementation Pattern

Tests define types and functions locally:

```typescript
// Types defined locally
type FileStatus = 'pending' | 'processing' | 'completed' | 'error';

interface QueuedFile {
  id: string;
  file: File;
  status: FileStatus;
  // ...
}

// Functions implemented locally
function createQueuedFile(file: File): QueuedFile {
  return {
    id: generateFileId(),
    file,
    status: 'pending',
    addedAt: new Date(),
  };
}
```

Why?
- Avoids JSX compilation issues in test files
- Tests run without React environment
- Pure logic testing

### File API Usage

Create test files with File constructor:

```typescript
const file = new File(['test content'], 'invoice.pdf', {
  type: 'application/pdf',
});
```

Parameters:
1. Content array
2. Filename
3. Options (type, lastModified)

---

## Common Patterns Reference

### Adding Items to Queue

1. Filter valid files
2. Create queued items with IDs
3. Append to existing queue
4. Return new state

### Processing Queue Items

1. Get next pending item
2. Mark as processing
3. Call processing function
4. Mark as completed or error
5. Continue with next item

### Error Recovery

1. Mark file as error with message
2. Show retry button
3. On retry, reset to pending
4. Clear error message
5. Re-process when queue runs

---

## Files Created

| File | Purpose | Lines |
|------|---------|-------|
| BatchProcessing.tsx | Components, hooks, utilities | ~700 |
| batch-processing.test.ts | 61 tests | ~1100 |

---

## Key Takeaways

1. **Queue pattern** for managing multiple items
2. **Immutable updates** for predictable state
3. **Status machine** for clear file states
4. **Composition** for maintainable components
5. **Custom hooks** for reusable logic
6. **Local test implementations** avoid JSX issues
7. **Color coding** provides instant visual feedback
8. **Progressive disclosure** shows relevant info

---

## Further Reading

- React Drag and Drop API
- File API (FileReader, Blob)
- Queue data structures
- State machine patterns
- Custom React hooks
