# REST API Design for Async Jobs - Learning Guide

## Overview
How to design REST APIs for asynchronous job processing.

## Key Concepts

### 1. HTTP 202 Accepted
For async operations:
```csharp
[HttpPost("invoice")]
public async Task<IActionResult> CreateInvoice(Request request)
{
    var jobId = await _queue.EnqueueAsync(request);

    return Accepted(new
    {
        jobId,
        status = "pending",
        message = "Job queued for processing"
    });
}
```

### 2. Status Polling Endpoint
```csharp
[HttpGet("status/{jobId}")]
public IActionResult GetStatus(string jobId)
{
    var status = _queue.GetJobStatus(jobId);

    if (status == null)
        return NotFound(new { error = "Job not found" });

    return Ok(status);
}
```

### 3. Response Evolution
```json
// Pending
{ "status": "pending", "createdAt": "..." }

// Processing
{ "status": "processing", "createdAt": "..." }

// Completed
{ "status": "completed", "result": {...}, "completedAt": "..." }

// Failed
{ "status": "failed", "error": "...", "completedAt": "..." }
```

### 4. Security Headers
```csharp
app.Use(async (context, next) =>
{
    context.Response.Headers.Append("X-Content-Type-Options", "nosniff");
    context.Response.Headers.Append("X-Frame-Options", "DENY");
    context.Response.Headers.Append("X-XSS-Protection", "1; mode=block");
    await next();
});
```

### 5. Request Logging
```csharp
_logger.LogInformation("Job {JobId} created for {Rfc}", jobId, rfc);
_logger.LogError(ex, "Job {JobId} failed", jobId);
```

## HTTP Status Codes

| Code | Usage |
|------|-------|
| 200 OK | Successful GET, status found |
| 202 Accepted | Request accepted, processing async |
| 400 Bad Request | Validation failure |
| 404 Not Found | Job/resource not found |
| 500 Server Error | Unexpected error |

## Polling Strategy

Client-side:
```javascript
async function waitForCompletion(jobId) {
    for (let i = 0; i < 30; i++) {
        const status = await getStatus(jobId);

        if (status.status === 'completed') return status;
        if (status.status === 'failed') throw new Error(status.error);

        await sleep(1000);
    }
    throw new Error('Timeout');
}
```

## Best Practices

1. **Use 202 for async** - Clear semantics
2. **Provide status endpoint** - For polling
3. **Include timestamps** - For debugging
4. **Structured errors** - JSON error responses
5. **Log with correlation** - Job ID in all logs
6. **Add security headers** - Defense in depth

## Model Validation
```csharp
public class CreateInvoiceRequest
{
    [Required]
    public string RfcEmisor { get; set; }

    [Range(0.01, double.MaxValue)]
    public decimal Total { get; set; }
}

// Controller checks ModelState
if (!ModelState.IsValid)
    return BadRequest(ModelState);
```

## Key Takeaways

1. 202 Accepted signals async processing
2. Status endpoint enables polling
3. Include job ID for correlation
4. Validation prevents bad data
5. Security headers are low-cost protection
6. Structured logging aids debugging
