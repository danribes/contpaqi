# T014.1 Split-Screen Layout - Guide

## What Was Developed

This subtask implements a **resizable split-screen layout** for the Human-in-the-Loop verification interface. The layout allows users to view a PDF invoice document side-by-side with the extracted data form, enabling efficient verification and correction of AI-extracted data.

## Why It Was Developed

### Business Need
When processing invoices with AI, users need to:
1. **Verify** extracted data against the original document
2. **Correct** any errors or low-confidence fields
3. **Cross-reference** specific sections quickly

A split-screen layout solves this by showing both the source (PDF) and result (form) simultaneously, eliminating context switching.

### Technical Requirements
- Flexible panel sizing for different screen sizes
- Support for mobile devices (single panel view)
- User control over panel proportions
- Smooth, responsive resizing

## How It Was Developed

### 1. Component Architecture

```
SplitScreenLayout
├── Toolbar (mode toggle)
├── Panels Container
│   ├── Left Panel (PDF)
│   │   ├── PanelHeader
│   │   └── Content (PDFPanelPlaceholder)
│   ├── ResizeDivider
│   └── Right Panel (Form)
│       ├── PanelHeader
│       └── Content (FormPanelPlaceholder)
```

### 2. State Management

The component uses a combination of:
- **Local state** for resize operations (`leftWidth`, `isDragging`)
- **Controlled/Uncontrolled pattern** for `mode` (can be controlled via props or internal)
- **Window resize listener** for responsive behavior

```typescript
// Width state with constraints
const [leftWidth, setLeftWidth] = useState(initialLeftWidth);

// Mode can be controlled externally or internally
const mode = controlledMode ?? internalMode;
```

### 3. Resize Implementation

The resize functionality uses mouse events:

```typescript
const handleDragStart = useCallback((e: React.MouseEvent) => {
  e.preventDefault();
  setIsDragging(true);

  const containerRect = container.getBoundingClientRect();
  const startX = e.clientX;
  const startWidth = leftWidth;

  const handleMouseMove = (moveEvent: MouseEvent) => {
    const deltaX = moveEvent.clientX - startX;
    const deltaPercent = (deltaX / containerRect.width) * 100;
    const newWidth = constrainWidth(startWidth + deltaPercent, min, max);
    setLeftWidth(newWidth);
  };

  document.addEventListener('mousemove', handleMouseMove);
  document.addEventListener('mouseup', handleMouseUp);
}, [leftWidth, minLeftWidth, maxLeftWidth]);
```

**Key technique**: Attach mouse events to `document` (not the divider) to capture movements even when cursor moves outside the divider.

### 4. Responsive Design

Breakpoint detection using window width:

```typescript
function getBreakpoint(width: number): Breakpoint {
  if (width < 640) return 'mobile';   // Tailwind sm
  if (width < 1024) return 'tablet';  // Tailwind lg
  return 'desktop';
}
```

Auto-switching on mobile:
```typescript
useEffect(() => {
  if (newBreakpoint === 'mobile' && mode === 'split') {
    handleModeChange('pdf-only'); // Switch to single panel on mobile
  }
}, [breakpoint, mode]);
```

### 5. Layout Modes

Three modes provide flexibility:

| Mode | Use Case |
|------|----------|
| `split` | Normal verification (both panels) |
| `pdf-only` | Focused document review |
| `form-only` | Data entry / keyboard navigation |

### 6. Tailwind CSS Styling

Dynamic width using Tailwind's arbitrary value syntax:
```typescript
const leftPanelStyle = mode === 'split'
  ? { width: `${leftWidth}%` }
  : mode === 'pdf-only'
    ? { width: '100%' }
    : { display: 'none' };
```

## Key Learnings

### 1. Controlled vs Uncontrolled Components
Supporting both patterns provides flexibility:
```typescript
const mode = controlledMode ?? internalMode;

const handleModeChange = (newMode: LayoutMode) => {
  if (onModeChange) onModeChange(newMode);  // Controlled
  else setInternalMode(newMode);             // Uncontrolled
};
```

### 2. Document-Level Event Listeners
For drag operations, always attach move/up listeners to `document`:
- Prevents losing track when cursor moves fast
- Ensures proper cleanup on mouse up

### 3. Width Constraints
Always clamp dynamic values:
```typescript
function constrainWidth(width: number, min: number, max: number): number {
  return Math.min(Math.max(width, min), max);
}
```

### 4. Placeholder Components
Creating placeholders for future features:
- Clearly documents what will be implemented
- Allows UI integration before feature completion
- Provides visual confirmation of layout

## Integration Example

```tsx
import { SplitScreenLayout, PDFPanelPlaceholder, FormPanelPlaceholder } from './components/SplitScreenLayout';

function VerificationView() {
  const [mode, setMode] = useState<LayoutMode>('split');

  return (
    <SplitScreenLayout
      leftPanel={<PDFPanelPlaceholder />}
      rightPanel={<FormPanelPlaceholder />}
      mode={mode}
      onModeChange={setMode}
      initialLeftWidth={50}
      minLeftWidth={25}
      maxLeftWidth={75}
    />
  );
}
```

## Future Enhancements

1. **Subtask 14.2**: Replace `PDFPanelPlaceholder` with react-pdf viewer
2. **Subtask 14.3**: Replace `FormPanelPlaceholder` with InvoiceForm
3. **Touch support**: Add touch events for mobile resize
4. **Keyboard resize**: Arrow keys to adjust panel width
5. **Preset layouts**: Save/load user's preferred layout
