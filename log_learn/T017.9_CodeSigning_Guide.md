# Learning Guide: Subtask 17.9 - Code Signing

## Overview

This guide explains how to code sign Windows executables, DLLs, and installers using Microsoft's signtool.exe and PowerShell automation.

## Why Code Signing?

Code signing provides:
1. **Authentication**: Proves software came from a known publisher
2. **Integrity**: Detects if code was modified after signing
3. **Trust**: Windows SmartScreen shows fewer warnings
4. **Compliance**: Required for many enterprise deployments

## Certificate Types

### Self-Signed (Development Only)
```powershell
# Create self-signed certificate
$cert = New-SelfSignedCertificate `
    -Type CodeSigningCert `
    -Subject "CN=My Company" `
    -KeyUsage DigitalSignature `
    -CertStoreLocation Cert:\CurrentUser\My

# Export to PFX
$password = ConvertTo-SecureString -String "P@ssw0rd" -Force -AsPlainText
Export-PfxCertificate -Cert $cert -FilePath "codesign.pfx" -Password $password
```

### Commercial Certificates
Purchase from Certificate Authorities:
- DigiCert
- Sectigo (Comodo)
- GlobalSign
- SSL.com

## Finding SignTool

SignTool is included in Windows SDK:

```powershell
# Common locations
$paths = @(
    "${env:ProgramFiles(x86)}\Windows Kits\10\bin\*\x64\signtool.exe",
    "${env:ProgramFiles(x86)}\Windows Kits\8.1\bin\x64\signtool.exe"
)

# Find latest version
$signtool = Get-ChildItem -Path $paths[0] -ErrorAction SilentlyContinue |
            Sort-Object { [version]$_.Directory.Name } -Descending |
            Select-Object -First 1 -ExpandProperty FullName
```

## SignTool Commands

### Basic Signing
```powershell
signtool sign /f "certificate.pfx" /p "password" "app.exe"
```

### With Timestamp (Recommended)
```powershell
signtool sign /f "certificate.pfx" /p "password" `
    /tr "http://timestamp.digicert.com" /td sha256 `
    "app.exe"
```

### Full Command with All Options
```powershell
signtool sign `
    /f "certificate.pfx" `       # Certificate file
    /p "password" `               # Certificate password
    /fd sha256 `                  # File digest algorithm
    /tr "http://timestamp.digicert.com" `  # RFC3161 timestamp
    /td sha256 `                  # Timestamp digest algorithm
    /d "Application Name" `       # Description
    /du "https://example.com" `   # URL
    "app.exe"
```

### SignTool Parameters
| Parameter | Description |
|-----------|-------------|
| `/f` | Path to PFX certificate file |
| `/p` | Certificate password |
| `/fd` | File digest algorithm (sha256, sha384, sha512) |
| `/t` | Legacy timestamp URL |
| `/tr` | RFC3161 timestamp URL |
| `/td` | Timestamp digest algorithm |
| `/d` | Description (shows in UAC dialog) |
| `/du` | Description URL |
| `/v` | Verbose output |

## Timestamp Servers

Always use timestamps to ensure signatures remain valid after certificate expires:

### RFC3161 Timestamp Servers
```
http://timestamp.digicert.com
http://timestamp.sectigo.com
http://timestamp.comodoca.com
http://tsa.starfieldtech.com
http://timestamp.globalsign.com
```

### Legacy vs RFC3161
```powershell
# Legacy (older, less secure)
signtool sign /t "http://timestamp.verisign.com/scripts/timstamp.dll" ...

# RFC3161 (recommended)
signtool sign /tr "http://timestamp.digicert.com" /td sha256 ...
```

## Verifying Signatures

### Using SignTool
```powershell
signtool verify /pa /v "app.exe"
```

### Using PowerShell
```powershell
$sig = Get-AuthenticodeSignature -FilePath "app.exe"

# Check status
$sig.Status           # Valid, NotSigned, HashMismatch, etc.
$sig.SignerCertificate.Subject
$sig.SignerCertificate.Issuer
$sig.TimeStamperCertificate.Subject
```

### Signature Statuses
| Status | Meaning |
|--------|---------|
| Valid | Signature is valid |
| NotSigned | File is not signed |
| HashMismatch | File was modified |
| NotTrusted | Certificate not trusted |
| UnknownError | Verification failed |

## Batch Signing

### Sign All EXE in Directory
```powershell
Get-ChildItem -Path ".\bin" -Filter "*.exe" | ForEach-Object {
    signtool sign /f "cert.pfx" /p "password" `
        /tr "http://timestamp.digicert.com" /td sha256 `
        $_.FullName
}
```

### Sign Multiple File Types
```powershell
$extensions = @("*.exe", "*.dll", "*.msi")

foreach ($ext in $extensions) {
    Get-ChildItem -Path ".\release" -Filter $ext -Recurse | ForEach-Object {
        signtool sign /f "cert.pfx" /p "password" `
            /tr "http://timestamp.digicert.com" /td sha256 `
            $_.FullName
    }
}
```

## Integration with Build Process

### MSBuild Post-Build Event
```xml
<Target Name="SignExecutable" AfterTargets="Build" Condition="'$(Configuration)' == 'Release'">
  <Exec Command="signtool sign /f $(CertPath) /p $(CertPassword) /tr http://timestamp.digicert.com /td sha256 $(TargetPath)" />
</Target>
```

### PowerShell Build Script
```powershell
# Build
dotnet publish -c Release

# Sign all outputs
$outputs = Get-ChildItem -Path ".\publish" -Include "*.exe","*.dll" -Recurse
foreach ($file in $outputs) {
    .\code-sign.ps1 -FilePath $file.FullName -CertPath "cert.pfx" -Password $env:CERT_PASSWORD
}
```

## Error Handling

### Common Errors
| Error | Cause | Solution |
|-------|-------|----------|
| File not found | Wrong path | Check file path |
| Certificate not found | Wrong cert path | Verify PFX location |
| Invalid password | Wrong password | Check certificate password |
| Timestamp failed | Server down | Try different timestamp server |
| Access denied | File locked | Close applications using file |

### Retry with Multiple Timestamp Servers
```powershell
$timestampServers = @(
    "http://timestamp.digicert.com",
    "http://timestamp.sectigo.com",
    "http://timestamp.comodoca.com"
)

foreach ($ts in $timestampServers) {
    $result = signtool sign /f "cert.pfx" /p "pwd" /tr $ts /td sha256 "app.exe" 2>&1
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Signed successfully with $ts"
        break
    }
}
```

## Security Best Practices

1. **Protect Private Key**: Never commit PFX files to source control
2. **Use Environment Variables**: Store passwords in secure environment
3. **Timestamp Always**: Ensures validity after certificate expires
4. **Use SHA-256+**: Avoid deprecated SHA-1 algorithm
5. **EV Certificates**: Extended Validation for SmartScreen reputation
6. **HSM Storage**: Hardware Security Modules for production

## Certificate Storage

### Environment Variable (CI/CD)
```powershell
$certBase64 = $env:CODE_SIGNING_CERT
$certPassword = $env:CODE_SIGNING_PASSWORD

# Decode and save temporarily
[System.IO.File]::WriteAllBytes("temp.pfx", [Convert]::FromBase64String($certBase64))

# Sign
signtool sign /f "temp.pfx" /p $certPassword ...

# Clean up
Remove-Item "temp.pfx" -Force
```

### Azure Key Vault
```powershell
# Sign using certificate in Azure Key Vault
signtool sign /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 `
    /kvu "https://myvault.vault.azure.net" `
    /kvc "MyCertificate" `
    "app.exe"
```

## Summary

Code signing involves:
1. Obtain a code signing certificate (PFX)
2. Install Windows SDK with signtool
3. Sign executables with timestamp
4. Verify signatures after signing

The `code-sign.ps1` script automates this process with support for:
- Single file or batch signing
- Multiple timestamp servers
- Signature verification
- Comprehensive error handling
