# T004.4 - Multi-Stage Docker Builds Guide

**Subtask**: 4.4 Implement multi-stage build for optimization
**Date**: 2025-12-05

---

## Learning Objectives

After completing this guide, you will understand:
1. What multi-stage builds are and why they matter
2. How to structure a multi-stage Dockerfile
3. Best practices for Docker image optimization
4. Security considerations for production containers

---

## 1. Understanding Multi-Stage Builds

### What is a Multi-Stage Build?

A multi-stage build uses multiple `FROM` instructions in a single Dockerfile. Each `FROM` starts a new build stage, and you can selectively copy artifacts from one stage to another.

### Why Use Multi-Stage Builds?

```
Traditional Build:
┌─────────────────────────────────┐
│         Single Stage            │
│  - Base image                   │
│  - Build tools (gcc, make)      │
│  - Source code                  │
│  - Compiled artifacts           │
│  - Runtime dependencies         │
│  = LARGE IMAGE (~3GB+)          │
└─────────────────────────────────┘

Multi-Stage Build:
┌─────────────────────────────────┐
│       Builder Stage             │
│  - Build tools                  │
│  - Source code                  │
│  - Compiled artifacts ─────────┐│
│  (DISCARDED)                   ││
└────────────────────────────────┘│
                                  │
┌─────────────────────────────────┘
│       Runtime Stage             │
│  - Minimal base image           │
│  - Runtime dependencies only    │
│  - Compiled artifacts           │
│  = SMALLER IMAGE (~1.5GB)       │
└─────────────────────────────────┘
```

---

## 2. Multi-Stage Build Syntax

### Basic Structure

```dockerfile
# Stage 1: Builder
FROM python:3.9-slim-bullseye as builder
# Build operations here...

# Stage 2: Runtime
FROM python:3.9-slim-bullseye
# Copy from builder and run
COPY --from=builder /app/output /app/output
```

### Key Syntax Elements

| Syntax | Purpose |
|--------|---------|
| `FROM ... as name` | Name the build stage |
| `COPY --from=name` | Copy from named stage |
| `--from=0` | Copy from stage by index |

---

## 3. Python Wheel Pattern

### What are Wheels?

Wheels (`.whl` files) are pre-compiled Python packages that install faster than source distributions.

### Wheel Build Pattern

```dockerfile
# Builder: Create wheels
FROM python:3.9-slim-bullseye as builder

RUN apt-get update && apt-get install -y \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip wheel --no-cache-dir --no-deps \
    --wheel-dir /app/wheels \
    -r requirements.txt

# Runtime: Install from wheels
FROM python:3.9-slim-bullseye

COPY --from=builder /app/wheels /wheels
RUN pip install --no-cache /wheels/*
```

### Benefits of Wheel Pattern

1. **No Build Tools in Runtime**: gcc, make not needed
2. **Faster Installs**: Pre-compiled, no compilation step
3. **Reproducibility**: Same binary every time
4. **Smaller Images**: No build artifacts left behind

---

## 4. Layer Caching Strategy

### How Docker Caching Works

```
Layer 1: FROM python:3.9-slim    [CACHED if same]
Layer 2: RUN apt-get install...  [CACHED if Layer 1 unchanged]
Layer 3: COPY requirements.txt   [CACHED if file unchanged]
Layer 4: RUN pip install         [CACHED if Layer 3 unchanged]
Layer 5: COPY src/               [REBUILT if code changed]
```

### Optimal Layer Order

```dockerfile
# 1. Rarely changing base
FROM python:3.9-slim-bullseye

# 2. System dependencies (change rarely)
RUN apt-get update && apt-get install -y ...

# 3. Python dependencies (change occasionally)
COPY requirements.txt .
RUN pip install -r requirements.txt

# 4. Application code (changes often)
COPY src/ ./src/

# 5. Runtime config (changes rarely)
CMD ["uvicorn", "src.main:app"]
```

**Rule**: Put frequently changing layers at the end!

---

## 5. Security Best Practices

### Non-Root User

```dockerfile
# Create user with home directory
RUN useradd -m appuser

# Set ownership
RUN chown -R appuser:appuser /app

# Switch to non-root
USER appuser
```

### Why Non-Root?

| Risk | Mitigation |
|------|------------|
| Container escape | Limited privileges |
| File system tampering | Restricted write access |
| Network exposure | Reduced attack surface |

### Secure Defaults

```dockerfile
# Remove setuid/setgid bits
RUN find / -perm +6000 -type f -exec chmod a-s {} \; || true

# No shell for service user
RUN useradd -M -s /sbin/nologin appuser
```

---

## 6. Health Checks

### HEALTHCHECK Instruction

```dockerfile
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1
```

### Parameters Explained

| Parameter | Default | Purpose |
|-----------|---------|---------|
| `--interval` | 30s | Time between checks |
| `--timeout` | 30s | Time to wait for response |
| `--start-period` | 0s | Grace period on startup |
| `--retries` | 3 | Failures before unhealthy |

### Health Check States

```
Starting → Healthy → Unhealthy
           ↑         │
           └─────────┘ (recovers)
```

---

## 7. CMD vs ENTRYPOINT

### Differences

```dockerfile
# CMD: Default command, can be overridden
CMD ["uvicorn", "src.main:app", "--host", "0.0.0.0"]
# docker run image other-command  # Replaces CMD

# ENTRYPOINT: Always runs, CMD becomes arguments
ENTRYPOINT ["uvicorn"]
CMD ["src.main:app", "--host", "0.0.0.0"]
# docker run image --port 9000  # Adds to ENTRYPOINT
```

### Exec Form vs Shell Form

```dockerfile
# Exec form (preferred) - signals handled properly
CMD ["uvicorn", "src.main:app"]

# Shell form - runs in /bin/sh -c, signals issues
CMD uvicorn src.main:app
```

**Always use exec form** for proper signal handling (SIGTERM, etc.)

---

## 8. Image Size Optimization

### Techniques

#### 1. Use Slim Base Images
```dockerfile
# Bad: Full image (~900MB)
FROM python:3.9

# Good: Slim image (~120MB)
FROM python:3.9-slim

# Better: Alpine (~50MB, but compatibility issues)
FROM python:3.9-alpine
```

#### 2. Combine RUN Commands
```dockerfile
# Bad: Multiple layers
RUN apt-get update
RUN apt-get install package1
RUN apt-get install package2

# Good: Single layer
RUN apt-get update && apt-get install -y \
    package1 \
    package2 \
    && rm -rf /var/lib/apt/lists/*
```

#### 3. Clean Up in Same Layer
```dockerfile
# Bad: Cleanup in separate layer doesn't reduce size
RUN apt-get install ...
RUN rm -rf /var/lib/apt/lists/*

# Good: Cleanup in same layer
RUN apt-get install ... \
    && rm -rf /var/lib/apt/lists/*
```

#### 4. Use --no-cache Flags
```dockerfile
RUN pip install --no-cache-dir package
```

---

## 9. Multi-Stage Build Patterns

### Pattern 1: Builder Pattern (Used Here)

```dockerfile
FROM base as builder
# Build artifacts

FROM base
COPY --from=builder /artifacts /artifacts
```

### Pattern 2: Test Stage

```dockerfile
FROM base as builder
# Build

FROM builder as tester
RUN pytest

FROM base as runtime
COPY --from=builder /app /app
```

### Pattern 3: Development vs Production

```dockerfile
FROM base as base-stage
# Common setup

FROM base-stage as development
# Dev tools, debugger

FROM base-stage as production
# Optimized, minimal
```

---

## 10. Debugging Multi-Stage Builds

### Build Specific Stage

```bash
# Build only the builder stage
docker build --target builder -t myapp:builder .

# Inspect what's in the stage
docker run -it myapp:builder /bin/bash
```

### View Layer Sizes

```bash
# See layer breakdown
docker history myimage:latest

# Detailed layer info
docker inspect myimage:latest
```

### Build with Progress

```bash
docker build --progress=plain -t myimage .
```

---

## 11. Common Pitfalls

### Pitfall 1: Copying Too Much

```dockerfile
# Bad: Copies everything including .git, __pycache__
COPY . .

# Good: Copy only what's needed
COPY requirements.txt .
COPY src/ ./src/
```

**Solution**: Use `.dockerignore`:
```
.git
__pycache__
*.pyc
.env
node_modules
```

### Pitfall 2: Not Cleaning Cache

```dockerfile
# Bad: Cache left in image
RUN apt-get update && apt-get install -y package

# Good: Clean cache
RUN apt-get update && apt-get install -y package \
    && rm -rf /var/lib/apt/lists/*
```

### Pitfall 3: Wrong Layer Order

```dockerfile
# Bad: Code copy invalidates pip cache
COPY . .
RUN pip install -r requirements.txt

# Good: Dependencies first
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
```

---

## 12. Summary

### Best Practices Checklist

- [ ] Use multi-stage builds
- [ ] Separate build and runtime dependencies
- [ ] Use wheel packages for Python
- [ ] Order layers by change frequency
- [ ] Use slim base images
- [ ] Combine RUN commands
- [ ] Clean caches in same layer
- [ ] Run as non-root user
- [ ] Use exec form for CMD
- [ ] Implement health checks
- [ ] Use `.dockerignore`

### Quick Reference

```dockerfile
# Multi-stage Python template
FROM python:3.9-slim as builder
WORKDIR /app
RUN apt-get update && apt-get install -y build-essential && rm -rf /var/lib/apt/lists/*
COPY requirements.txt .
RUN pip wheel --no-cache-dir --wheel-dir /wheels -r requirements.txt

FROM python:3.9-slim
WORKDIR /app
COPY --from=builder /wheels /wheels
RUN pip install --no-cache /wheels/* && rm -rf /wheels
COPY src/ ./src/
RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser
EXPOSE 8000
HEALTHCHECK CMD curl -f http://localhost:8000/health || exit 1
CMD ["uvicorn", "src.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

---

## Further Reading

1. [Docker Multi-Stage Builds](https://docs.docker.com/build/building/multi-stage/)
2. [Docker Best Practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
3. [Python Wheels Documentation](https://wheel.readthedocs.io/)
4. [Container Security Best Practices](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html)
