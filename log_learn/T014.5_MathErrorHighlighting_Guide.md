# T014.5 - Math Error Highlighting Learning Guide

**Subtask**: 14.5 - Implement math error highlighting (red)
**Date**: 2025-12-09
**Type**: Financial Validation & UI Feedback

---

## Overview

This guide covers implementing real-time mathematical validation for financial data with visual error highlighting, specifically for Mexican invoice calculations.

---

## Key Concepts

### 1. Mexican Invoice Math Rules

Mexican invoices (CFDI) have specific calculation requirements:

```
IVA (Impuesto al Valor Agregado) = Subtotal × 16%
Total = Subtotal + IVA
Line Item Amount = Quantity × Unit Price
```

### 2. Tolerance-Based Comparison

Financial calculations often have rounding issues. Use tolerance:

```typescript
const DEFAULT_TOLERANCE = 0.01; // 1 cent

function isWithinTolerance(
  actual: number,
  expected: number,
  tolerance: number = DEFAULT_TOLERANCE
): boolean {
  // Add epsilon for floating point precision
  const epsilon = 1e-10;
  return Math.abs(actual - expected) <= tolerance + epsilon;
}
```

**Why epsilon?** JavaScript floating point math can produce:
```javascript
100.01 - 100 = 0.010000000000005116  // Not exactly 0.01
```

### 3. Real-time Validation with useMemo

Use `useMemo` for efficient real-time validation:

```typescript
const mathValidation = useMemo(() => {
  const subtotal = parseFloat(formState.subtotal.value) || 0;
  const iva = parseFloat(formState.iva.value) || 0;
  const total = parseFloat(formState.total.value) || 0;

  return validateInvoiceMath({ subtotal, iva, total });
}, [formState.subtotal.value, formState.iva.value, formState.total.value]);
```

---

## Implementation Patterns

### 1. Structured Error Response

```typescript
interface MathError {
  field: string;      // Which field has the error
  message: string;    // Human-readable message
  expected: number;   // What the value should be
  actual: number;     // What the value currently is
  difference: number; // How far off it is
}

interface MathValidationResult {
  isValid: boolean;
  errors: MathError[];
}
```

### 2. Individual Field Validation

Separate validation functions for each rule:

```typescript
function validateIva(subtotal: number, iva: number): MathError | null {
  const expectedIva = Math.round(subtotal * 0.16 * 100) / 100;

  if (!isWithinTolerance(iva, expectedIva)) {
    return {
      field: 'iva',
      message: `IVA should be 16% of subtotal ($${expectedIva.toFixed(2)})`,
      expected: expectedIva,
      actual: iva,
      difference: Math.round((iva - expectedIva) * 100) / 100,
    };
  }
  return null;
}
```

### 3. Aggregate Validation

Combine individual validations:

```typescript
function validateInvoiceMath(amounts: InvoiceAmounts): MathValidationResult {
  const errors: MathError[] = [];

  const ivaError = validateIva(amounts.subtotal, amounts.iva);
  if (ivaError) errors.push(ivaError);

  const totalError = validateTotal(amounts.subtotal, amounts.iva, amounts.total);
  if (totalError) errors.push(totalError);

  return {
    isValid: errors.length === 0,
    errors,
  };
}
```

---

## Visual Highlighting Design

### Color Strategy

| State | Border | Background | Ring | Purpose |
|-------|--------|------------|------|---------|
| Normal | gray-300 | white | none | Default |
| Error | red-500 | red-50 | red-300 | Math error |

### Tailwind Classes

```typescript
function getMathErrorHighlightClass(hasError: boolean): string {
  return hasError
    ? 'border-red-500 bg-red-50 ring-2 ring-red-300'
    : '';
}
```

### Priority Order

When multiple states apply:
1. **Math Error** (highest priority - red)
2. **Form Validation Error** (red)
3. **Low Confidence** (red)
4. **Medium Confidence** (orange)
5. **High Confidence** (green)
6. **Normal** (gray)

```typescript
const borderColor = hasMathError
  ? 'border-red-500'
  : hasFormError
  ? 'border-red-500'
  : confidenceLevel
  ? getConfidenceColor(confidenceLevel)
  : 'border-gray-300';
```

---

## Component Patterns

### 1. Error Banner Component

```tsx
function MathErrorBanner({ errors }) {
  if (errors.length === 0) return null;

  return (
    <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
      <div className="flex items-start gap-2">
        <AlertIcon />
        <div>
          <p className="font-bold">Math Validation Errors</p>
          <ul className="list-disc list-inside text-sm">
            {errors.map((error, i) => (
              <li key={i}>
                <strong>{error.field}:</strong> {error.message}
              </li>
            ))}
          </ul>
        </div>
      </div>
    </div>
  );
}
```

### 2. Calculation Helper Component

Assist users with correct values:

```tsx
function CalculationHelper({ subtotal, onAutoCalculate }) {
  const expectedIva = Math.round(subtotal * 0.16 * 100) / 100;
  const expectedTotal = subtotal + expectedIva;

  return (
    <div className="bg-blue-50 border border-blue-200 rounded p-3">
      <div className="flex justify-between items-center">
        <div>
          <p>Expected IVA (16%): <strong>${expectedIva.toFixed(2)}</strong></p>
          <p>Expected Total: <strong>${expectedTotal.toFixed(2)}</strong></p>
        </div>
        <button
          onClick={() => onAutoCalculate(expectedIva, expectedTotal)}
          className="px-3 py-1 bg-blue-600 text-white rounded"
        >
          Auto-fill
        </button>
      </div>
    </div>
  );
}
```

### 3. Form Field with Error State

```tsx
function FormFieldInput({ label, value, error, mathError, ...props }) {
  const hasMathError = !!mathError;

  return (
    <div className="mb-4">
      <label>
        {label}
        {hasMathError && <span className="text-red-500 text-xs ml-2">(Math error)</span>}
      </label>
      <input
        value={value}
        className={`border-2 rounded ${hasMathError ? 'border-red-500 bg-red-50' : ''}`}
        {...props}
      />
      {mathError && (
        <p className="text-red-600 text-xs mt-1">
          <ErrorIcon /> {mathError}
        </p>
      )}
    </div>
  );
}
```

---

## Testing Strategy

### 1. Pure Function Tests

```typescript
describe('validateIva', () => {
  it('should pass for correct 16% IVA', () => {
    expect(validateIva(10000, 1600)).toBeNull();
  });

  it('should fail for incorrect IVA', () => {
    const error = validateIva(10000, 1500);
    expect(error).not.toBeNull();
    expect(error.expected).toBe(1600);
    expect(error.actual).toBe(1500);
  });
});
```

### 2. Tolerance Edge Cases

```typescript
describe('tolerance handling', () => {
  it('should accept value at boundary', () => {
    // 10000 * 0.16 = 1600, allow 1600.01
    expect(validateIva(10000, 1600.01)).toBeNull();
  });

  it('should reject value beyond tolerance', () => {
    expect(validateIva(10000, 1600.02)).not.toBeNull();
  });
});
```

### 3. Real-time Validation Flow

```typescript
describe('real-time validation', () => {
  it('should detect error as user types', () => {
    let amounts = { subtotal: 10000, iva: 0, total: 0 };

    // Initially invalid (IVA and total wrong)
    let result = validateInvoiceMath(amounts);
    expect(result.isValid).toBe(false);

    // User types correct IVA
    amounts.iva = 1600;
    result = validateInvoiceMath(amounts);
    expect(result.errors.some(e => e.field === 'iva')).toBe(false);

    // User types correct total
    amounts.total = 11600;
    result = validateInvoiceMath(amounts);
    expect(result.isValid).toBe(true);
  });
});
```

---

## Common Patterns

### Currency Formatting (Mexican Locale)

```typescript
function formatCurrency(amount: number): string {
  return `$${amount.toLocaleString('es-MX', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  })}`;
}

// Examples:
formatCurrency(1000)      // "$1,000.00"
formatCurrency(1234.56)   // "$1,234.56"
formatCurrency(1000000)   // "$1,000,000.00"
```

### Currency Parsing

```typescript
function parseCurrency(value: string): number {
  const cleaned = value.replace(/[$,\s]/g, '');
  const parsed = parseFloat(cleaned);
  return isNaN(parsed) ? 0 : parsed;
}

// Examples:
parseCurrency('$1,000.00')  // 1000
parseCurrency('1234.56')    // 1234.56
parseCurrency('invalid')    // 0
```

### Rounding to 2 Decimals

```typescript
function roundCurrency(amount: number): number {
  return Math.round(amount * 100) / 100;
}

// Important for calculations:
const iva = roundCurrency(subtotal * 0.16);  // Prevent floating point issues
```

---

## Best Practices

1. **Validate in real-time** - Use useMemo for responsive feedback
2. **Show expected values** - Help users understand correct amounts
3. **Provide auto-fill** - Let users quickly correct errors
4. **Use tolerance** - Account for rounding differences
5. **Handle floating point** - Add epsilon to comparisons
6. **Prioritize errors** - Math errors above confidence
7. **Clear error messages** - Include expected values

---

## Related Resources

- Mexican SAT (Tax Administration) guidelines
- CFDI (Digital Tax Invoice) specifications
- IEEE 754 floating point standard
- React useMemo optimization patterns
