# T018.7 - Language Persistence Guide

**Subtask**: 18.7 - Persist language preference across sessions
**Topic**: Persisting User Preferences in Electron Apps

---

## Overview

This guide covers how to persist language preferences in an Electron application using multiple storage mechanisms: localStorage (renderer), Windows Registry (system), and system locale detection.

---

## Prerequisites

- Electron application with main/renderer process separation
- react-i18next for internationalization
- Understanding of IPC (Inter-Process Communication)

---

## Architecture

### Storage Layers

```
┌─────────────────────────────────────────────────────────────┐
│                     Renderer Process                         │
│  ┌──────────────┐                                           │
│  │ localStorage │  ← User's explicit preference              │
│  │  (i18nextLng)│                                           │
│  └──────────────┘                                           │
└─────────────────────────────────────────────────────────────┘
                            │
                      IPC Channel
                            │
┌─────────────────────────────────────────────────────────────┐
│                      Main Process                            │
│  ┌──────────────┐     ┌──────────────┐                      │
│  │   Registry   │     │ System Locale│                      │
│  │ (Windows)    │     │ (app.getLocale) │                   │
│  └──────────────┘     └──────────────┘                      │
└─────────────────────────────────────────────────────────────┘
```

### Priority Order

1. **localStorage** - User's explicit preference (highest priority)
2. **Registry** - Installer's language selection
3. **System Locale** - Operating system language
4. **Default** - Fallback to English

---

## Windows Registry Operations

### Registry Path

```typescript
const REGISTRY_CONFIG = {
  KEY: 'HKCU\\Software\\ContPAQi\\AIBridge',
  VALUE_NAME: 'Language',
  VALUE_TYPE: 'REG_SZ',
};
```

### Reading from Registry

Use the Windows `reg.exe` command:

```typescript
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

async function readRegistry(key: string, valueName: string): Promise<string | null> {
  try {
    const command = `reg query "${key}" /v "${valueName}"`;
    const { stdout } = await execAsync(command);

    // Parse output: "    Language    REG_SZ    es"
    const match = stdout.match(/REG_SZ\s+(.+)/);
    return match ? match[1].trim() : null;
  } catch {
    return null; // Key or value not found
  }
}
```

### Writing to Registry

```typescript
async function writeRegistry(key: string, valueName: string, value: string): Promise<boolean> {
  try {
    // /f forces overwrite without prompt
    const command = `reg add "${key}" /v "${valueName}" /t REG_SZ /d "${value}" /f`;
    await execAsync(command);
    return true;
  } catch {
    return false;
  }
}
```

---

## IPC Communication Pattern

### Main Process (language-manager.ts)

```typescript
import { ipcMain, app } from 'electron';

export function registerLanguageIpcHandlers(): void {
  // Read from registry
  ipcMain.handle('language:getFromRegistry', async () => {
    return await getLanguageFromRegistry();
  });

  // Write to registry
  ipcMain.handle('language:setToRegistry', async (_event, language: string) => {
    return await setLanguageToRegistry(language);
  });

  // Get system locale
  ipcMain.handle('language:getSystemLocale', () => {
    return app.getLocale();
  });
}
```

### Preload Script (preload.ts)

```typescript
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electronAPI', {
  getRegistryLanguage: () => ipcRenderer.invoke('language:getFromRegistry'),
  setRegistryLanguage: (lang: string) => ipcRenderer.invoke('language:setToRegistry', lang),
  getSystemLocale: () => ipcRenderer.invoke('language:getSystemLocale'),
});
```

### TypeScript Types

```typescript
declare global {
  interface Window {
    electronAPI: {
      getRegistryLanguage: () => Promise<string | null>;
      setRegistryLanguage: (lang: string) => Promise<{ success: boolean; error?: string }>;
      getSystemLocale: () => Promise<string>;
    };
  }
}
```

---

## Renderer Integration

### Loading Language on Startup

```typescript
// i18n/index.ts
export async function initializeLanguagePreference(): Promise<void> {
  // Check localStorage first
  const savedLang = localStorage.getItem('i18nextLng');
  if (savedLang && isLanguageSupported(savedLang)) {
    return; // Already have user preference
  }

  // Try registry (installer preference)
  const registryLang = await loadLanguageFromRegistry();
  if (registryLang) {
    await changeLanguage(registryLang);
    return;
  }

  // Fall back to system locale detection
  // (handled by i18next's LanguageDetector)
}

export async function loadLanguageFromRegistry(): Promise<string | null> {
  try {
    const electronAPI = window.electronAPI;
    if (electronAPI?.getRegistryLanguage) {
      const lang = await electronAPI.getRegistryLanguage();
      if (lang && isLanguageSupported(lang)) {
        return lang;
      }
    }
  } catch (error) {
    console.warn('Failed to load language from registry:', error);
  }
  return null;
}
```

### Saving Language Preference

```typescript
export async function changeLanguage(lng: string): Promise<void> {
  // Update i18next
  await i18n.changeLanguage(lng);

  // Save to localStorage
  localStorage.setItem('i18nextLng', lng);

  // Optionally save to registry for system-wide persistence
  try {
    await window.electronAPI?.setRegistryLanguage(lng);
  } catch {
    // Registry save is optional, don't fail if it errors
  }
}
```

---

## Locale Normalization

### Handling Different Formats

Locales come in various formats:
- Full: `en-US`, `es-MX`
- Underscore: `en_US`, `es_MX`
- Simple: `en`, `es`

```typescript
function normalizeLanguageCode(locale: string): 'en' | 'es' {
  if (!locale) return 'en';

  // Extract primary language
  const primaryLang = locale.split(/[-_]/)[0].toLowerCase();

  // Map to supported language
  return primaryLang === 'es' ? 'es' : 'en';
}
```

### System Locale Detection

```typescript
function getSystemLanguage(): 'en' | 'es' {
  const locale = app.getLocale(); // e.g., "en-US", "es-MX"
  return normalizeLanguageCode(locale);
}
```

---

## Error Handling

### Registry Errors

```typescript
type RegistryErrorCode =
  | 'KEY_NOT_FOUND'
  | 'VALUE_NOT_FOUND'
  | 'ACCESS_DENIED'
  | 'WRITE_FAILED'
  | 'NOT_WINDOWS';

function handleRegistryError(error: Error): RegistryErrorCode {
  const message = error.message;

  if (message.includes('not find')) return 'KEY_NOT_FOUND';
  if (message.includes('Access is denied')) return 'ACCESS_DENIED';
  return 'UNKNOWN_ERROR';
}
```

### Graceful Degradation

```typescript
async function resolveLanguagePreference(): Promise<string> {
  // Try each source in order, skip on error

  try {
    const localStorage = window.localStorage.getItem('i18nextLng');
    if (localStorage && isValid(localStorage)) return localStorage;
  } catch {}

  try {
    const registry = await window.electronAPI?.getRegistryLanguage();
    if (registry && isValid(registry)) return registry;
  } catch {}

  try {
    const locale = await window.electronAPI?.getSystemLocale();
    return normalizeLanguageCode(locale);
  } catch {}

  return 'en'; // Final fallback
}
```

---

## Platform Considerations

### Windows

- Registry available at `HKCU\Software\ContPAQi\AIBridge`
- Use `reg.exe` for registry operations
- Installer can pre-set language preference

### macOS/Linux

- No registry available
- Fall back to localStorage and system locale
- `app.getLocale()` works cross-platform

```typescript
function isWindows(): boolean {
  return process.platform === 'win32';
}

async function getLanguageFromRegistry(): Promise<string | null> {
  if (!isWindows()) return null;
  // Windows-specific registry code
}
```

---

## Testing Strategies

### Mock Registry Operations

```typescript
describe('Registry Operations', () => {
  const mockRegistry: Record<string, string> = {};

  function mockRead(key: string, value: string) {
    return mockRegistry[`${key}\\${value}`] || null;
  }

  function mockWrite(key: string, value: string, data: string) {
    mockRegistry[`${key}\\${value}`] = data;
  }

  beforeEach(() => {
    Object.keys(mockRegistry).forEach(k => delete mockRegistry[k]);
  });

  it('should read written value', () => {
    mockWrite('HKCU\\Test', 'Lang', 'es');
    expect(mockRead('HKCU\\Test', 'Lang')).toBe('es');
  });
});
```

### Test Priority Resolution

```typescript
describe('Language Priority', () => {
  it('should prefer localStorage over registry', async () => {
    const result = resolveLanguagePreference({
      localStorage: 'es',
      registry: 'en',
      systemLocale: 'fr-FR',
    });
    expect(result.language).toBe('es');
    expect(result.source).toBe('localStorage');
  });
});
```

---

## Best Practices

### 1. Always Validate Language Codes

```typescript
const SUPPORTED_LANGUAGES = ['en', 'es'] as const;
type SupportedLanguage = typeof SUPPORTED_LANGUAGES[number];

function isSupported(lang: string): lang is SupportedLanguage {
  return SUPPORTED_LANGUAGES.includes(lang as SupportedLanguage);
}
```

### 2. Log Language Resolution

```typescript
console.log(`[i18n] Language resolved: ${lang} (source: ${source})`);
```

### 3. Handle Async Properly

```typescript
// In App.tsx or main entry
useEffect(() => {
  initializeLanguagePreference().catch(console.error);
}, []);
```

### 4. Provide Fallbacks

Never let the app fail due to language loading errors.

---

## Files Reference

| File | Purpose |
|------|---------|
| `electron/language-manager.ts` | Main process language operations |
| `electron/preload.ts` | IPC bridge for renderer |
| `electron/main.ts` | App initialization |
| `src/i18n/index.ts` | i18next configuration |
| `tests/language-manager.test.ts` | Unit tests |

---

## Related Tasks

- **Task 18.1**: Installer language selection
- **Task 18.2**: i18n framework setup
- **Task 18.6**: Language switcher component
- **Task 18.8**: Update installer scripts with localized messages
