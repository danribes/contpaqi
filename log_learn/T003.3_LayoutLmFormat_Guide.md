# T003.3 - LayoutLMv3 Data Preparation Guide

## Overview

This guide covers the implementation of LayoutLMv3 data preparation for token classification training. LayoutLMv3 is a multimodal model that combines text, layout, and image information for document understanding tasks.

---

## Key Concepts

### BIO Tagging

BIO (Beginning-Inside-Outside) is a standard sequence labeling format:

| Tag | Meaning | Example |
|-----|---------|---------|
| B-ENTITY | Beginning of entity | First token of "RFC_EMISOR" |
| I-ENTITY | Inside/continuation | Subsequent tokens |
| O | Outside any entity | Non-entity tokens |

### Why BIO Format?

1. **Multi-token entities**: Handles entities spanning multiple tokens
2. **Adjacent entities**: Distinguishes between consecutive entities of same type
3. **Standard format**: Compatible with most NER training frameworks

---

## LayoutLM Input Format

### Sample Structure

```json
{
  "tokens": ["Invoice", "XAXX010101ABC", "Total:", "$1,160.00"],
  "bboxes": [[50, 100, 120, 130], [200, 100, 350, 130], ...],
  "ner_tags": [0, 1, 0, 5],
  "image_path": "invoice_00001.png"
}
```

### Field Descriptions

| Field | Type | Description |
|-------|------|-------------|
| tokens | string[] | OCR-extracted text tokens |
| bboxes | int[][] | Normalized bounding boxes [x1, y1, x2, y2] |
| ner_tags | int[] | Label indices (from label list) |
| image_path | string | Path to corresponding image |

### Bounding Box Normalization

LayoutLM expects bboxes normalized to 0-1000 scale:

```python
def normalize_bbox_layoutlm(bbox, width, height):
    x1, y1, x2, y2 = bbox
    return [
        int(x1 * 1000 / width),
        int(y1 * 1000 / height),
        int(x2 * 1000 / width),
        int(y2 * 1000 / height)
    ]
```

---

## Entity Types for Mexican Invoices

| Entity | Description | Example |
|--------|-------------|---------|
| RFC_EMISOR | Issuer tax ID | XAXX010101ABC |
| RFC_RECEPTOR | Recipient tax ID | XEXX010101000 |
| TOTAL | Invoice total | $1,160.00 |
| SUBTOTAL | Before tax amount | $1,000.00 |
| IVA | Tax amount (16%) | $160.00 |
| DATE | Invoice date | 15/03/2024 |
| INVOICE_NUMBER | Invoice number | INV-2024-001 |
| COMPANY_NAME | Company name | Empresa SA de CV |

---

## Pipeline Architecture

```
PDF Input → Image Conversion → OCR Extraction → Token Matching → BIO Tagging → LayoutLM Format
```

### Step 1: PDF to Image

```python
from pdf2image import convert_from_path

images = convert_from_path(pdf_path, dpi=300)
image = images[0]  # First page
```

### Step 2: OCR Token Extraction

```python
import pytesseract

def get_ocr_tokens(image):
    ocr_data = pytesseract.image_to_data(
        image,
        output_type=pytesseract.Output.DICT
    )

    tokens = []
    for i in range(len(ocr_data['text'])):
        text = ocr_data['text'][i].strip()
        if text:
            bbox = [
                ocr_data['left'][i],
                ocr_data['top'][i],
                ocr_data['left'][i] + ocr_data['width'][i],
                ocr_data['top'][i] + ocr_data['height'][i]
            ]
            tokens.append({'text': text, 'bbox': bbox})

    return tokens
```

### Step 3: Token Matching

```python
def match_token_to_field(token_text, ground_truth):
    fields = ground_truth.get('fields', {})

    # Direct match for RFCs
    if fields.get('rfc_emisor') == token_text:
        return 'RFC_EMISOR'

    # Numeric match with formatting
    total = fields.get('total')
    if total:
        clean = token_text.replace(',', '').replace('$', '')
        if clean == f"{total:.2f}":
            return 'TOTAL'

    return None  # O tag
```

### Step 4: BIO Tag Creation

```python
def create_bio_tags(tokens, ground_truth, label_list):
    tags = []
    prev_entity = None

    for token in tokens:
        entity = match_token_to_field(token['text'], ground_truth)

        if entity is None:
            tags.append(label_list.index('O'))
            prev_entity = None
        elif entity != prev_entity:
            tags.append(label_list.index(f'B-{entity}'))
            prev_entity = entity
        else:
            tags.append(label_list.index(f'I-{entity}'))

    return tags
```

---

## Label List

Complete label list for Mexican invoice extraction:

```python
LABEL_LIST = [
    "O",
    "B-RFC_EMISOR", "I-RFC_EMISOR",
    "B-RFC_RECEPTOR", "I-RFC_RECEPTOR",
    "B-TOTAL", "I-TOTAL",
    "B-SUBTOTAL", "I-SUBTOTAL",
    "B-IVA", "I-IVA",
    "B-DATE", "I-DATE",
    "B-INVOICE_NUMBER", "I-INVOICE_NUMBER",
    "B-COMPANY_NAME", "I-COMPANY_NAME"
]
```

---

## Output Structure

```
data/formatted/layoutlm/
├── images/
│   ├── invoice_00000.png
│   ├── invoice_00001.png
│   └── ...
├── samples.json    # List of LayoutLM samples
└── labels.json     # Label mapping
```

---

## Usage

```bash
# Convert synthetic data to LayoutLM format
python scripts/prepare_datasets.py \
    --input-dir data/synthetic \
    --output-dir data/formatted \
    --format layoutlm
```

---

## Common Issues & Solutions

### Issue: Empty Token List

**Cause**: OCR failed or returned no text
**Solution**: Check image quality, ensure tesseract is installed

### Issue: No Entities Matched

**Cause**: OCR text differs from ground truth
**Solution**: Use fuzzy matching or normalize both strings

### Issue: Incorrect BBox Scale

**Cause**: Not normalized to 0-1000 range
**Solution**: Always apply `normalize_bbox_layoutlm()`

---

## Dependencies

| Package | Purpose |
|---------|---------|
| pytesseract | Python wrapper for Tesseract OCR |
| tesseract-ocr | OCR engine (system package) |
| pdf2image | PDF to image conversion |
| Pillow | Image processing |

---

## Best Practices

1. **Image Quality**: Use 300 DPI for OCR accuracy
2. **Token Normalization**: Strip whitespace, handle encoding
3. **Validation**: Verify label indices are within bounds
4. **Consistency**: Ensure all samples have same label list

---

## References

- [LayoutLMv3 Paper](https://arxiv.org/abs/2204.08387)
- [Hugging Face LayoutLM](https://huggingface.co/docs/transformers/model_doc/layoutlmv3)
- [BIO Tagging](https://en.wikipedia.org/wiki/Inside%E2%80%93outside%E2%80%93beginning_(tagging))
