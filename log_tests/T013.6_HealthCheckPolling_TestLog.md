# T013.6 Health Check Polling - Test Log

## Test Execution Summary
**Date**: 2025-12-07
**Tests**: 32 passed | **Status**: Complete

## Test File
`desktop-app/tests/health-check-polling.test.ts`

## Test Categories

### checkHealth (5 tests)
| Test | Description | Status |
|------|-------------|--------|
| should return healthy when endpoint responds with healthy status | Basic healthy response | PASS |
| should return unhealthy when endpoint responds with unhealthy status | Unhealthy response handling | PASS |
| should return unhealthy when HTTP status is not ok | HTTP error handling | PASS |
| should return unhealthy when fetch throws network error | Network error handling | PASS |
| should return unhealthy on timeout | Timeout handling with AbortController | PASS |

### checkHealthWithRetry (5 tests)
| Test | Description | Status |
|------|-------------|--------|
| should succeed on first attempt without retries | No retry needed | PASS |
| should retry on failure and succeed | Retry with eventual success | PASS |
| should fail after exhausting all retries | Max retries exceeded | PASS |
| should call onRetry callback on each retry | Callback invocation | PASS |
| should use exponential backoff for retries | Delay timing verification | PASS |

### startPolling (6 tests)
| Test | Description | Status |
|------|-------------|--------|
| should call health check immediately on start | Immediate first check | PASS |
| should poll at specified intervals | Interval timing | PASS |
| should call onStatusChange when status changes | Status change callback | PASS |
| should not call onStatusChange if status remains the same | Deduplication | PASS |
| should call onError when check fails | Error callback | PASS |
| should report error status when health check fails | Error state handling | PASS |

### stopPolling (3 tests)
| Test | Description | Status |
|------|-------------|--------|
| should stop polling when called | Stop functionality | PASS |
| should be safe to call multiple times | Idempotent stop | PASS |
| should allow restarting polling after stop | Restart capability | PASS |

### getCurrentStatus (3 tests)
| Test | Description | Status |
|------|-------------|--------|
| should return unknown before first check | Initial state | PASS |
| should return latest status after check | Status tracking | PASS |
| should return error status after failed check | Error state | PASS |

### isPolling (3 tests)
| Test | Description | Status |
|------|-------------|--------|
| should return false initially | Initial state | PASS |
| should return true after starting polling | Active state | PASS |
| should return false after stopping polling | Stopped state | PASS |

### getLastCheckTime (2 tests)
| Test | Description | Status |
|------|-------------|--------|
| should return null before first check | Initial state | PASS |
| should return timestamp after check | Timestamp tracking | PASS |

### configuration (1 test)
| Test | Description | Status |
|------|-------------|--------|
| should use custom health URL | URL configuration | PASS |

### waitForHealthy (4 tests)
| Test | Description | Status |
|------|-------------|--------|
| should resolve immediately if already healthy | Fast path | PASS |
| should poll until healthy | Polling success | PASS |
| should timeout if never becomes healthy | Timeout handling | PASS |
| should call onProgress callback | Progress callback | PASS |

## Mocking Strategy

### Global Fetch Mock
```typescript
const mockFetch = jest.fn();
global.fetch = mockFetch;
```

### Response Mocking
```typescript
// Healthy response
mockFetch.mockResolvedValueOnce({
  ok: true,
  json: async () => ({ status: 'healthy' }),
});

// Unhealthy response
mockFetch.mockResolvedValueOnce({
  ok: true,
  json: async () => ({ status: 'unhealthy' }),
});

// HTTP error
mockFetch.mockResolvedValueOnce({
  ok: false,
  status: 503,
});

// Network error
mockFetch.mockRejectedValueOnce(new Error('Network error'));
```

### Timeout Testing with AbortSignal
```typescript
mockFetch.mockImplementationOnce(
  (_url: string, options: { signal?: AbortSignal }) =>
    new Promise((resolve, reject) => {
      const timer = setTimeout(() => resolve(response), 200);
      if (options?.signal) {
        options.signal.addEventListener('abort', () => {
          clearTimeout(timer);
          reject(new Error('Request aborted due to timeout'));
        });
      }
    })
);
```

## Test Patterns

### Testing Retry Logic
```typescript
it('should retry on failure and succeed', async () => {
  mockFetch
    .mockRejectedValueOnce(new Error('Connection refused'))
    .mockRejectedValueOnce(new Error('Connection refused'))
    .mockResolvedValueOnce({
      ok: true,
      json: async () => ({ status: 'healthy' }),
    });

  const result = await healthCheckManager.checkHealthWithRetry({
    maxRetries: 3,
    initialDelayMs: 10,
    maxDelayMs: 50,
  });

  expect(result.healthy).toBe(true);
  expect(result.retryCount).toBe(2);
  expect(mockFetch).toHaveBeenCalledTimes(3);
});
```

### Testing Polling
```typescript
it('should call onStatusChange when status changes', async () => {
  const onStatusChange = jest.fn();
  let callCount = 0;

  mockFetch.mockImplementation(() => {
    callCount++;
    if (callCount === 1) {
      return Promise.resolve({
        ok: true,
        json: async () => ({ status: 'healthy' }),
      });
    }
    return Promise.resolve({
      ok: true,
      json: async () => ({ status: 'unhealthy' }),
    });
  });

  healthCheckManager.startPolling({
    intervalMs: 100,
    onStatusChange,
  });

  await new Promise(resolve => setTimeout(resolve, 180));
  healthCheckManager.stopPolling();

  expect(onStatusChange).toHaveBeenCalledTimes(2);
  expect(onStatusChange).toHaveBeenNthCalledWith(1, 'healthy', undefined);
  expect(onStatusChange).toHaveBeenNthCalledWith(2, 'unhealthy', undefined);
});
```

### Testing Exponential Backoff
```typescript
it('should use exponential backoff for retries', async () => {
  const startTime = Date.now();
  const delays: number[] = [];
  let lastCheckTime = startTime;

  mockFetch.mockImplementation(() => {
    const now = Date.now();
    delays.push(now - lastCheckTime);
    lastCheckTime = now;
    return Promise.reject(new Error('Connection refused'));
  });

  await healthCheckManager.checkHealthWithRetry({
    maxRetries: 2,
    initialDelayMs: 20,
    maxDelayMs: 100,
    backoffMultiplier: 2,
  });

  expect(delays[0]).toBeLessThan(50); // First call - near immediate
  expect(delays[1]).toBeGreaterThanOrEqual(15); // ~20ms delay
  expect(delays[2]).toBeGreaterThanOrEqual(35); // ~40ms delay (2x)
});
```

## Bug Found and Fixed

During testing, a bug was discovered in the `startPolling` method where `unhealthy` status was incorrectly being reported as `error`:

**Original (buggy) code:**
```typescript
if (result.healthy) {
  newStatus = result.status === 'healthy' ? 'healthy' : 'unhealthy';
} else {
  newStatus = 'error'; // BUG: unhealthy also falls here
}
```

**Fixed code:**
```typescript
if (result.error) {
  newStatus = 'error';
} else if (result.status) {
  newStatus = result.status === 'healthy' ? 'healthy' : 'unhealthy';
} else {
  newStatus = 'error';
}
```

## Test Timing
- Uses real timers with short intervals (10-100ms) instead of fake timers
- Tests include appropriate timeouts (10000ms) for async operations
- Polling tests use `--forceExit` to prevent hanging

## Coverage Areas
- Health check success/failure paths
- Timeout handling with AbortController
- Retry logic with exponential backoff
- Polling lifecycle (start/stop/restart)
- Status change deduplication
- Callback invocations (onRetry, onStatusChange, onError, onProgress)
- Configuration options
