# T013.5 Docker Daemon Handling - Test Log

## Test Execution Summary
**Date**: 2025-12-07
**Tests**: 25+ | **Status**: Written (pending npm install)

## Test File
`desktop-app/tests/docker-daemon-detection.test.ts`

## Test Categories

### checkDaemonStatus (4 tests)
| Test | Description |
|------|-------------|
| should detect when Docker daemon is not running | DAEMON_NOT_RUNNING detection |
| should detect when Docker is not installed (ENOENT) | DOCKER_NOT_INSTALLED detection |
| should detect permission denied errors | PERMISSION_DENIED detection |
| should return running=true when daemon responds | Healthy daemon state |

### getFullStatus with daemon not running (3 tests)
| Test | Description |
|------|-------------|
| should return containerState=unknown when daemon not running | Unknown state handling |
| should not check container status if daemon not running | Skip container check |
| should include timestamp even when daemon not running | Timestamp always present |

### isDockerAvailable (3 tests)
| Test | Description |
|------|-------------|
| should return true when Docker CLI is installed | CLI available |
| should return false when Docker CLI is not installed | CLI not found |
| should return false on timeout | Timeout handling |

### getDaemonError (4 tests)
| Test | Description |
|------|-------------|
| should provide user-friendly message for daemon not running | DAEMON_NOT_RUNNING message |
| should provide user-friendly message for Docker not installed | DOCKER_NOT_INSTALLED message |
| should provide user-friendly message for permission errors | PERMISSION_DENIED message |
| should return null when daemon is running | No error when healthy |

### waitForDaemon (4 tests)
| Test | Description |
|------|-------------|
| should resolve immediately if daemon is already running | Fast path success |
| should retry until daemon starts | Retry with eventual success |
| should timeout if daemon never starts | Timeout with failure |
| should call onRetry callback | Callback invocation |

### Docker Error Classification (4 tests)
| Test | Description |
|------|-------------|
| should classify "Cannot connect" as DAEMON_NOT_RUNNING | Pattern matching |
| should classify ENOENT as DOCKER_NOT_INSTALLED | Pattern matching |
| should classify "permission denied" as PERMISSION_DENIED | Pattern matching |
| should classify unknown errors as UNKNOWN_ERROR | Fallback classification |

## Mocking Strategy

### child_process Mock
```typescript
const mockSpawn = jest.fn();
jest.mock('child_process', () => ({
  spawn: mockSpawn,
}));
```

### Mock Process Factory
```typescript
function createMockProcess(options: {
  closeCode: number;
  stdout?: string;
  stderr?: string;
  delay?: number;
}) {
  const mockProcess = {
    stdout: { on: jest.fn() },
    stderr: { on: jest.fn() },
    on: jest.fn((event, callback) => {
      if (event === 'close') {
        setTimeout(() => callback(closeCode), delay);
      }
    }),
  };
  return mockProcess;
}

function createMockProcessWithError(errorMessage: string) {
  return {
    stdout: { on: jest.fn() },
    stderr: { on: jest.fn() },
    on: jest.fn((event, callback) => {
      if (event === 'error') {
        callback(new Error(errorMessage));
      }
    }),
  };
}
```

## Test Patterns

### Testing Error Detection
```typescript
it('should detect when Docker daemon is not running', async () => {
  const mockProcess = createMockProcess({
    closeCode: 1,
    stderr: 'Cannot connect to the Docker daemon',
  });
  mockSpawn.mockReturnValue(mockProcess);

  const status = await dockerManager.checkDaemonStatus();

  expect(status.isDaemonRunning).toBe(false);
  expect(status.error).toContain('Cannot connect');
});
```

### Testing User-Friendly Messages
```typescript
it('should provide user-friendly message for daemon not running', async () => {
  const mockProcess = createMockProcess({
    closeCode: 1,
    stderr: 'Cannot connect to the Docker daemon',
  });
  mockSpawn.mockReturnValue(mockProcess);

  const error = await dockerManager.getDaemonError();

  expect(error.code).toBe('DAEMON_NOT_RUNNING');
  expect(error.message).toContain('Docker');
  expect(error.suggestion).toBeDefined();
});
```

### Testing Retry Logic
```typescript
it('should retry until daemon starts', async () => {
  const failProcess = createMockProcess({
    closeCode: 1,
    stderr: 'Daemon not running',
  });
  const successProcess = createMockProcess({
    closeCode: 0,
    stdout: '24.0.7',
  });

  mockSpawn
    .mockReturnValueOnce(failProcess)
    .mockReturnValueOnce(failProcess)
    .mockReturnValueOnce(successProcess);

  const result = await dockerManager.waitForDaemon(10000, 100);

  expect(result.success).toBe(true);
  expect(mockSpawn).toHaveBeenCalledTimes(3);
});
```

### Testing Classification
```typescript
it('should classify "Cannot connect" as DAEMON_NOT_RUNNING', async () => {
  const mockProcess = createMockProcess({
    closeCode: 1,
    stderr: 'Cannot connect to the Docker daemon at unix:///var/run/docker.sock',
  });
  mockSpawn.mockReturnValue(mockProcess);

  const error = await dockerManager.getDaemonError();
  expect(error?.code).toBe('DAEMON_NOT_RUNNING');
});
```

## Coverage Areas
- Error detection from stderr patterns
- Error classification logic
- User-friendly message generation
- Retry/polling mechanism
- Timeout handling
- Callback invocation
- Edge cases (empty stderr, unknown errors)

## Notes
- All tests mock child_process.spawn
- Factory functions ensure consistent mock behavior
- Timeout tests use Jest's extended timeout (5000-15000ms)
- Tests verify error codes, messages, and suggestions
